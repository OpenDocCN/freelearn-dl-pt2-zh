- en: Heuristic Search Techniques and Logical Inference
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式搜索技术和逻辑推理
- en: In this chapter, we will introduce a broad range of problem-solving tools. We
    will start by looking at ontologies and knowledge-based reasoning before moving
    on to optimization in the context of **Boolean satisfiability** (**SAT**) and
    combinatorial optimization, where we'll simulate the result of individual behavior and
    coordination in society. Finally, we'll implement Monte Carlo tree search to find
    the best moves in chess.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一系列问题解决工具。我们将从本体论和基于知识的推理开始，然后转向**布尔可满足性** (**SAT**)和组合优化的优化，其中我们将模拟个体行为和社会协调的结果。最后，我们将实现蒙特卡洛树搜索以找到国际象棋中的最佳着法。
- en: We'll be dealing with various techniques in this chapter, including logic solvers,
    graph embeddings, **genetic algorithms** (**GA**), **particle swarm optimization**
    (**PSO**), SAT solvers, **simulated annealing** (**SA**), ant colony optimization,
    multi-agent systems, and Monte Carlo tree search.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涉及各种技术，包括逻辑求解器、图嵌入、**遗传算法** (**GA**)、**粒子群优化** (**PSO**)、SAT求解器、**模拟退火**
    (**SA**)、蚁群优化、多主体系统和蒙特卡洛树搜索。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Making decisions based on knowledge
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于知识做出决策
- en: Solving the n-queens problem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决n皇后问题
- en: Finding the shortest bus route
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找最短的公交路线
- en: Simulating the spread of a disease
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟疾病的传播
- en: Writing a chess engine with Monte Carlo tree search
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写带有蒙特卡洛树搜索的国际象棋引擎
- en: Let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Making decisions based on knowledge
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于知识做出决策
- en: When a lot of background knowledge is available about a topic, why not use it
    when making decisions? This is called a knowledge-based system. Inference engines
    in expert systems and unification, as done in logic solvers, are examples of this.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当关于一个主题有大量背景知识可用时，为什么不在做出决策时使用它？这被称为基于知识的系统。专家系统中的推理引擎和逻辑求解器中的统一化就是其中的例子。
- en: Another way to retrieve knowledge when making decisions is based on representing
    knowledge in a graph. Every node in the graph represents a concept, while every
    edge represents a relationship. Both can be embedded and represented as numerical
    features that express their location with respect to the other elements of the
    graph.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出决策时，另一种检索知识的方式是基于在图中表示知识。图中的每个节点表示一个概念，而每条边表示一种关系。两者都可以嵌入并表示为表达它们与图中其他元素位置关系的数值特征。
- en: In this recipe, we'll go through two examples for each of these possibilities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将为每种可能性举例两次。
- en: From Aristotle to Linnaeus to today's mathematicians and physicists, people
    have tried to put order into the world by categorizing objects into a systematic
    order, called taxonomy. Mathematically, taxonomies are expressed as graphs, which
    represent information as tuples *(s, o), *in that subject s which is connected
    to object o; or triplets *(s, p, o)*, in that *a* is related to (a predicate of)* p* to
    *o*. A frequently used type of taxonomy is the ISA taxonomy, where relationships
    are of the type is*-a*. For example, a car is a vehicle, and a plane is also a
    vehicle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从亚里士多德到林奈再到今天的数学家和物理学家，人们试图通过将对象分类到系统顺序中来对世界进行排序，这被称为分类学。在数学上，分类法被表示为图，它表示信息作为元组*(s,
    o)*，其中主题s与对象o相连；或者三元组*(s, p, o)*，其中主题a与谓词p相关联到o。经常使用的一种类型是ISA分类法，其中关系为is-a类型。例如，汽车是车辆，飞机也是车辆。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we'll use a logic solver interfaced from the `nltk` (**natural
    language toolkit**) library from Python, and then use the graph libraries known
    as `networkx` and `karateclub`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用从Python的`nltk` (**自然语言工具包**)库接口的逻辑求解器，然后使用被称为`networkx`和`karateclub`的图库。
- en: 'The `pip` command you''ll need to use to download these libraries is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用的`pip`命令如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For the second part of this recipe, we'll also need to download the zoo dataset
    from Kaggle, which is available at [https://www.kaggle.com/uciml/zoo-animal-classification](https://www.kaggle.com/uciml/zoo-animal-classification).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方的第二部分，我们还需要从Kaggle下载动物园数据集，可在[https://www.kaggle.com/uciml/zoo-animal-classification](https://www.kaggle.com/uciml/zoo-animal-classification)获取。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: As we explained in the introduction to this recipe, we'll look at two different
    problems from two different approaches.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个配方的介绍中解释的那样，我们将从两种不同的方法来看待两个不同的问题。
- en: We'll start with logical reasoning using a logic solver.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用逻辑求解器开始进行逻辑推理。
- en: Logical reasoning
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑推理
- en: In this part of this recipe, we'll look at a simple example of logical reasoning
    using libraries bundled with the `nltk` library. There are many other ways to
    approach logical inference, some of which we'll look at in the *See also...* section
    at the end of this recipe.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方的这一部分，我们将使用`nltk`库捆绑的一些库来简单展示逻辑推理的一个示例。还有许多其他方法可以处理逻辑推理，我们将在配方末尾的*参考资料*部分中看到一些。
- en: We'll use a very simple toy problem that you could find in any *101 – Introduction
    to Logic* book, though a more complex approach to such problems could be taken.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个非常简单的玩具问题，你可以在任何*101 – 逻辑入门*书籍中找到，尽管解决这类问题的方法可以更复杂。
- en: 'Our problem is well-known: if all men are mortal, and Socrates is a man, is
    Socrates mortal?'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的问题是众所周知的：如果所有人类都是可死的，苏格拉底是一个人类，那么苏格拉底是可死的吗？
- en: 'We can express this very naturally in `nltk`, as shown here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`nltk`中非常自然地表达这个过程，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code gives us the following output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给出了以下输出：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The reasoning provided by the solver can also be read naturally, so we won't
    explain this here. We'll learn how this works internally in the *How it works...*
    section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 求解器提供的推理也可以很自然地阅读，所以我们不会在这里解释这个过程。我们将在*如何工作...*部分中学习其内部工作原理。
- en: Next, we'll look at knowledge embedding.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看知识嵌入。
- en: Knowledge embedding
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 知识嵌入
- en: In this part of this recipe, we'll try to make use of how information is interrelated
    by embedding it into a multidimensional space that can serve as part of featurization.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方的这一部分，我们将尝试利用信息如何相互关联，将其嵌入到一个可以作为特征化一部分的多维空间中。
- en: 'Here, we''ll load the data, preprocess it, embed it, and then test our embedding
    by classifying species, given their new features. Let''s get started:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将加载数据，预处理数据，嵌入数据，然后通过对其新特征进行分类来测试我们的嵌入效果。让我们开始吧：
- en: '**Dataset loading and preprocessing**: First, we''ll load the zoo dataset into
    pandas, as we''ve done many times already. Then, we''ll make sure that the binary
    columns are represented as `bool` instead of `int`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据集加载和预处理**：首先，我们将像之前那样将动物园数据集加载到 pandas 中。然后，我们将确保将二进制列表示为`bool`而不是`int`：'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The zoo dataset contains 101 animals, each with features describing whether
    it, for example, has hair or produces milk. Here, the target class is the biological
    class of the animal.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 动物园数据集包含101种动物，每种动物都有描述其是否有毛发或产奶等特征。这里，目标类别是动物的生物学类别。
- en: '**Graph embedding**: The `get_triplet()` function returns triplets for binary
    and integer elements in the format (*s*, *p*, *o*). Note that we create triplets
    from the full dataset, rather than just the training dataset. However, to avoid
    target leakage, we don''t create triplets from the target for data points outside
    the training set:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图嵌入**：`get_triplet()`函数以(*s*, *p*, *o*)的格式返回二进制和整数元素的三元组。注意，我们是从完整数据集中创建三元组，而不仅仅是训练集。但是，为了避免目标泄漏，我们不会从训练集外的数据点创建三元组：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code will create our triplets. Let''s take a look at some of
    them to get an idea of what they look like. The following are the first 20 entries
    we get; we used `triplets[:20]` to obtain them:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将创建我们的三元组。让我们看一些示例，了解它们的样子。以下是我们得到的前20个条目；我们使用`triplets[:20]`来获取它们：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code block shows a few examples of the resultant triplets. In
    total, we got 842 triplets out of 101 rows.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块展示了一些结果三元组的示例。总共，我们从101行中得到了842个三元组。
- en: 'Now, we can load this dataset into a graph using the `networkx` API:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`networkx` API将这个数据集加载到图中：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Vocabulary` class is a wrapper for the `label2id` and `id2label` dictionaries.
    We need this because some graph embedding algorithms don't accept string names
    for nodes or relationships. Here, we converted the concept labels into IDs before
    storing them in the graph.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vocabulary`类是`label2id`和`id2label`字典的包装器。我们需要这个类是因为一些图嵌入算法不接受节点或关系的字符串名称。在这里，我们在将概念标签存储到图中之前将其转换为ID。'
- en: 'Now, we can embed the graph numerically with different algorithms. We''ll use
    `Walklets` here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用不同的算法对图进行数值嵌入。这里我们将使用`Walklets`：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code shows that every concept in the graph will be represented
    by a 5-dimensional vector.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了图中每个概念将由一个5维向量表示。
- en: 'Now, we can test whether these features are useful for predicting the target
    (`the animal`):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试这些特征是否对预测目标（`动物`）有用：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output looks as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This looks quite good, though the technique only becomes really interesting
    if we have a knowledge base that goes beyond our training set. It is hard to show
    graph embedding without loading millions of triplets or huge graphs. We'll mention
    a few large knowledge bases in the following section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很不错，尽管这项技术只有在我们拥有超越训练集的知识库时才会变得真正有趣。在不加载数百万个三元组或庞大图表的情况下，很难展示图嵌入。我们将在接下来的小节中提到一些大型知识库。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this section, we'll look at the basic concepts behind this recipe, as well
    as its corresponding methods. First, we'll cover logical reasoning and logic provers,
    before looking at knowledge embedding and graph embedding with Walklets.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先涵盖逻辑推理和逻辑证明器，然后再看知识嵌入和Walklets图嵌入的基本概念。
- en: Logical reasoning
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑推理
- en: Logical reasoning is a term that bridges logical inference techniques such as
    deduction, induction, and abduction. **Abductive reasoning**, which is often used
    in expert systems, is the process of examining the available observations and
    deriving possible conclusions (the **best explanation**) from them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑推理是一个涵盖逻辑推断技术如演绎、归纳和引导的术语。**引导推理**，经常在专家系统中使用，是从现有观察中检查并推导可能结论（*最佳解释*）的过程。
- en: An expert system is a reasoning system that emulates the decision-making abilities
    of human experts. Expert systems are designed to solve complex problems by reasoning through
    bodies of knowledge, represented mainly as if-then-else rules (this is called
    a **knowledge base**).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 专家系统是一种模拟人类专家决策能力的推理系统。专家系统通过推理处理知识体系，主要以if-then-else规则表示（这称为*知识库*）。
- en: '**Inductive reasoning** is about determining a conclusion while following the
    initial premises and a rule. In **deductive reasoning**, we infer a rule from
    observations.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**归纳推理** 是在遵循初始前提和规则的情况下确定结论。在**演绎推理** 中，我们从观察中推断出一个规则。'
- en: 'To apply logical reasoning, a linguistic statement has to be encoded as a well-formed
    logical formula so that we can apply logical calculus. A well-formed formula can
    contain the following entities:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用逻辑推理，语言陈述必须编码为良好形式的逻辑公式，以便我们可以应用逻辑演算。良好形式的公式可以包含以下实体：
- en: Predicate symbols such as *P*
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言符号如 *P*
- en: The equality symbol, ![](img/545096dd-fa85-4d9d-a871-cdefbe354cef.png)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等号符号，![](img/545096dd-fa85-4d9d-a871-cdefbe354cef.png)
- en: Negation, ![](img/53c24013-9588-4000-a136-097c75269a05.png)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否定，![](img/53c24013-9588-4000-a136-097c75269a05.png)
- en: Binary connectives such as ![](img/98e2563b-94db-4ae8-afc4-4f8657c8ae33.png)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二元连接词如 ![](img/98e2563b-94db-4ae8-afc4-4f8657c8ae33.png)
- en: Quantifiers such as ![](img/75440140-643f-4d1a-a844-d114521c3111.png) (for all)
    and ![](img/0bf2d4e5-1c93-4fdb-8686-ab6e6004fc8d.png) (there exists).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量词如 ![](img/75440140-643f-4d1a-a844-d114521c3111.png)（对于所有）和 ![](img/0bf2d4e5-1c93-4fdb-8686-ab6e6004fc8d.png)（存在）。
- en: 'For example, the reasoning that *Socrates is a man. Man is mortal. Therefore,
    Socrates is mortal*, can be expressed as a logical statement using propositional
    logic, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，推理*Socrates是一个人。人是有限的。因此，苏格拉底是有限的*，可以用命题逻辑的逻辑陈述来表达，如下：
- en: '![](img/d8ac40e5-3dcc-4ed0-b84b-bcdf306724c8.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8ac40e5-3dcc-4ed0-b84b-bcdf306724c8.png)'
- en: Next, we'll look at logic provers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下逻辑证明器。
- en: Logic provers
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑证明器
- en: Automated theorem proving is a wide field that includes work based on logical
    theorems and mathematical formulas. We've already looked at the problem of proving
    a first-order logic equation that consists of logical equations. A search algorithm
    is combined with logical equations so that the satisfiability of a propositional
    formula can be decided on (see the *Solving the n-queens problem* recipe in this
    chapter), as well as the validity of a sentence, given a set of axioms. The *Resolution
    Theorem Prover* in `nltk` provides other functionality, such as unification, subsumption,
    and **question answering** (**QA**): [http://www.nltk.org/howto/resolution.html](http://www.nltk.org/howto/resolution.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 自动定理证明是一个广泛的领域，包括基于逻辑定理和数学公式的工作。我们已经看过证明由逻辑等式组成的一阶逻辑方程的问题。搜索算法与逻辑方程结合，以便确定命题公式的可满足性（参见本章中的*Solving
    the n-queens problem*配方），以及在给定一组公理的情况下句子的*有效性*。`nltk`中的*解析定理证明器*提供了其他功能，如统一化、包含、以及**问答**（**QA**）：[http://www.nltk.org/howto/resolution.html](http://www.nltk.org/howto/resolution.html)。
- en: In the next subsection, we'll look at knowledge embedding.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将看一下知识嵌入。
- en: Knowledge embedding
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 知识嵌入
- en: A **knowledge embedding** (**KE**) refers to the distributed representations
    of concepts derived from their relationships. These are often represented in a
    **knowledge graph** (**KG**).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识嵌入**（**KE**）指的是从概念关系中导出的分布式表示。这些通常在**知识图谱**（**KG**）中表示。'
- en: 'A well-known example of a KG is **WordNet** (G.A. Miller and others, *WordNet:
    An online lexical database*; 1990), which provides synonyms, hypernyms, and other
    expansions of words, similar to a thesaurus, and is available with different GUIs
    and an appropriate command line for all major operating systems. WordNet is available
    in more than 200 languages, and each word (synset) is related to other words over
    directed semantic relationships, such as hypernyms or hyponyms, meronyms or holonyms,
    and others.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[知识图谱](https://wiki.example.org/feynmans_learning_method)的一个著名示例是**WordNet**（G.A.
    Miller等人，《WordNet：一个在线词汇数据库》；1990年），它提供了单词的同义词、上义词和其他扩展，类似于一本词典，并且在所有主要操作系统中都有不同的GUI和适当的命令行。WordNet提供了200多种语言的版本，每个词（synset）都通过定向语义关系与其他词相关联，如上义词或下义词、部分或整体关系等。'
- en: KGs can be used in **natural language processing** (**NLP**) applications to
    support decision-making, where they can be used effectively as lookup engines
    or for reasoning.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 知识图谱可以在**自然语言处理**（**NLP**）应用中使用，以支持决策，它们可以有效地作为查找引擎或推理的工具。
- en: Knowledge embeddings are low-dimensional representations of concept relationships
    and can be extracted using embedding or more generic dimensionality reduction
    methods. In the next subsection, we'll look at the Walklet embedding method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 知识嵌入是概念关系的低维表示，可以使用嵌入或更通用的降维方法提取。在下一小节中，我们将看看Walklet嵌入方法。
- en: Graph embedding with Walklets
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用Walklets进行图嵌入
- en: The Walklet algorithm basically applies the Word2Vec skipgram algorithm to vertices
    in a graph, so instead of embeddings of words (the original application of Word2Vec),
    we'll get embeddings of concepts based on their connections. The Walklet algorithm subsamples
    short random walks on the vertices of a graph, as paths, which are then passed
    to the shallow neural network (see the following diagram) for skipgram training.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Walklet算法基本上将Word2Vec skipgram算法应用于图中的顶点，因此我们将根据它们的连接而不是单词（Word2Vec的原始应用）获得概念的嵌入。Walklet算法在图的顶点上对短随机行走进行子采样，作为路径传递给浅层神经网络（见下图），用于skipgram训练。
- en: The skipgram algorithm (Mikolov and others 2013; [https://arxiv.org/abs/1301.3781](https://arxiv.org/abs/1301.3781))
    predicts the context of words (that is, vertices) based on the word itself. Each
    word is featurized as a continuous bag of words vector (in practice, each word
    gets indexed in a dictionary that we use), and we predict the indexes of the surrounding
    words (concepts) based on hidden layer projection. The dimensionality of this
    hidden layer's projection and the window size of the context are the main parameters
    of the algorithm. After training, we use the hidden layer as the embedding.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: skipgram算法（Mikolov等人，2013年；[https://arxiv.org/abs/1301.3781](https://arxiv.org/abs/1301.3781)）根据单词本身预测单词（即顶点）的上下文。每个单词被表示为连续的词袋向量（实际上，每个单词都在我们使用的字典中得到索引），我们预测基于隐藏层投影的周围单词（概念）的索引。该隐藏层投影的维度和上下文的窗口大小是算法的主要参数。训练后，我们使用隐藏层作为嵌入。
- en: 'The following diagram illustrates the skipgram network architecture, which
    contains an input layer, a hidden layer, and an output layer of word predictions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了skipgram网络架构，包括输入层、隐藏层和单词预测的输出层：
- en: '![](img/7fed0371-75d1-4335-9469-b7c20c468b6d.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fed0371-75d1-4335-9469-b7c20c468b6d.png)'
- en: '*w(t)* refers to the current word (or concept), while *w(t-2)*, *w(t-1)*, *w(t+1)*,
    and *w(t+2)* refer to two words before and after, respectively. We predict the
    word context based on the current word. As we''ve already mentioned, the size
    of the context (window size) is a hyperparameter of the skipgram algorithms.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*w(t)*指的是当前单词（或概念），而*w(t-2)*、*w(t-1)*、*w(t+1)*和*w(t+2)*指的是当前单词之前和之后的两个单词。我们根据当前单词预测单词上下文。正如我们已经提到的，上下文的大小（窗口大小）是skipgram算法的超参数。'
- en: A related algorithm is the **continuous bag-of-words algorithm** (**CBOW**),
    where the architecture is inverted - we predict a single word based on the context.
    Both are based on the hypothesis that words that co-occur have related meaning
    or that they have distributional similarity, which implies that they are similar
    in terms of their meaning. This is called a **distributional hypothesis** (Harris,
    1954, *Distributional structure*).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的算法是**连续词袋算法**（**CBOW**），其中架构被倒置 - 我们根据上下文预测单个词。两者都基于这样一个假设：共同出现的词具有相关的含义或分布相似性，这意味着它们在意义上是相似的。这被称为**分布假设**（Harris,
    1954, *Distributional structure*）。
- en: The Walklet algorithm performs well on large graphs and – since it's a neural
    network – can be trained online. You can find out more about Walklets in the 2017
    paper by Brian Perozzi and others, *Don't Walk, Skip! Online Learning of Multi-scale** Network
    Embeddings*([https://arxiv.org/abs/1605.02115](https://arxiv.org/abs/1605.02115)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Walklet算法在大型图上表现良好，并且由于它是神经网络，可以在线训练。关于Walklets的更多信息可以在Brian Perozzi等人的2017年论文*Don't
    Walk, Skip! Online Learning of Multi-scale** Network Embeddings*中找到（[https://arxiv.org/abs/1605.02115](https://arxiv.org/abs/1605.02115)）。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The following are libraries that can be used for logical inference in Python:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是用于Python中逻辑推理的库：
- en: SymPy: [https://docs.sympy.org/latest/modules/logic.html](https://docs.sympy.org/latest/modules/logic.html)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SymPy：[https://docs.sympy.org/latest/modules/logic.html](https://docs.sympy.org/latest/modules/logic.html)
- en: Kanren logic programming: [https://github.com/logpy/logpy](https://github.com/logpy/logpy)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kanren逻辑编程：[https://github.com/logpy/logpy](https://github.com/logpy/logpy)
- en: PyDatalog: [https://sites.google.com/site/pydatalog/](https://sites.google.com/site/pydatalog/)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyDatalog：[https://sites.google.com/site/pydatalog/](https://sites.google.com/site/pydatalog/)
- en: We've been following the inference guide in `nltk` for this recipe. You can
    find more tools at the official `nltk` website: [http://www.nltk.org/howto/inference.html](http://www.nltk.org/howto/inference.html).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在`nltk`的推理指南中遵循推理的指导。你可以在官方`nltk`网站找到更多工具：[http://www.nltk.org/howto/inference.html](http://www.nltk.org/howto/inference.html)。
- en: 'Some other libraries for graph embedding are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用于图嵌入的其他库如下：
- en: KarateClub: [https://karateclub.readthedocs.io/en/latest/index.html](https://karateclub.readthedocs.io/en/latest/index.html)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KarateClub：[https://karateclub.readthedocs.io/en/latest/index.html](https://karateclub.readthedocs.io/en/latest/index.html)
- en: pykg2vec: [https://github.com/Sujit-O/pykg2vec](https://github.com/Sujit-O/pykg2vec)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pykg2vec：[https://github.com/Sujit-O/pykg2vec](https://github.com/Sujit-O/pykg2vec)
- en: PyTorch BigGraph (by Facebook Research): [https://github.com/facebookresearch/PyTorch-BigGraph](https://github.com/facebookresearch/PyTorch-BigGraph)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyTorch BigGraph（由Facebook Research提供）：[https://github.com/facebookresearch/PyTorch-BigGraph](https://github.com/facebookresearch/PyTorch-BigGraph)
- en: GraphVite: [https://graphvite.io/](https://graphvite.io/)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphVite：[https://graphvite.io/](https://graphvite.io/)
- en: AmpliGraph (by Accenture): [https://docs.ampligraph.org/](https://docs.ampligraph.org/)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmpliGraph（由Accenture提供）：[https://docs.ampligraph.org/](https://docs.ampligraph.org/)
- en: pyRDF2Vec: [https://github.com/IBCNServices/pyRDF2Vec](https://github.com/IBCNServices/pyRDF2Vec)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pyRDF2Vec：[https://github.com/IBCNServices/pyRDF2Vec](https://github.com/IBCNServices/pyRDF2Vec)
- en: KarateClub, which is maintained by Benedek Rozemberczki, a PhD student at the
    University of Edinburgh, contains many implementations of unsupervised graph embedding
    algorithms.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: KarateClub由爱丁堡大学的博士生Benedek Rozemberczki维护，包含许多无监督图嵌入算法的实现。
- en: 'Some graph libraries provide link prediction as well. This means that, for
    a given set of nodes, you can infer whether a relationship to other nodes exists.
    A review of link prediction can be found in *Knowledge Graph Embedding for Link
    Prediction: A Comparative Analysis*, by Andrea Rossi and others. (2020; [https://arxiv.org/abs/2002.00819](https://arxiv.org/abs/2002.00819)).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '一些图库还提供链路预测。这意味着对于给定的节点集合，您可以推断是否存在与其他节点的关系。关于链路预测的评论可以在Andrea Rossi等人的论文*Knowledge
    Graph Embedding for Link Prediction: A Comparative Analysis*中找到（2020； [https://arxiv.org/abs/2002.00819](https://arxiv.org/abs/2002.00819)）。'
- en: 'Some resources for reasoning about the real world and/or with common sense
    are as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关于推理真实世界和/或常识的资源如下：
- en: 'ActionCores: [http://www.actioncores.org/apidoc.html#pracinference](http://www.actioncores.org/apidoc.html#pracinference)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ActionCores：[http://www.actioncores.org/apidoc.html#pracinference](http://www.actioncores.org/apidoc.html#pracinference)
- en: KagNet: [https://github.com/INK-USC/KagNet](https://github.com/INK-USC/KagNet)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KagNet：[https://github.com/INK-USC/KagNet](https://github.com/INK-USC/KagNet)
- en: 'Allen AI Commonsense Knowledge Graphs: [https://mosaic.allenai.org/projects/commonsense-knowledge-graphs](https://mosaic.allenai.org/projects/commonsense-knowledge-graphs)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Allen AI Commonsense Knowledge Graphs: [https://mosaic.allenai.org/projects/commonsense-knowledge-graphs](https://mosaic.allenai.org/projects/commonsense-knowledge-graphs)'
- en: '*Commonsense Reasoning Problem Page* at NYU CS: [http://commonsensereasoning.org/problem_page.html](http://commonsensereasoning.org/problem_page.html)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Commonsense Reasoning Problem Page* at NYU CS: [http://commonsensereasoning.org/problem_page.html](http://commonsensereasoning.org/problem_page.html)'
- en: '*Learning on graphs: Open Graph Benchmark: Datasets for Machine Learning on
    Graphs, Hu and others, 2020* ([https://arxiv.org/pdf/2005.00687.pdf](https://arxiv.org/pdf/2005.00687.pdf))
    is another reference for graph embedding with machine learning.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*Learning on graphs: Open Graph Benchmark: Datasets for Machine Learning on
    Graphs, Hu and others, 2020* ([https://arxiv.org/pdf/2005.00687.pdf](https://arxiv.org/pdf/2005.00687.pdf))
    是关于使用机器学习进行图形嵌入的另一个参考文献。'
- en: 'There are several large real-world knowledge databases available, such as the
    following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个大型的现实世界知识数据库可供使用，例如以下内容：
- en: Wikidata: [https://www.wikidata.org/](https://www.wikidata.org/)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikidata: [https://www.wikidata.org/](https://www.wikidata.org/)
- en: 'Conceptnet5: [https://github.com/commonsense/conceptnet5](https://github.com/commonsense/conceptnet5)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Conceptnet5: [https://github.com/commonsense/conceptnet5](https://github.com/commonsense/conceptnet5)'
- en: The Open Multilingual Wordnet: [http://compling.hss.ntu.edu.sg/omw/](http://compling.hss.ntu.edu.sg/omw/)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The Open Multilingual Wordnet: [http://compling.hss.ntu.edu.sg/omw/](http://compling.hss.ntu.edu.sg/omw/)
- en: Yago: [https://github.com/yago-naga/yago3](https://github.com/yago-naga/yago3)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yago: [https://github.com/yago-naga/yago3](https://github.com/yago-naga/yago3)
- en: Solving the n-queens problem
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决n-皇后问题
- en: In mathematical logic, satisfiability is about whether a formula can be valid
    under some interpretation (parameters). We say that a formula is unsatisfiable
    if it can't be true under any interpretation. A **Boolean satisfiability problem**,
    or **SAT**, is all about whether a Boolean formula is valid (satisfiable) under
    any of the values of its parameters. Since many problems can be reduced to SAT
    problems, and solvers and optimizations for it exist, it is an important class
    of problems.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在数理逻辑中，可满足性是关于一个公式在某些解释（参数）下是否有效的问题。如果一个公式在任何解释下都不能成立，我们称其为不可满足。布尔可满足性问题（SAT）是关于一个布尔公式在其参数的任何值下是否有效（可满足）的问题。由于许多问题可以归约为SAT问题，并且存在针对它的求解器和优化方法，SAT问题是一个重要的问题类别。
- en: SAT problems have been proven to be NP-complete. NP-completeness (short for
    **nondeterministic polynomial time**) means that a solution to a problem can be
    verified in polynomial time. Note that this doesn't mean that a solution can be
    found quickly, only that a solution can be verified quickly. NP-complete problems
    are often approached with search heuristics and algorithms.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SAT问题已被证明是NP完全的。NP完全性（缩写为**非确定性多项式时间**）意味着问题的解决方案可以在多项式时间内验证。请注意，这并不意味着可以快速找到解决方案，只是可以快速验证解决方案。NP完全问题通常使用搜索启发式和算法来解决。
- en: In this recipe, we'll address a SAT problem in various ways. We'll take a relatively
    simple and well-studied case known as the n-queens problem, where we try to place
    queens on a chessboard of *n* by *n* squares so that any column, row, and diagonal
    can only take, at most, one queen.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将以多种方式解决SAT问题。我们将以一个相对简单且深入研究的案例来解释，即n-皇后问题，其中我们尝试在一个*n*乘*n*的棋盘上放置皇后，以使得任何列、行和对角线最多只能放置一个皇后。
- en: First, we'll apply a GA, then PSO, and then a specialized SAT solver.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将应用遗传算法（GA），然后是粒子群优化（PSO），最后使用专门的SAT求解器。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll be using the `dd` solver for one of the approaches in this recipe. To
    install it, we also need the `omega` library. We can get both by using the `pip`
    command, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个配方中的一个方法中将使用`dd`求解器。要安装它，我们还需要`omega`库。我们可以使用`pip`命令获取这两个库，如下所示：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We'll use the dd SAT solver libraries later, but first, we'll look at some other
    algorithmic approaches.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将使用`dd` SAT求解器库，但首先我们将研究一些其他的算法方法。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll start with the GA.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从遗传算法（GA）开始。
- en: Genetic algorithm
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遗传算法
- en: 'First, we''ll define how a chromosome is represented and how it can mutate.
    Then, we''ll define a feedback loop for testing these chromosomes and changing
    them. We''ll explain the algorithm itself in the *How it works...* section, toward
    the end of this recipe. Let''s get started:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义染色体的表示方式和如何进行变异。然后，我们将定义一个反馈循环来测试和改变这些染色体。我们将在最后的*工作原理*部分详细解释算法本身。让我们开始吧：
- en: '**Representing a solution** (a chromosome): An object-oriented style lends
    itself to defining chromosomes. Let''s look at our implementation. First, we need
    to know what a chromosome is and what it does:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表示解决方案**（一个染色体）：面向对象的风格适合定义染色体。让我们看看我们的实现。首先，我们需要知道染色体是什么以及它的作用：'
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code creates our basic data structure, which contains a candidate
    solution that can replicate and mutate. This code refers to a cost function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了我们的基本数据结构，其中包含一个候选解决方案，可以复制和突变。此代码涉及成本函数。
- en: 'We need a cost function so that we know how to fit our genes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个成本函数，以便知道如何适应我们的基因：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can select genes based on this cost function (see the `fitness()` method).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据这个成本函数（见`fitness()`方法）选择基因。
- en: '**Writing the main algorithm**: The GA for the n-queens problem is as follows
    (we''ve omitted the visualization here):'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写主要算法**：N皇后问题的GA如下（我们在此省略了可视化）：'
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This class contains the population of chromosomes and can have methods applied
    to it (population control, if you like), such as what parents to use (`get_parents()`)
    and mating them (`cross_over()`). Take note of the `iterate()` method, which is
    where the main logic is implemented. We'll comment on the main decisions we've
    made here in the *How it works...* section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含染色体的种群，并可以对其应用方法（如果您喜欢的话，如`get_parents()`和`cross_over()`）。请注意`iterate()`方法，在这里实现了主要逻辑。我们将在*它的工作原理...*部分对我们在这里做出的主要决策进行评论。
- en: '**Running the algorithm**: We execute our algorithm by simply instantiating
    a `GeneticQueen` and calling `iterate()`. We can also put in a few extra lines
    to get regular updates and to collect fitness data over time. We then run the
    algorithm, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行算法**：我们通过简单地实例化一个`GeneticQueen`并调用`iterate()`来执行我们的算法。我们还可以添加几行额外的代码来定期更新并随时间收集适应性数据。然后，我们像这样运行算法：'
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, we can visualize the solution.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以可视化解决方案。
- en: 'If we run the preceding code, we''ll get a single run that looks like this
    (yours may look different):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，将得到一个看起来像这样的单次运行结果（您的结果可能会有所不同）：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code gives us the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码给出了以下输出：
- en: '![](img/ac966a3c-1d5d-4a9a-9d61-b5f3c6051cc9.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac966a3c-1d5d-4a9a-9d61-b5f3c6051cc9.png)'
- en: This took close to 8 seconds to complete.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作接近8秒才完成。
- en: 'The following plot shows the fitness of the best chromosome at each iteration
    of the algorithm:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了算法每次迭代中最佳染色体的适应性：
- en: '![](img/58a57946-e6ab-4001-a30c-753e83544296.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58a57946-e6ab-4001-a30c-753e83544296.png)'
- en: Here, we can see that the fitness of the algorithm doesn't always improve; it
    can also go down. We could have chosen to keep the best chromosome here. In that
    case, we wouldn't have seen any decline (but the potential downside is that we
    could have ended up in a local minimum).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到算法的适应性并不总是改善；它也可能下降。我们本可以选择在此处保留最佳染色体。在这种情况下，我们不会看到任何下降（但潜在的缺点是我们可能会陷入局部最小值）。
- en: Now, let's move on to PSO!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续PSO！
- en: Particle swarm optimization
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子群优化
- en: 'In this part of this recipe, we''ll be implementing a PSO algorithm for the
    n-queens problem from scratch. Let''s get started:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方的这一部分，我们将从头开始实现N皇后问题的PSO算法。让我们开始吧：
- en: '**Representing a solution**: Similar to the GA, we need to define what a solution
    looks like. In PSO, this means we define a particle:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表示解决方案**：与GA类似，我们需要定义解决方案的外观。在PSO中，这意味着我们定义一个粒子：'
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the main data structure that we'll be working with. It contains a candidate
    solution. Applying PSO will involve changing a bunch of these particles. We'll
    explain how `Particle` works in more detail in the *How it works...* section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要处理的主数据结构。它包含一个候选解决方案。应用PSO将涉及更改一堆这些粒子。我们将在*它的工作原理...*部分详细解释`Particle`的工作原理。
- en: We are going to use the same cost function that we defined for the GA. This
    cost function tells us how well our particles fit the given problem – in other
    words, how good a property vector is.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与我们为GA定义的相同成本函数。该成本函数告诉我们我们的粒子如何适应给定问题 - 换句话说，一个性质向量有多好。
- en: 'We''ll wrap our initialization and the main algorithm into a class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将初始化和主算法封装到一个类中：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `get_best_particle()` method returns the best configuration and the best
    score. Take note of the `iterate()` method, which updates our particles and returns
    the best particle, along with its score. Details regarding this update are provided
    in the *How it works...* section. The optimization process itself is done using
    a few formulas that are relatively simple.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_best_particle()`方法返回最佳配置和最佳分数。请注意`iterate()`方法，它更新我们的粒子并返回最佳粒子及其分数。关于此更新的详细信息在*工作原理...*部分提供。优化过程本身使用几个相对简单的公式完成。'
- en: 'We''ll also want to display our solutions. The code for showing the board positions
    is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想展示我们的解决方案。显示棋盘位置的代码如下：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the main algorithm for PSO:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是PSO的主算法：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similar to what we did in the case of the GA, we track how well our solutions
    do over the iterations (via our cost function). The main function returns the
    following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在GA案例中所做的，我们追踪解决方案在迭代中的表现（通过我们的成本函数）。主函数返回以下内容：
- en: '`best_particle`: The best solution'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`best_particle`：最佳解决方案'
- en: '`scores`: The best scores over our iterations'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scores`：我们迭代中的最佳分数'
- en: As we mentioned previously, we'll explain how all of this works in the *How
    it works...* section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们将在*工作原理...*部分解释所有这些内容的工作方式。
- en: You can view the output of the algorithm being run with *n = 8* at [https://github.com/PacktPublishing/Artificial-Intelligence-with-Python-Cookbook/blob/master/chapter05/solving-n-queens.md](https://github.com/PacktPublishing/Artificial-Intelligence-with-Python-Cookbook/blob/master/chapter05/solving-n-queens.md).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看使用*n = 8*运行的算法输出，网址为[https://github.com/PacktPublishing/Artificial-Intelligence-with-Python-Cookbook/blob/master/chapter05/solving-n-queens.md](https://github.com/PacktPublishing/Artificial-Intelligence-with-Python-Cookbook/blob/master/chapter05/solving-n-queens.md)。
- en: We are using the chess library for visualization here.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用棋盘库进行可视化。
- en: 'In the following plot, you can see the quality of the solutions over our iterations:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图表中，您可以看到解决方案在迭代中的质量：
- en: '![](img/1882e481-9689-40e1-bc00-9e98ff95a298.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1882e481-9689-40e1-bc00-9e98ff95a298.png)'
- en: Since all the particles maintain their own records of the best solution, the
    score can never decline. At iteration 1,323, we reached a solution and the algorithm
    stopped.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有粒子都保持其最佳解的记录，分数永远不会下降。在第1,323次迭代时，我们找到了一个解决方案，算法停止了。
- en: SAT solver
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SAT求解器
- en: This is heavily based on the example that can be found in the `dd` library,
    copyright of California Institute of Technology, at [https://github.com/tulip-control/dd/blob/0f6d16483cc13078edebac9e89d1d4b99d22991e/examples/queens.py](https://github.com/tulip-control/dd/blob/0f6d16483cc13078edebac9e89d1d4b99d22991e/examples/queens.py).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要基于可以在`dd`库中找到的示例，版权属于加州理工学院，网址为[https://github.com/tulip-control/dd/blob/0f6d16483cc13078edebac9e89d1d4b99d22991e/examples/queens.py](https://github.com/tulip-control/dd/blob/0f6d16483cc13078edebac9e89d1d4b99d22991e/examples/queens.py)。
- en: In a modern SAT solver in Python, we can define our constraints as simple functions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中的现代SAT求解器中，我们可以将约束定义为简单的函数。
- en: 'Basically, there''s one formula that incorporates all the constraints. Once
    all the constraints have been satisfied (or the conjunction of all the constraints),
    the solution is found:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，有一个公式包含所有约束条件。一旦所有约束条件满足（或所有约束条件的合取），就找到了解决方案：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s the constraint for `at_least_one_queen_per_row`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`at_least_one_queen_per_row`的约束条件：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we take disjunctions over the queens on each row.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对每行上的皇后进行析取。
- en: 'The main run looks like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 主运行如下所示：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we run this, we should see an example solution. We should also get some
    statistics regarding how many solutions were found and how long it took to find them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，应该看到一个示例解决方案。我们还应该得到一些关于找到多少解决方案以及花费多长时间找到它们的统计信息。
- en: 'The following is our example solution for the eight queens problem:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是八皇后问题的示例解决方案：
- en: '![](img/adf9eaae-ec96-44ba-aa1f-6f99090ae6a4.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adf9eaae-ec96-44ba-aa1f-6f99090ae6a4.png)'
- en: 'The textual output looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 文本输出如下所示：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This solver not only got all the solutions (we only visualized one of them)
    but was also about twice as fast as the GA!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此求解器不仅获得了所有的解决方案（我们只显示了其中一个），而且比遗传算法快大约两倍！
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this section, we'll explain the different approaches we employed in this
    recipe, starting with the GA.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释在此配方中使用的不同方法，从遗传算法开始。
- en: Genetic algorithm
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遗传算法
- en: 'The GA is quite simple at heart: we maintain a set of candidate solutions (called
    chromosomes) and we have two operations we can use to change them:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，遗传算法很简单：我们维护一组候选解决方案（称为染色体），并且我们有两种操作可以用来改变它们：
- en: '`cross-over`: Two chromosomes have children (which means they mix)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cross-over`：两个染色体产生子代（这意味着它们混合）'
- en: '`mutation:` A chromosome changes randomly'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mutation:` 染色体随机变化'
- en: A chromosome has a candidate solution that's stored in `configuration`. When
    initializing a chromosome, we have to give it either the number of queens or the
    initial configuration. We covered what chromosomes actually are previously in
    this chapter. If a configuration is not given, then we need to create one with
    a list comprehension, such as `[random.randint(1, nq) for _ in range(nq)]`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个染色体存储在`configuration`中的候选解决方案。在初始化染色体时，我们必须给它皇后的数量或者初始配置。在本章的前文中，我们已经讨论了染色体的实际含义。如果没有给定配置，则需要使用列表推导创建一个，比如`[random.randint(1,
    nq) for _ in range(nq)]`。
- en: A chromosome can calculate its own fitness; here, we used the same cost function
    that we used previously, but this time, we scaled it to be between 0 and 1, where
    1 means we found a solution and anything in-between shows how close we are to
    getting a solution. A chromosome can also mutate itself; that is, it can randomly
    change one of its values.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个染色体可以计算自己的适应度；在这里，我们使用了先前使用的相同成本函数，但这次我们将其缩放到0到1之间，其中1表示我们找到了一个解决方案，介于其中的任何值显示我们距离解决方案有多接近。染色体也可以对自己进行突变；也就是说，它可以随机改变其值之一。
- en: 'At each iteration of the algorithm, we create a new generation of chromosomes
    by using these two operations. The algorithm itself is straightforward:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的每一次迭代，我们都通过这两个操作创建新的染色体代。
- en: First, we initialize our first generation of chromosomes with different values
    representing the different parameters of the solution.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用代表解决方案不同参数的不同值初始化我们的第一代染色体。
- en: Then, we calculate the fitness of our chromosomes. This can be done by interacting
    with the environment or it could be intrinsic to the solution, as in our combinatorial
    problem of the nine queens problem.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们计算我们的染色体的适应度。这可以通过与环境的交互来完成，或者它可能是解决方案本身固有的，就像我们的九皇后问题的组合问题一样。
- en: 'Next, we create a new generation of chromosomes, as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们按以下方式创建新的染色体代：
- en: Choose parents while taking their fitness into account
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在考虑其适应度的情况下选择父母
- en: Mutate a few chromosomes according to a certain probability
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据一定的概率突变几个染色体
- en: Finally, we repeat from *Step 2* until the fitness is high enough or we have
    iterated a lot.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从*第2步*开始重复，直到适应度足够高或者我们已经迭代了很多次。
- en: We've expressed the last step very loosely here. Basically, we can decide when
    the fitness is high enough and how many times we want to iterate. These are our
    stopping criteria.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里非常宽泛地表达了最后一步。基本上，我们可以决定何时适应度足够高以及我们想要迭代多少次。这些是我们的停止标准。
- en: 'This is very legible in our implementation of `GeneticQueen.iterate()`, so
    let''s have another look for visualization purposes (only slightly simplified):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们的`GeneticQueen.iterate()`的实现中非常清晰，因此为了可视化目的，让我们再看一眼（仅稍微简化）：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A major decision we have to make regarding the GA is whether we maintain the
    best solution or whether all the chromosomes (even the best) must die (potentially
    after giving birth to offspring). Here, each iteration creates a completely new
    generation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于遗传算法（GA），我们必须做出的一个重要决策是是否保留最佳解决方案，或者是否所有染色体（包括最佳的）都必须死亡（可能在产生后代后）。在这里，每次迭代都会创建一个全新的代。
- en: We randomly choose parents by weighting them by their fitness, where the fittest
    are more likely to be chosen. The `cross-over` function in our implementation
    randomly decides between two of the parents for each parameter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过按其适应度加权随机选择父母，其中适应度最高的被选择的可能性更大。在我们的实现中，`cross-over`函数会随机在每个参数中的两个父母之间做出决策。
- en: 'The main hyperparameters and major decisions that must be made for the GA are
    as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为GA必须做出的主要超参数和主要决策如下：
- en: Population size (how many chromosomes do we have?)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 种群大小（我们有多少染色体？）
- en: Mutation rate (how much do chromosomes change when they mutate?)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异率（染色体变异时变化的程度是多少？）
- en: How many (and which) chromosomes create offspring? Typically, these are the
    ones with the highest fitness.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多少（以及哪些）染色体产生后代？通常这些是具有最高适应度的染色体。
- en: What are our stopping criteria? Typically, there's a threshold value for the
    algorithm's fitness and a set number of iterations.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的停止标准是什么？通常，算法的适应度有一个阈值，并且有一个设定的迭代次数。
- en: As we can see, the GA is quite flexible and very intuitive. In the next section,
    we'll look at PSO.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，遗传算法非常灵活且直观。在接下来的部分，我们将看看PSO。
- en: Particle swarm optimization
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子群优化（Particle Swarm Optimization，PSO）
- en: We started our implementation with the `Particle` data structure. To initialize
    a particle, we pass the number of queens (`N`) or the vectors for our velocities
    and parameters. Basically, a particle has a configuration, or a set of parameters –
    a vector, in this case – that fits a problem to a certain degree (`current_particle`),
    and a velocity (similar to a learning rate). Each property vector from a particle
    represents the queens' positions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以`Particle`数据结构开始我们的实现。要初始化一个粒子，我们传入皇后数量（`N`）或者我们的速度和参数向量。基本上，一个粒子有一个配置，或者说一组参数
    - 在这种情况下是一个向量，它与问题的某个程度匹配（`current_particle`），以及一个速度（类似于学习率）。每个粒子的属性向量表示皇后的位置。
- en: PSO then applies changes to particles in a particular way. PSO is a combination
    of local search and global search; that is, at each particle, we try to direct
    our search toward the best particle globally and the best the particle has been
    in the past. A particle maintains a record of its best instantiation; that is,
    the vector of its best parameters and the corresponding score. We also maintain
    the corresponding velocities of the parameters. These velocities can slow down,
    increase, or change direction according to the formula being used.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: PSO然后以特定的方式对粒子应用变化。PSO结合了局部搜索和全局搜索；也就是说，在每个粒子处，我们试图将搜索引导向全局最佳粒子和过去最佳粒子。一个粒子保持其最佳实例的记录；也就是说，其最佳参数的向量和相应的得分。我们还保持参数的相应速度。这些速度可以根据正在使用的公式而减慢、增加或改变方向。
- en: 'PSO takes a few parameters, as follows (most of these were named in our implementation;
    here, we''re omitting the ones that are specific to our nine queens problem):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: PSO需要一些参数，如下所示（大多数这些在我们的实现中已命名；这里省略了那些特定于我们的九皇后问题的参数）：
- en: '`omega`: The decay parameter'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`omega`：衰减参数'
- en: '`phip`: Controls the contribution of the local search'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phip`：控制局部搜索的贡献'
- en: '`phig`: Controls the contribution of the global search'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phig`：控制全局搜索的贡献'
- en: '`n_particles`: The number of particles'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_particles`：粒子的数量'
- en: '`max_iterations`: Used for early stopping without a solution'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_iterations`：用于没有解决方案的提前停止'
- en: In our PSO problem, there were two deltas, `delta_p` and `delta_g`, where *p*
    and *g* stand for particle and global, respectively. This is because of one of
    them is calculated with respect to the particle's historic best and the other
    is calculated with respect to the particle's global best.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的PSO问题中，有两个增量，`delta_p` 和 `delta_g`，其中 *p* 和 *g* 分别代表粒子（particle）和全局（global）。这是因为其中一个是根据粒子的历史最佳计算的，另一个是根据粒子的全局最佳计算的。
- en: 'The update is calculated according to the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 更新根据以下代码计算：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `rp` and `rg` are random numbers and `phip` and `phig` are the local and
    global factors, respectively. They refer to either a unique particle or all the
    particles, as shown in the `delta_p` and `delta_g` variables.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`rp` 和 `rg` 是随机数，`phip` 和 `phig` 分别是局部和全局因子。它们分别指一个唯一的粒子或所有粒子，如`delta_p`
    和 `delta_g` 变量所示。
- en: 'There''s also another parameter, `omega`, that regulates the decay of the current
    velocities. At each iteration, the new velocities are calculated according to
    the following formula:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个参数 `omega`，它调节当前速度的衰减。在每次迭代中，根据以下公式计算新的速度：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In turn, the particle parameters are incremented according to their velocities.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，根据它们的速度递增粒子参数。
- en: Note that the algorithm is sensitive to what's chosen for `phip`, `phig`, and `omega`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，算法对于`phip`、`phig`和`omega`的选择非常敏感。
- en: Our cost function (or goodness function) calculates the score for a particle
    according to a given configuration of queens. This configuration is represented
    as a list of indexes in the range ]0, N-1[*.* For each pair of queens, the function
    checks whether they overlap either in the diagonal, vertical, or horizontal sense.
    Each non-conflicting check awards a point, so the maximal number of points is![](img/f0965a57-dba1-4252-a522-06eced1f26c9.png).
    This is 28 for the 8 queens problem.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的成本函数（或好度函数）根据给定的皇后配置为每个粒子计算分数。这个配置被表示为在范围]0, N-1[*.*中的索引列表对于每对皇后，函数检查它们是否在对角线、垂直或水平方向上重叠。每个不冲突的检查都给予一个点，因此最大的得分是![](img/f0965a57-dba1-4252-a522-06eced1f26c9.png)。这对于8皇后问题是28。
- en: SAT solver
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SAT 求解器
- en: There are lots of different ways **specialized satisfiability** (**SAT**) solvers
    work. A survey by Weiwei Gong and Xu Zhou (2017) provides a broad overview of
    the different approaches: [https://aip.scitation.org/doi/abs/10.1063/1.4981999](https://aip.scitation.org/doi/abs/10.1063/1.4981999).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的**专用可满足性**（**SAT**）求解器工作方式。Weiwei Gong 和 Xu Zhou（2017）的调查提供了对不同方法的广泛概述：[https://aip.scitation.org/doi/abs/10.1063/1.4981999](https://aip.scitation.org/doi/abs/10.1063/1.4981999)。
- en: The `dd` solver, which we used in our recipe, works using **binary decision
    diagrams** (**BDD**), which were introduced by Randal Bryant (*Graph-based algorithms
    for Boolean function manipulation*, 1986). Binary decision diagrams (sometimes
    called **branching programs**) are constraints represented as Boolean functions
    as opposed to other encodings, such as negation normal.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配方中使用的 `dd` 求解器，使用**二进制决策图**（**BDD**）工作，这些图是由 Randal Bryant（*基于图的布尔函数操作算法*，1986年）引入的。二进制决策图（有时称为**分支程序**）将约束表示为布尔函数，而不是其他编码方式，如否定范式。
- en: 'In a BDD, an algorithm or a set of constraints is expressed as a Boolean function
    over a Boolean domain of dimension, *n*, that evaluates to true or false:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BDD 中，一个算法或一组约束被表示为在维度为 *n* 的布尔域上的布尔函数，其评估为真或假：
- en: '![](img/a0c150ba-9740-4023-a19f-3ea43deae487.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0c150ba-9740-4023-a19f-3ea43deae487.png)'
- en: This means that we can represent problems as binary trees or, equivalently,
    as truth tables.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将问题表示为二叉树或等效地表示为真值表。
- en: 'To illustrate this, let''s look at an example. We can enumerate all the states
    over our binary variables (*x1*, *x2*, and *x3*) and then come up with a final
    state that''s the result of *f*. The following truth table summarizes the states
    of our variables, as well as our function evaluation:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们看一个例子。我们可以枚举所有关于我们的二进制变量（*x1*，*x2* 和 *x3*）的状态，然后得出一个最终状态，即 *f* 的结果。以下真值表总结了我们变量的状态，以及我们的函数评估：
- en: '| *x1* | *x2* | *x3* | *f* |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| *x1* | *x2* | *x3* | *f* |'
- en: '| False | False | False | False |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| False | False | False | False |'
- en: '| False | False | True | False |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| False | False | True | False |'
- en: '| False | True | False | False |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| False | True | False | False |'
- en: '| False | True | True | False |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| False | True | True | False |'
- en: '| True | False | False | True |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| True | False | False | True |'
- en: '| True | False | True | False |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| True | False | True | False |'
- en: '| True | True | False | True |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| True | True | False | True |'
- en: '| True | True | True | True |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| True | True | True | True |'
- en: 'This corresponds to the following binary tree:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于以下二叉树：
- en: '![](img/ea715312-19c9-45ce-a2ae-bcc9a3124140.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea715312-19c9-45ce-a2ae-bcc9a3124140.png)'
- en: Binary trees and truth tables have highly optimized library implementations,
    which means they can run very fast. This explains how we got our results so quickly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树和真值表具有高度优化的库实现，因此它们可以运行非常快。这解释了我们如何如此快速地得到结果。
- en: See also
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'There are lots of other SAT solvers in Python, some of which are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中还有许多其他 SAT 求解器，其中一些如下所示：
- en: 'Microsoft''s PDP solver: [https://github.com/microsoft/PDP-Solver](https://github.com/microsoft/PDP-Solver)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft 的 PDP 求解器：[https://github.com/microsoft/PDP-Solver](https://github.com/microsoft/PDP-Solver)
- en: Z3, by Microsoft Research: [https://github.com/Z3Prover/z3](https://github.com/Z3Prover/z3)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z3，由微软研究院提供：[https://github.com/Z3Prover/z3](https://github.com/Z3Prover/z3)
- en: 'Python bindings to picosat, developed by Continuum: [https://github.com/ContinuumIO/pycosat](https://github.com/ContinuumIO/pycosat)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 绑定到 picosat，由 Continuum 开发：[https://github.com/ContinuumIO/pycosat](https://github.com/ContinuumIO/pycosat)
- en: A discussion of the SAT solver, when applied to Sudoku, can be found here: [https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/](https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 SAT 求解器在解数独中的应用讨论可在此找到：[https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/](https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/)。
- en: An example of Z3 for the Knights and Knaves problem can be found here: [https://jamiecollinson.com/blog/solving-knights-and-knaves-with-z3/](https://jamiecollinson.com/blog/solving-knights-and-knaves-with-z3/).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[这里可以找到解决骑士和卫士问题的Z3示例：](https://jamiecollinson.com/blog/solving-knights-and-knaves-with-z3/) [https://jamiecollinson.com/blog/solving-knights-and-knaves-with-z3/](https://jamiecollinson.com/blog/solving-knights-and-knaves-with-z3/)'
- en: Finding the shortest bus route
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找最短公交路线
- en: Finding the shortest bus route implies finding a path that connects points (bus
    stops) on a map. This is an instance of the traveling salesman problem. In this
    recipe, we'll approach the problem of finding the shortest bus route with different
    algorithms, including simulated annealing and ant colony optimization.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找最短公交路线意味着寻找一条连接地图上点（公交车站）的路径。这是旅行推销员问题的一个实例。在本篇文章中，我们将通过不同的算法来解决寻找最短公交路线的问题，包括模拟退火和蚁群优化。
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Apart from standard dependencies such as `scipy` and `numpy`, which we always
    rely on, we'll be using the `scikit-opt` library, which implements many different
    algorithms for swarm intelligence.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像`scipy`和`numpy`这样的标准依赖项外，我们还将使用`scikit-opt`库，该库实现了许多不同的群体智能算法。
- en: Swarm intelligence is the collective behavior of decentralized, self-organized
    systems that leads to the emergence of apparent intelligence in the eyes of an
    observer. This concept is used in work based on artificial intelligence. Natural
    systems, such as ant colonies, bird flocking, hawks hunting, animal herding, and
    bacterial growth, display a certain level of intelligence at the global level,
    even though ants, birds, and hawks typically exhibit relatively simple behavior.
    Swarm algorithms, which are inspired by biology, include the genetic algorithm,
    particle swarm optimization, simulated annealing, and ant colony optimization.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 群体智能是分散式、自组织系统的集体行为，这种行为在观察者眼中表现出明显的智能性。这个概念在基于人工智能的工作中被使用。自然系统，如蚂蚁群、鸟群、鹰的捕猎、动物群集和细菌生长，在全局层面展示出一定水平的智能，尽管蚂蚁、鸟类和鹰通常表现出相对简单的行为。受生物学启发的群体算法包括遗传算法、粒子群优化、模拟退火和蚁群优化。
- en: 'We can install `scikit-opt` with `pip` as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pip`安装`scikit-opt`，如下所示：
- en: '[PRE27]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we are ready to tackle the traveling salesman problem.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备解决旅行推销员问题。
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: As we mentioned previously, we'll approach our shortest bus route problem in
    two different ways.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们将以两种不同的方式解决最短公交路线问题。
- en: 'First, we need to create a list of coordinates (longitude, latitude) for bus
    stops. The difficulty of the problem depends on the number of stops (`N`). Here,
    we''ve set `N` to `15`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为公交车站创建一组坐标（经度，纬度）。问题的难度取决于站点的数量（`N`）。在这里，我们将`N`设置为`15`：
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also precalculate a distance matrix between stops, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以预先计算站点之间的距离矩阵，如下所示：
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can feed this distance matrix into the two algorithms to save time.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个距离矩阵输入到两个算法中以节省时间。
- en: We'll start with simulated annealing.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从模拟退火开始。
- en: Simulated annealing
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟退火
- en: 'In this subsection, we''ll write our algorithm for finding the shortest bus
    route. This is based on Luke Mile''s Python implementation of simulated annealing,
    when applied to the traveling salesman problem: [https://gist.github.com/qpwo/a46274751cc5db2ab1d936980072a134](https://gist.github.com/qpwo/a46274751cc5db2ab1d936980072a134).
    Let''s get started:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子节中，我们将编写我们的算法来寻找最短公交路线。这基于Luke Mile的Python实现的模拟退火，应用于旅行推销员问题：[https://gist.github.com/qpwo/a46274751cc5db2ab1d936980072a134](https://gist.github.com/qpwo/a46274751cc5db2ab1d936980072a134)。让我们开始吧：
- en: 'The implementation itself is short and succinct:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现本身非常简短而简洁：
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we need to call the algorithm, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要调用算法，如下所示：
- en: '[PRE31]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is the final solution – the path looks as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终的解决方案 – 路径如下所示：
- en: '![](img/b06783a1-cd08-427f-8393-fa053648e368.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b06783a1-cd08-427f-8393-fa053648e368.png)'
- en: 'We can also plot the internal distance measure of the algorithm. Please note
    how this internal cost function goes down all the time until about 800,000 iterations:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以绘制算法的内部距离度量。请注意，这个内部成本函数在约800,000次迭代之前一直下降：
- en: '![](img/0ed8b401-9405-4b86-a9ca-6bfbc670008e.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ed8b401-9405-4b86-a9ca-6bfbc670008e.png)'
- en: Now, let's try out ant colony optimization.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试蚁群优化算法。
- en: Ant colony optimization
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蚁群优化
- en: 'Here, we''re loading the implementation from a library. We''ll explain the
    details of this in the *How it works...* section:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在从库中加载实现。我们将在*它的工作原理...*部分解释细节：
- en: '[PRE32]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are using the distance calculations based on the point distances (`distance_matrix`)
    we retrieved previously.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用基于我们之前获取的点距离的距离计算（`distance_matrix`）。
- en: 'Again, we can plot the best path and the path distance over iterations, as
    follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以绘制最佳路径和路径距离随迭代次数的变化情况，如下所示：
- en: '![](img/2836f8ea-47e2-447a-b4d6-8e60b7fef4b7.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2836f8ea-47e2-447a-b4d6-8e60b7fef4b7.png)'
- en: Once again, we can see the final path, which is the result of our optimization
    (the subplot on the left), as well as the distance as it goes down over iterations
    of the algorithm (the subplot on the right).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以看到最终路径，这是我们优化的结果（左侧子图），以及随着算法迭代距离逐渐减少的路径（右侧子图）。
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The shortest bus route problem is an example of the **traveling salesman problem** (**TSP**),
    which, in turn, is a well-known example of combinatorial optimization.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最短巴士路线问题是旅行商问题（**TSP**）的一个示例，而 TSP 又是组合优化的一个众所周知的示例。
- en: Combinatorial optimization refers to using combinatorial techniques to solve
    discrete optimization problems. In other words, it is the act of finding a solution
    among a combination of objects. Discrete, in this case, means that there are a
    finite number of options. The intelligence part of combinatorial optimization
    goes into either reducing the search space or accelerating the search. The traveling
    salesman problem, the minimum spanning tree problem, the marriage problem, and
    the knapsack problem are all applications of combinatorial optimization.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 组合优化是指使用组合技术来解决离散优化问题。换句话说，它是在一组对象中找到解决方案的行为。在这种情况下，“离散”意味着有限数量的选项。组合优化的智能部分在于减少搜索空间或加速搜索。旅行商问题、最小生成树问题、婚姻问题和背包问题都是组合优化的应用。
- en: 'The TSP can be stated as follows: given a list of towns to visit, which is
    the shortest path that traverses all of them and leads back to the point of origin?
    The TSP has applications in domains such as planning, logistics, and microchip design.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: TSP 可以表述如下：给定要访问的城镇列表，找出遍历所有城镇并回到起点的最短路径是什么？TSP 在规划、物流和微芯片设计等领域有应用。
- en: Now, let's take a look at simulated annealing and ant colony optimization in
    more detail.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看一下模拟退火和蚁群优化。
- en: Simulated annealing
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟退火
- en: Simulated annealing is a probabilistic optimization technique. The name comes
    from metallurgy, where heating and cooling is used to reduce the defects in materials.
    Briefly, at each iteration, a state transition (a change) can occur. If the change
    is successful, the system will lower its temperature. This can be repeated until
    the state is good enough or until we reach a certain number of iterations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟退火是一种概率优化技术。其名称来源于冶金学，其中加热和冷却用于减少材料中的缺陷。简单来说，在每次迭代中，可以发生状态转换（即变化）。如果变化成功，则系统会降低其温度。这可以重复进行，直到状态足够好或达到一定迭代次数为止。
- en: In this recipe, we randomly initialized our city tour and then iterated for
    simulated annealing. The main idea of SA is that the rate of changes depends on
    a certain temperature. In our implementation, we decreased the temperature logistically
    from 4 to 0. In each iteration, we tried swapping (we could have tried other operations)
    two random bus stops, indexes *i* and *j* in our path (tour), where *i < j*, and
    then we calculated the sum of distances to *i* from *i-1* to *i*, from *i* to
    *i+1*, from *j-1* to *j*, and from *j* to *j+1* (see `calc_distance`). We also
    needed a distance measure for `calc_distance`. We chose the Euclidean distance
    here, but we could have chosen others.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们随机初始化了我们的城市旅游路线，然后进行了模拟退火的迭代。SA 的主要思想是，变化的速率取决于一定的温度。在我们的实现中，我们从 4
    逻辑地降低了温度到 0。在每次迭代中，我们尝试交换（也可以尝试其他操作）路径（旅游路线）中两个随机巴士站点的索引 *i* 和 *j*，其中 *i < j*，然后计算从
    *i-1* 到 *i*、从 *i* 到 *i+1*、从 *j-1* 到 *j* 和从 *j* 到 *j+1* 的距离总和（见 `calc_distance`）。我们还需要一个距离度量来进行
    `calc_distance`。我们选择了欧几里得距离，在这里，但我们也可以选择其他距离度量。
- en: 'The temperature gets factored in when we need to decide whether to accept the
    swap. We calculate the exponential of the difference in path length before and
    after the swap:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 温度在我们需要决定是否接受交换时发挥作用。我们计算路径长度变化前后的指数差：
- en: '![](img/a27925b2-5ca8-464f-a966-f4cd0733f1e1.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a27925b2-5ca8-464f-a966-f4cd0733f1e1.png)'
- en: Then, we draw a random number. We accept the change if this random number is
    lower than our expression; otherwise, we undo it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们生成一个随机数。如果这个随机数小于我们的表达式，我们就接受这个变化；否则，我们撤销它。
- en: Ant colony optimization
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蚁群优化
- en: 'As the name suggests, **ant colony optimization** is inspired by ant colonies.
    Let''s use pheromones, which are secreted by ants as they follow a path, as an
    analogy: here, the agents have candidate solutions that are more attractive the
    closer they get to the solution.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，**蚁群优化** 受到蚂蚁群体的启发。让我们使用蚂蚁分泌的信息素作为类比：这里，代理人具有候选解决方案，越接近解决方案，越有吸引力。
- en: 'In general, ant number *k* moves from state *x* to state *y* with the following probability:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，蚂蚁编号 *k* 从状态 *x* 转移到状态 *y* 的概率如下：
- en: '![](img/cca21206-5116-4d0a-b6bb-b7d3d9bae156.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cca21206-5116-4d0a-b6bb-b7d3d9bae156.png)'
- en: '*Tau* is the pheromone trail that''s deposited between *x* and *y*. The *eta*
    parameter controls the influence of the pheromone, where *eta* to the power of
    *beta* is the state transition (for example, one over the cost of the transition).
    Pheromone trails are updated according to how good the overall solution that included
    the state transition was.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tau* 是在 *x* 和 *y* 之间沉积的信息素路径。*eta* 参数控制信息素的影响，其中 *eta* 的 *beta* 次幂是状态转换（例如转换成本的倒数）。信息素路径根据包括状态转换在内的整体解决方案的好坏而更新。'
- en: The `scikit-opt` function does the heavy lifting here. We only have to pass
    a few parameters, such as the distance function, the number of points, the number
    of ants in the population, the number of iterations, and the distance matrix,
    before calling `run()`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`scikit-opt` 函数起到了重要作用。我们只需传递几个参数，如距离函数、点数、种群中的蚂蚁数量、迭代次数和距离矩阵，然后调用 `run()`。
- en: See also
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can also solve this problem as a mixed-integer problem. The Python-MIP library
    solves mixed-integer problems, and you can find an example for the TSP at [https://python-mip.readthedocs.io/en/latest/examples.html](https://python-mip.readthedocs.io/en/latest/examples.html).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以将此问题作为混合整数问题来解决。Python-MIP 库解决混合整数问题，您可以在 [https://python-mip.readthedocs.io/en/latest/examples.html](https://python-mip.readthedocs.io/en/latest/examples.html)
    找到 TSP 的示例。
- en: 'The TSP can be solved with a Hopfield Network as well, as explained in this
    tutorial: [https://www.tutorialspoint.com/artificial_neural_network/artificial_neural_network_optimization_using_hopfield.htm](https://www.tutorialspoint.com/artificial_neural_network/artificial_neural_network_optimization_using_hopfield.htm).
    A cuckoo search approach is discussed here: [https://github.com/Ashwin-Surana/cuckoo-search](https://github.com/Ashwin-Surana/cuckoo-search).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: TSP 也可以用 Hopfield 网络解决，如本教程所述：[https://www.tutorialspoint.com/artificial_neural_network/artificial_neural_network_optimization_using_hopfield.htm](https://www.tutorialspoint.com/artificial_neural_network/artificial_neural_network_optimization_using_hopfield.htm)。在这里讨论了一种布谷鸟搜索方法：[https://github.com/Ashwin-Surana/cuckoo-search](https://github.com/Ashwin-Surana/cuckoo-search)。
- en: '`scikit-opt` is a powerful library for heuristic algorithms. It includes the
    following algorithms:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-opt` 是一个强大的启发式算法库。它包括以下算法：'
- en: Differential evolution
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 差分进化
- en: Genetic algorithm
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗传算法
- en: Particle swarm optimization
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子群优化
- en: Simulated annealing
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟退火
- en: Ant colony algorithm
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚁群算法
- en: Immune algorithm
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免疫算法
- en: Artificial fish swarm algorithm
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工鱼群算法
- en: 'The `scikit-opt` documentation contains more examples of solving the TSP: [https://scikit-opt.github.io/scikit-opt/#/en/README?id=_22-genetic-algorithm-for-tsptravelling-salesman-problem](https://scikit-opt.github.io/scikit-opt/#/en/README?id=_22-genetic-algorithm-for-tsptravelling-salesman-problem). Another
    library similar to `scikit-opt` is `pyswarms`, available at [https://pyswarms.readthedocs.io/en/latest/index.html](https://pyswarms.readthedocs.io/en/latest/index.html).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-opt` 文档包含更多解决 TSP（旅行推销员问题）的例子：[https://scikit-opt.github.io/scikit-opt/#/en/README?id=_22-genetic-algorithm-for-tsptravelling-salesman-problem](https://scikit-opt.github.io/scikit-opt/#/en/README?id=_22-genetic-algorithm-for-tsptravelling-salesman-problem)。另一个类似于
    `scikit-opt` 的库是 `pyswarms`，可以在 [https://pyswarms.readthedocs.io/en/latest/index.html](https://pyswarms.readthedocs.io/en/latest/index.html)
    找到。'
- en: As we mentioned in the introduction to this recipe, transport logistics has
    its own application in the TSP, even in its purest form. A dataset of 30,000 public
    buses, minibuses, and vans in Mexico is available at [https://thelivinglib.org/mapaton-cdmx/](https://thelivinglib.org/mapaton-cdmx/).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本文开头提到的，运输物流在 TSP 中有其独特的应用，甚至在其纯粹形式中。墨西哥拥有30,000辆公共汽车、小巴和面包车的数据集可以在 [https://thelivinglib.org/mapaton-cdmx/](https://thelivinglib.org/mapaton-cdmx/)
    找到。
- en: Simulating the spread of a disease
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟疾病传播
- en: Pandemics such as smallpox, tuberculosis, and the Black Death have affected
    the human population significantly throughout history. As of 2020, Covid-19 is
    spreading through populations all over the world, and the politics and economics
    of getting the virus under control with little casualties have been widely discussed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如天花、结核病和黑死病等大流行病，长期以来显著影响了人类群体。截至2020年，新冠肺炎正在全球范围内传播，关于如何在尽可能少的伤亡情况下控制病毒的政治和经济问题已广泛讨论。
- en: Regarding Covid-19, to libertarians, Sweden was, for some time, the poster child
    for how you didn't need a lockdown, although secondary factors such as having
    a high proportion of single-person households and a cultural tendency to social
    distance weren't taken into account. Recently, fatalities in Sweden have been
    on the rise, and its per capita rate is one of the highest recorded ([https://www.worldometers.info/coronavirus/](https://www.worldometers.info/coronavirus/)).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 关于新冠肺炎，对于自由主义者来说，瑞典曾一度成为无需封锁的典范，尽管未考虑到诸如高比例的单人户和社会距离的文化倾向等次要因素。最近，瑞典的死亡人数有所上升，其人均发病率是已记录的最高之一（[https://www.worldometers.info/coronavirus/](https://www.worldometers.info/coronavirus/)）。
- en: In the UK, the initial response was to rely on herd immunity, and the lockdown
    was declared only weeks after other countries had already imposed it. The **National
    Health Service** (**NHS**) were using makeshift beds and renting beds in commercial
    hospitals because they didn't have the capacity to cope.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在英国，最初的反应是依赖群体免疫，只有在其他国家已经实施封锁数周后才宣布封锁。由于无法应对，国民健康服务系统（**NHS**）使用临时床位并租用商业医院的床位。
- en: 'A **multi-agent system** (**MAS**) is a computer simulation consisting of participants
    known as agents. The individual agents can respond heuristically or based on reinforcement
    learning. Conjunctively, the system behavior of these agents responding to each
    other and to the environment can be applied to study topics, including the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**多代理系统**（**MAS**）是由参与者（称为代理）组成的计算机模拟。这些个体代理可以根据启发式或基于强化学习作出响应。此外，这些代理相互响应以及对环境的响应的系统行为可以应用于研究以下主题：'
- en: Cooperation and coordination
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合作与协调
- en: Distributed constraint optimization
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式约束优化
- en: Communication and negotiation
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交流与协商
- en: Distributed problem solving, especially distributed constraint optimization
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式问题解决，尤其是分布式约束优化
- en: In this recipe, a relatively simple, multi-agent simulation will show you how
    different responses can cause a difference in the number of fatalities, and the
    spread, of a pandemic.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，一个相对简单的多代理模拟将展示不同的响应如何导致疫情的致命人数和传播方式上的差异。
- en: Getting ready
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We'll be using the `mesa` multi-agent modeling library to implement our multi-agent
    simulation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`mesa`多代理建模库来实现我们的多代理模拟。
- en: 'The `pip` command for this is as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此操作的`pip`命令如下：
- en: '[PRE33]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, we are ready to go!
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了！
- en: How to do it...
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: This simulation is based on work by Maple Rain Research Co., Ltd. For this recipe,
    we've made a few changes regarding introducing factors such as hospital beds and
    lockdown policies, and we've also changed how infections and active cases are
    accounted for. You can find the complete code at [https://github.com/benman1/covid19-sim-mesa](https://github.com/benman1/covid19-sim-mesa).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟基于Maple Rain Research Co., Ltd.的工作。对于这个食谱，我们已经做了一些更改，引入了因素如医院床位和封锁政策，并且我们也改变了感染和活跃病例的计算方式。你可以在[https://github.com/benman1/covid19-sim-mesa](https://github.com/benman1/covid19-sim-mesa)找到完整的代码。
- en: 'Disclaimer: This recipe''s intent is not to provide medical advice, nor are
    we qualified medical practitioners or specialists.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 声明：本食谱的目的不是提供医疗建议，我们也不是合格的医疗从业者或专家。
- en: 'First, we are going to define our agents through the `Person` class:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过`Person`类来定义我们的代理：
- en: '[PRE34]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This defines an agent as a person with a health and quarantine status.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 此定义将代理定义为拥有健康和隔离状态的人。
- en: 'We still need a few methods to change how other properties can change. We won''t
    go through all of them, just the ones that should suffice for you to gain an understanding
    of how everything comes together. The core thing we need to understand is what
    agents do while they''re infected. Basically, while infected, we need to understand
    whether the agents infect others, die from the infection, or recover:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要一些方法来改变其他属性的变化方式。我们不会详细介绍所有这些方法，只是介绍那些足以让你理解所有内容如何结合在一起的方法。我们需要理解的核心是代理在感染时做什么。基本上，在感染期间，我们需要了解代理是否会传染给其他人，是否会因感染而死亡，或者是否会康复：
- en: '[PRE35]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we can see quite a few variables that are defined at the model level,
    such as `self.model.critical_rate`, `self.model.hospital_factor`, and `self.model.recovery_period`. We'll
    look at these model variables in more detail later.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到几个在模型层面上定义的变量，例如`self.model.critical_rate`，`self.model.hospital_factor`和`self.model.recovery_period`。我们稍后会更详细地查看这些模型变量。
- en: 'Now, we need a way for our agents to record their position, which is what in
    `mesa` is called a `MultiGrid`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一种方法让我们的代理记录它们的位置，这在`mesa`中被称为`MultiGrid`：
- en: '[PRE36]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is relatively straightforward. If agents move, they move within their neighborhood;
    that is, the next adjacent cell.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相对直接的。如果代理移动，它们只在它们的邻域内移动；也就是说，下一个相邻的单元。
- en: 'The entry method, which is called at every cycle (iteration), is the `step()`
    method:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为`step()`方法的入口方法在每个周期（迭代）都会被调用：
- en: '[PRE37]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Agents move at every step if they are alive. Here''s what happens when they
    move:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代理活着，它们在每一步都会移动。这是它们移动时会发生的事情：
- en: '[PRE38]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This concludes the main logic of our agents; that is, `Person`. Now, let's look
    at how everything comes together at the model level. This can be found in the
    `Simulation` class inside `model.py`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们的代理，也就是`Person`的主要逻辑。现在，让我们看看在模型层面上如何将所有内容整合在一起。这可以在`model.py`中的`Simulation`类中找到。
- en: 'Let''s see how the agents are created:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代理是如何创建的：
- en: '[PRE39]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code creates as many agents as we need. Some of them will be infected
    according to the `start_infected` parameter. We also add the agents to a map of
    cells organized in a grid.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了我们需要的代理数量。其中一些会根据`start_infected`参数被感染。我们还将这些代理添加到一个以网格形式组织的单元地图中。
- en: 'We also need to define a few data collectors, as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义一些数据收集器，如下所示：
- en: '[PRE40]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The variables in this dictionary of lists are appended in every cycle so that
    we can plot them or evaluate them statistically. As an example, let''s see how
    the `active_cases` function is defined:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此字典列表中的变量在每个周期中都会追加，以便我们可以绘图或进行统计评估。例如，让我们看看`active_cases`函数是如何定义的：
- en: '[PRE41]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When called, the function iterates over the agents in the model and counts the
    ones whose status is `infected`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，该函数会迭代模型中的代理，并计算状态为`infected`的代理数量。
- en: 'Again, just like for `Person`, the main logic of `Simulation` is in the `step()`
    method, which advances the model by one cycle:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，就像对`Person`一样，`Simulation`的主要逻辑在`step()`方法中，该方法推进模型一个周期：
- en: '[PRE42]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let's see how different lockdown policies affect deaths and the spread of the
    disease over time.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同的封锁政策如何影响死亡和疾病的传播。
- en: 'We''ll use the same set of variables that we used previously in these simulations.
    We''ve set them so that they roughly correspond to the UK according to a factor
    of 1/1,000:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这些模拟中使用与之前相同的一组变量。我们设置它们以便它们大致对应于英国，按照1/1,000的因子：
- en: '[PRE43]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We'll explain the motivation for the grid in the *How it works...* section.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*它是如何工作的……*部分解释网格的动机。
- en: Lockdown is declared by the `lockdown_policy` method, which is passed to the
    constructor of `Simulation`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 封锁由`lockdown_policy`方法声明，该方法被传递给`Simulation`的构造函数。
- en: 'First, let''s look at the data when no lockdown was introduced. We can create
    this policy if our `policy` function always returns `False`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在没有引入封锁的情况下的数据。如果我们的`policy`函数始终返回`False`，我们可以创建这个策略：
- en: '[PRE44]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The resulting graph shows our five collected variables over time:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图显示了我们随时间收集的五个变量：
- en: '![](img/dadc7951-0559-418e-8da7-a54ec51e1248.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dadc7951-0559-418e-8da7-a54ec51e1248.png)'
- en: Overall, we have 8,774 deaths.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，我们有8,774例死亡。
- en: 'Here, we can see several waves of infections as lockdown is lifted early according
    to this policy:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到随着这一政策早期解除封锁，多次感染的波动：
- en: '[PRE45]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we run this simulation, we get a completely different result, as shown
    here:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个模拟时，我们得到完全不同的结果，如下所示：
- en: '![](img/bb631cd4-91dc-4621-bfaa-b39786d40cec.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb631cd4-91dc-4621-bfaa-b39786d40cec.png)'
- en: The rectangular shape around 250 iterations shows when lockdown was declared
    (ignore the scale or shape). Overall, we can see that this resulted in 20,663
    deaths. This extremely high death rate –much higher than the `critical_rate` parameter –
    has been set to 5% due to reinfection before immunity.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在250个迭代周围的矩形形状显示了封锁的宣布时间（忽略比例或形状）。总体而言，我们可以看到这导致了20663人的死亡。这种极高的死亡率——远高于`critical_rate`参数的设定——由于免疫前再感染，已经设定为5%。
- en: 'Let''s compare this to a very cautious policy of declaring lockdown every time
    the death rate rises or if the rate of infected in the population rises above
    20% within (roughly) 3 weeks:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这与一个非常谨慎的政策进行比较，即每次死亡率上升或者感染率在（大致）3周内超过20%时宣布封锁：
- en: '[PRE46]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With a single lockdown, we get the following graph, which shows about 600 deaths
    overall:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 仅有一次封锁，我们得到了以下的图表，显示了大约600人的总死亡人数：
- en: '![](img/e0201d7c-7781-4da1-8408-76ad16e461d5.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0201d7c-7781-4da1-8408-76ad16e461d5.png)'
- en: You can change these parameters or play with the logic to create more sophisticated
    and/or realistic simulations.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更改这些参数或者调整逻辑，以创建更复杂和/或更真实的模拟。
- en: More details around the original work can be found online ([https://teck78.blogspot.com/2020/04/using-mesa-framework-to-simulate-spread.html](https://teck78.blogspot.com/2020/04/using-mesa-framework-to-simulate-spread.html)).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于原始工作的细节可以在线上找到（[https://teck78.blogspot.com/2020/04/using-mesa-framework-to-simulate-spread.html](https://teck78.blogspot.com/2020/04/using-mesa-framework-to-simulate-spread.html)）。
- en: How it works...
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The simulation is quite simple: it''s composed of agents and proceeds in iterations
    (called cycles). Each agent represents a part of the population.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟非常简单：它由代理组成，并且在迭代（称为周期）中进行。每个代理代表人群的一部分。
- en: Here, a certain population is infected with the disease. At each cycle (which
    corresponds to 1 hour), infected people can go to the hospital (if there's capacity),
    die, or make progress toward recovery. They can also go into quarantine. While
    alive, not recovered, and not in quarantine, they can infect other people in spatial
    proximity to them. When recovering, agents can become immune.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，某个群体被这种疾病感染。在每个周期（对应1小时）内，被感染者可以去医院（如果有空位）、死亡、或者朝着康复迈进。他们还可以进入隔离状态。在尚未康复、未隔离且尚未死亡的情况下，他们可以在与他们空间接近的人群中传播疾病。恢复时，代理可以获得免疫力。
- en: At each cycle, agents can move around. They move to a new position if they're
    not in quarantine or the national lockdown has been declared; otherwise, they
    stay in place. If a person is infected, they can die, go to the hospital, recover,
    infect others, or go into quarantine.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个周期内，代理可以移动。如果他们不在隔离中或者国家实施了封锁，他们将会移动到一个新的位置；否则，他们将保持原地。如果一个人被感染，他们可以死亡、去医院、康复、传染给其他人，或者进入隔离状态。
- en: 'A national lockdown can be declared according to different policies, depending
    on death and infection rates. This is the main focus of our simulation: how does
    the introduction of a national lockdown affect fatalities?'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 根据死亡和感染率，可以宣布国家封锁，这是我们模拟的主要焦点：国家封锁的引入如何影响死亡人数？
- en: We need to consider different variables for this. One is population density.
    We can introduce population density by putting our agents on a map or a grid,
    where the grid size is defined by `grid_x` and `grid_y`. The `infect_rate` parameter
    must be tweaked according to grid size and population density.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑不同的变量。其中一个是人口密度。我们可以通过将我们的代理放在地图或网格上来引入人口密度，网格大小由`grid_x`和`grid_y`定义。`infect_rate` 参数必须根据网格大小和人口密度进行调整。
- en: 'We have a lot more parameters to take into account here, such as the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要考虑更多的参数，比如以下的参数：
- en: '`initial_infected` is the rate at which the population is initially infected.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_infected` 是初始感染率。'
- en: '`recovery_period` declares the number of cycles (roughly in hours) it takes
    to recover after being infected, with `0` for never.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recovery_period` 声明了被感染后恢复所需的周期数（大致以小时计），`0` 表示永不恢复。'
- en: '`critical_rate` is the rate over the whole recovery period in which an ill
    person can get critically ill, which means they''d go to the hospital, if possible,
    or die.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`critical_rate` 是在整个恢复期内患病者可能重症的比例，这意味着他们可能会去医院（如果可能的话）或者死亡。'
- en: '`hospital_capacity_rate` is the number of hospital beds per person over the
    whole population. We found this through online searches ([https://www.hsj.co.uk/acute-care/nhs-hospitals-have-four-times-more-empty-beds-than-normal/7027392.article](https://www.hsj.co.uk/acute-care/nhs-hospitals-have-four-times-more-empty-beds-than-normal/7027392.article), [https://www.kingsfund.org.uk/publications/nhs-hospital-bed-numbers](https://www.kingsfund.org.uk/publications/nhs-hospital-bed-numbers)).'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hospital_capacity_rate` 是全人口每人的医院床位数。我们通过在线搜索找到了这些信息（[https://www.hsj.co.uk/acute-care/nhs-hospitals-have-four-times-more-empty-beds-than-normal/7027392.article](https://www.hsj.co.uk/acute-care/nhs-hospitals-have-four-times-more-empty-beds-than-normal/7027392.article)，[https://www.kingsfund.org.uk/publications/nhs-hospital-bed-numbers](https://www.kingsfund.org.uk/publications/nhs-hospital-bed-numbers)）。'
- en: There's also `active_ratio`, which defines how active a person is; `quarantine_rate`,
    which determines how likely someone will go into self-quarantine (if not the hospital); and `immunity_chance`,
    which is relevant after recovery.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有 `active_ratio` 定义一个人的活跃程度；`quarantine_rate` 决定一个人不去医院而进行自我隔离的可能性；以及 `immunity_chance` ，在康复后相关。
- en: The simulation is going to run for a set amount of `cycles`, and our lockdown
    policy is declared in the `lockdown_policy` function.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟将运行一定数量的 `cycles`，我们的封锁政策在 `lockdown_policy` 函数中声明。
- en: In the `step()` method of `Simulation`, we performed data collection. Then,
    we checked whether the hospitals can take on any more patients according to the `free_beds` variable.
    Then, we ran the agents with `self.schedule.step()`. If we were in lockdown, we
    counted down. Lockdown is set from `False` to the `lockdown_period` variable (by
    taking liberty with Python's duck typing) once lockdown is declared.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Simulation` 的 `step()` 方法中，我们进行了数据收集。然后，根据 `free_beds` 变量检查医院是否可以接收更多患者。接着，我们运行了代理器 `self.schedule.step()`。如果我们处于封锁状态，我们开始倒计时。封锁状态由
    `False` 变量到 `lockdown_period` 变量设置（在 Python 的鸭子类型中有所改动）。
- en: The `lockdown_policy()` function determines how long the national lockdown should
    be, given how many agents are infected and deaths over time (lists). Here, 0 means
    we don't declare lockdown.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`lockdown_policy()` 函数确定国家封锁的持续时间，根据感染和死亡的人数随时间变化（列表）。在这里，0 意味着我们不宣布封锁。'
- en: There's more...
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Since the simulations can take a long time to run, it can be very slow to try
    out parameters. Instead of having to do a full run, and only then see if we get
    the desired effect or not, we can use the live plotting functionality of `matplotlib.`
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模拟可能需要很长时间才能运行，尝试参数可能非常缓慢。而不是必须进行完整运行，然后才能看到是否产生预期效果，我们可以使用 `matplotlib` 的实时绘图功能。
- en: 'In order to get faster feedback, let''s live plot the simulation loop, as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更快的反馈，让我们实时绘制模拟循环，如下所示：
- en: '[PRE47]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will continuously (every 10 cycles) update our plot of the simulation parameters.
    Instead of having to wait for a full simulation, we can abort it if it doesn't
    work out.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这将持续（每 10 个周期）更新我们的模拟参数绘图。如果没有达到预期效果，我们可以中止它，而不必等待完整模拟。
- en: See also
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'You can find out more about mesa''s multi-agent-based modeling in Python at
    [https://mesa.readthedocs.io/en/master/](https://mesa.readthedocs.io/en/master/)).
    Some other multi-agent libraries are as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://mesa.readthedocs.io/en/master/](https://mesa.readthedocs.io/en/master/)
    找到有关 mesa 的基于 Python 的多智能体建模的更多信息。以下是一些其他的多智能体库：
- en: MAgent specializes in 2D environments with a very large number of agents that
    learn through reinforcement learning: [https://github.com/PettingZoo-Team/MAgent](https://github.com/PettingZoo-Team/MAgent).
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MAgent 专注于具有非常多代理的 2D 环境，通过强化学习进行学习：[https://github.com/PettingZoo-Team/MAgent](https://github.com/PettingZoo-Team/MAgent)。
- en: osBrain and PADE are general-purpose multi-agent system libraries. They can
    be found at [https://osbrain.readthedocs.io/en/stable/](https://osbrain.readthedocs.io/en/stable/) and [https://pade.readthedocs.io/en/latest/](https://pade.readthedocs.io/en/latest/),
    respectively.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: osBrain 和 PADE 是通用的多智能体系统库。它们分别可以在 [https://osbrain.readthedocs.io/en/stable/](https://osbrain.readthedocs.io/en/stable/)
    和 [https://pade.readthedocs.io/en/latest/](https://pade.readthedocs.io/en/latest/)
    找到。
- en: SimPy is a discrete event simulator that can be used for a broader range of
    simulations: [https://simpy.readthedocs.io/en/latest/](https://simpy.readthedocs.io/en/latest/).
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SimPy 是一个离散事件模拟器，可用于更广泛的模拟：[https://simpy.readthedocs.io/en/latest/](https://simpy.readthedocs.io/en/latest/)。
- en: Other simulators have also been released, most prominently the CovidSim microsimulation
    model ([https://github.com/mrc-ide/covid-sim](https://github.com/mrc-ide/covid-sim)),
    which was developed by the MRC Centre for Global Infectious Disease Analysis,
    hosted at Imperial College, London.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模拟器也已发布，其中最突出的是CovidSim微模型（[https://github.com/mrc-ide/covid-sim](https://github.com/mrc-ide/covid-sim)），由伦敦帝国学院全球传染病分析中心MRC开发。
- en: Writing a chess engine with Monte Carlo tree search
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蒙特卡洛树搜索编写国际象棋引擎
- en: Chess is a two-player board game that's been popular as a game of wits since
    the 15th century. A computer beat the first human player in the 1950s (a complete
    novice) before one beat the human world champion in 1997\. They have since moved
    on to having superhuman intelligence. One of the main difficulties of writing
    a chess engine – a computer program that plays chess – is searching through the
    many variations and combinations and picking the best one.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 国际象棋是一种两人对弈的棋盘游戏，自15世纪以来作为智力游戏而广受欢迎。在20世纪50年代，计算机击败了第一个人类玩家（一个完全的新手），然后在1997年击败了人类世界冠军。此后，它们已经发展到拥有超人类的智能。编写国际象棋引擎的主要困难之一是搜索许多变化和组合并选择最佳策略。
- en: In this recipe, we'll use Monte Carlo tree search to create a basic chess engine.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用蒙特卡洛树搜索来创建一个基本的国际象棋引擎。
- en: Getting ready
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'We''ll use the `python-chess` library for visualization, to get valid moves,
    and to know if a state is terminal. We can install it with the `pip` command,
    as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`python-chess`库进行可视化，获取有效移动，并知道状态是否终止。我们可以使用`pip`命令安装它，如下所示：
- en: '[PRE48]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We'll be using this library for visualization, to generate valid moves at each
    position, and to check if we've reached a final position.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个库进行可视化，生成每个位置的有效移动，并检查是否达到了最终位置。
- en: How to do it...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: This recipe is based on a minimal implementation of Monte Carlo tree search
    by Luke Miles at [https://gist.github.com/qpwo/c538c6f73727e254fdc7fab81024f6e1](https://gist.github.com/qpwo/c538c6f73727e254fdc7fab81024f6e1).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例基于Luke Miles在[https://gist.github.com/qpwo/c538c6f73727e254fdc7fab81024f6e1](https://gist.github.com/qpwo/c538c6f73727e254fdc7fab81024f6e1)上对蒙特卡洛树搜索的最小实现。
- en: First, we'll look at the code we'll be using to define our tree search class,
    and then look at how the search works. After that, we'll learn how this can be
    adapted to chess.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看我们将用来定义我们的树搜索类的代码，然后看看搜索是如何工作的。之后，我们将学习如何将其适应于国际象棋。
- en: Tree search
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树搜索
- en: A tree search is a search that employs a search tree as a data structure. In
    general, in a search tree, nodes (or leaves) represent a concept or a situation,
    and these are then connected over edges (branches). The tree search traverses
    the tree to come up with the best solution.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 树搜索是一种利用搜索树作为数据结构的搜索方法。通常情况下，在搜索树中，节点（或叶子）表示一个概念或情况，这些节点通过边（分支）连接。树搜索遍历树以得出最佳解决方案。
- en: 'Let''s start by implementing the tree search class:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先实现树搜索类：
- en: '[PRE49]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We'll look at these variables in more detail in the *How it works...* section.
    We'll be adding more methods to this class shortly.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*它的工作原理...*部分更详细地讨论这些变量。我们很快将向这个类添加更多方法。
- en: 'The different steps in our tree search are performed in our `do_rollout` method:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的树搜索中的不同步骤在我们的`do_rollout`方法中执行：
- en: '[PRE50]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Each `rollout()` call adds one layer to our tree.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`rollout()`调用都会向我们的树中添加一层。
- en: 'Let''s get through the four main steps in turn:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次完成四个主要步骤：
- en: 'The `select` step finds a leaf node from which no simulation has been initiated
    yet:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`select`步骤找到一个叶节点，从该节点尚未启动模拟：'
- en: '[PRE51]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is defined recursively, so if we don't find an unexplored node, we explore
    a child of the current node.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这是递归定义的，因此如果我们找不到未探索的节点，我们就会探索当前节点的一个子节点。
- en: 'The expansion step adds the children nodes – the nodes that can be reached
    via valid moves, given a board position:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展步骤添加子节点——即通过有效移动到达的节点，给定一个棋盘位置：
- en: '[PRE52]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This function updates the `children` dictionary with the descendants (or children)
    of the node. These nodes are any valid board positions that can be reached from
    the node in a single move.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用后代（或子节点）更新`children`字典。这些节点是从当前节点通过单个移动可以到达的任何有效棋盘位置。
- en: 'The simulation step runs a series of moves until the game is ended:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟步骤运行一系列移动，直到游戏结束：
- en: '[PRE53]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This function plays out the simulation until the end of the game.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数执行模拟直到游戏结束。
- en: 'The backpropagation step associates a reward with each step of the path:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反向传播步骤将奖励与路径上的每一步关联起来：
- en: '[PRE54]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we need a way to choose the best move, which can be as simple as going
    through the `Q` and `N` dictionaries and choosing the descendent with the maximum
    utility (reward):'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一种选择最佳移动的方法，可以简单地通过查看`Q`和`N`字典并选择具有最大效用（奖励）的后代来实现：
- en: '[PRE55]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We set the score of any unseen node to `-infinity`, in order to avoid choosing
    an unseen move.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看不见的节点的分数设置为`-infinity`，以避免选择未见过的移动。
- en: Implementing a node
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现一个节点
- en: Now, let's learn how to use a node for our chess implementation.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何为我们的国际象棋实现使用一个节点。
- en: 'Since this is based on the `python-chess` library, it is relatively easy to
    implement:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这基于`python-chess`库，所以实现起来相对容易：
- en: '[PRE56]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We've omitted a few methods here, but don't worry – we will be covering them
    in the *How it works...* section.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里省略了一些方法，但不要担心 - 我们将在*工作原理...*部分进行覆盖。
- en: Now that everything has been prepared, we can finally play chess.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，我们终于可以下棋了。
- en: Playing chess
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下国际象棋
- en: Let's play some chess!
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们下一盘国际象棋！
- en: 'The following is just a simple loop with a graphical prompt stating the board
    position:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 以下只是一个简单的循环，带有一个图形提示显示棋盘位置：
- en: '[PRE57]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You should then be asked to enter a move to go to a certain position on the
    chessboard. After each move, a board will appear, showing the current position
    of the chess pieces. This can be seen in the following screenshot:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您应该被要求输入一个移动到棋盘上某个位置的移动。每次移动后，将显示一个棋盘，显示当前棋子的位置。这可以在以下截图中看到：
- en: '![](img/b028c2ce-c138-4008-bf02-ab37d0372fa8.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b028c2ce-c138-4008-bf02-ab37d0372fa8.png)'
- en: Note that moves have to be entered in UCI notation. If you enter the move in
    a format that's square to square – for example, a2a4 – it should always work.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 注意移动必须以UCI符号输入。如果以“square to square”格式输入移动，例如a2a4，它应该总是有效。
- en: The playing strength being used here isn't very high, but it should still be
    easy to see a few improvements that you can make while play around with it. Note
    that this implementation is not parallelized.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的游戏强度并不是非常高，但是在玩弄它时应该仍然很容易看到一些改进。请注意，此实现没有并行化。
- en: How it works...
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In **Monte Carlo tree search** (**MCTS**), we apply the Monte Carlo method –
    which is basically random sampling – in order to obtain an idea of the strength
    of the moves that are made by the player. For each move, we play random moves
    until the game finishes. If we do this often enough, we'll get a good estimate.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在**蒙特卡洛树搜索**（**MCTS**）中，我们应用蒙特卡洛方法 - 基本上是随机抽样 - 以获取关于玩家所做移动强度的概念。对于每个移动，我们随机进行移动直到游戏结束。如果我们做得足够频繁，我们将得到一个很好的估计。
- en: 'The tree search maintains different variables:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 树搜索维护不同的变量：
- en: '`Q` is the total reward of each node.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q`是每个节点的总奖励。'
- en: '`N` is the total visit count for each node.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`N`是每个节点的总访问次数。'
- en: '`children` holds the children of each node – the nodes that can be reached
    from a board position.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`children`保存每个节点的子节点 - 可以从一个棋盘位置到达的节点。'
- en: A node is a board state in our case.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点在我们的情况下是一个棋盘状态。
- en: These dictionaries are important because we average the utility of a node (a
    board state) over rewards, and we sample nodes based on how often (or rather,
    how little) they have been visited.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字典很重要，因为我们通过奖励对节点（棋盘状态）的效用进行平均，并根据它们被访问的频率（或者更确切地说，它们被访问的次数越少）对节点进行抽样。
- en: 'Each iteration of the search consists of four steps:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索的每次迭代包括四个步骤：
- en: Selection
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择
- en: Expansion
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展
- en: Simulation
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟
- en: Backpropagation
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回传播
- en: The selection step, at its most basic, looks for a node (such as a board position)
    that hasn't been explored yet.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 选择步骤，在其最基本的形式下，寻找一个尚未探索过的节点（例如一个棋盘位置）。
- en: The expansion step updates the `children` dictionary with the children of the
    selected node.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展步骤将`children`字典更新为所选节点的子节点。
- en: 'The simulation step is straightforward: we play out a chain of random moves
    until a terminal position is reached and return the reward. Since this is a two-player,
    zero-sum board game, we have to invert the reward when it''s the opponent''s turn.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟步骤很简单：我们执行一系列随机移动，直到到达终止位置，并返回奖励。由于这是一个两人零和棋盘游戏，当轮到对手时，我们必须反转奖励。
- en: The backpropagation step follows the path in a backward direction to associate
    the reward with all the nodes in the explored path. The `_backpropagate()` method backtracks all
    the nodes along a series of moves (a path), attributes them with a reward, and
    updates the number of visits.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 反向传播步骤按照反向方向的路径将奖励与探索路径中的所有节点关联起来。`_backpropagate()` 方法沿着一系列移动（路径）回溯所有节点，赋予它们奖励，并更新访问次数。
- en: 'As for implementing a node, nodes must be hashable and comparable since we''ll
    store them in the dictionaries we mentioned previously. So, here, we need to implement
    the `__hash__` and `__eq__` methods. We omitted them previously since we didn''t
    need them to understand the algorithm itself, so we''ve added them here for completeness:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 至于节点的实现，由于我们将它们存储在之前提到的字典中，所以节点必须是可散列且可比较的。因此，在这里，我们需要实现`__hash__`和`__eq__`方法。我们以前没有提到它们，因为我们不需要它们来理解算法本身，所以我们在这里补充了它们以保持完整性：
- en: '[PRE58]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `__repr__()` method can be quite useful when you are debugging.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在调试时，`__repr__()`方法可能非常有用。
- en: 'For the main functionality of the `ChessGame` class, we also need the following
    methods:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ChessGame`类的主要功能，我们还需要以下方法：
- en: '`find_children()`: Finds all possible successors from the current node'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_children()`: 从当前节点查找所有可能的后继节点'
- en: '`find_random_child()`: Finds a random successor from the current node'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_random_child()`: 从当前节点找到一个随机的后继节点'
- en: '`is_terminal()`: Determines whether a node is terminal'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_terminal()`: 确定节点是否为终端节点'
- en: '`reward()`: Provides a reward for the current node'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reward()`: 为当前节点提供奖励'
- en: Please take a look at the implementation of `ChessGame` again to see this in
    action.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 请再次查看`ChessGame`的实现，以了解它的运作方式。
- en: There's more...
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这还不算完...
- en: One major extension of MCTS is **Upper Confidence Trees** (**UCTs**), which
    are used to balance exploration and exploitation. The first Go programs to reach
    dan level on a 9x9 board used MCTS with UCT.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: MCTS的一个重要扩展是**上置信树**（**UCTs**），用于平衡探索和利用。在9x9棋盘上达到段位的第一个围棋程序使用了带有UCT的MCTS。
- en: 'To implement the `UCT` extension, we have to go back to our `MCTS` class and
    make a couple of changes:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`UCT`扩展，我们需要回到我们的`MCTS`类，并进行一些更改：
- en: '[PRE59]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `uct()` function applies the **Upper-Confidence-Bound** (**UCB**) formula,
    which provides a move with a score. The score of node *n* is the sum of the number
    of simulations won among all simulations, starting with node *n*, plus a confidence
    term:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`uct()` 函数应用**上置信界限**（**UCB**）公式，为一个移动提供一个得分。节点*n*的得分是从节点*n*开始的所有模拟中赢得的模拟数量的总和，加上一个置信项：'
- en: '![](img/3cd15c9a-842a-4e93-9c8b-6866bed8a6e0.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cd15c9a-842a-4e93-9c8b-6866bed8a6e0.png)'
- en: Here, *c* is a constant.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*c* 是一个常数。
- en: 'Next, we need to replace the last line of code so that it uses `_uct_select()` instead
    of ` _select()` for recursion. Here, we''ll replace the last line of `_select()` so
    that it states the following:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要替换代码的最后一行，以便使用`_uct_select()`代替`_select()`进行递归。在这里，我们将替换`_select()`的最后一行，使其陈述如下：
- en: '[PRE60]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Making this change should increase the agent's playing strength further.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此更改应该会进一步增强代理程序的游戏强度。
- en: See also
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To find out more about UCTs, take a look at the following article on MoGO regarding
    the first computer Go program to reach dan level on a 9x9 board: [https://hal.inria.fr/file/index/docid/369786/filename/TCIAIG-2008-0010_Accepted_.pdf](https://hal.inria.fr/file/index/docid/369786/filename/TCIAIG-2008-0010_Accepted_.pdf).
    It also provides a description of MCTS in pseudocode.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于UCT的信息，请查看MoGO关于在9x9棋盘上达到段位的第一个计算机围棋程序的文章：[https://hal.inria.fr/file/index/docid/369786/filename/TCIAIG-2008-0010_Accepted_.pdf](https://hal.inria.fr/file/index/docid/369786/filename/TCIAIG-2008-0010_Accepted_.pdf)。它还提供了MCTS的伪代码描述。
- en: The easyAI library contains a lot of different search algorithms: [https://zulko.github.io/easyAI/index.html](https://zulko.github.io/easyAI/index.html).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: easyAI库包含许多不同的搜索算法：[https://zulko.github.io/easyAI/index.html](https://zulko.github.io/easyAI/index.html)。
