- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Teaching Networks to Generate Digits
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the building blocks of neural network models.
    In this chapter, our first project will recreate one of the most groundbreaking
    models in the history of deep learning, **Deep Belief Network** (**DBN**). DBN
    was one of the first multi-layer networks for which a feasible learning algorithm
    was developed. Besides being of historical interest, this model is connected to
    the topic of this book because the learning algorithm makes use of a generative
    model in order to pre-train the neural network weights into a reasonable configuration
    prior to backpropagation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: How to load the **Modified National Institute of Standards and Technology**
    (**MNIST**) dataset and transform it using TensorFlow 2's Dataset API.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How a **Restricted Boltzmann Machine** (**RBM**) – a simple neural network –
    is trained by minimizing an "energy" equation that resembles formulas from physics
    to generate images.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to stack several RBMs to make a DBN and apply forward and backward passes
    to pre-train this network to generate image data.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement an end-to-end classifier by combining this pre-training with
    backpropagation "fine-tuning" using the TensorFlow 2 API.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MNIST database
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In developing the DBN model, we will use a dataset that we have discussed before
    – the MNIST database, which contains digital images of hand-drawn digits from
    0 to 9¹. This database is a combination of two sets of earlier images from the
    **National Institute of Standards and Technology** (**NIST**): Special Database
    1 (digits written by US high school students) and Special Database 3 (written
    by US Census Bureau employees),² the sum of which is split into 60,000 training
    images and 10,000 test images.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The original images in the dataset were all black and white, while the modified
    dataset normalized them to fit into a 20x20-pixel bounding box and removed jagged
    edges using anti-aliasing, leading to intermediary grayscale values in cleaned
    images; they are padded for a final resolution of 28x28 pixels.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: In the original NIST dataset, all the training images came from Bureau employees,
    while the test dataset came from high school students, and the modified version
    mixes the two groups in the training and test sets to provide a less biased population
    for training machine learning algorithms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16176_04_01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Digits from the NIST dataset (left)³ and MNIST (right)⁴'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: An early application of **Support Vector Machines** (**SMVs**) to this dataset
    yielded an error rate of 0.8%,⁵ while the latest deep learning models have shown
    error rates as low as 0.23%.⁶ You should note that these figures were obtained
    due to not only the discrimination algorithms used but also "data augmentation"
    tricks such as creating additional translated images where the digit has been
    shifted by several pixels, thus increasing the number of data examples for the
    algorithm to learn from. Because of its wide availability, this dataset has become
    a benchmark for many machine learning models, including Deep Neural Networks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The dataset was also the benchmark for a breakthrough in training multi-layer
    neural networks in 2006, in which an error rate of 1.25% was achieved (without
    image translation, as in the preceding examples).⁷ In this chapter, we will examine
    in detail how this breakthrough was achieved using a generative model, and explore
    how to build our own DBN that can generate MNIST digits.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving and loading the MNIST dataset in TensorFlow
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in training our own DBN is to construct our dataset. This section
    will show you how to transform the MNIST data into a convenient format that allows
    you to train a neural network, using some of TensorFlow 2's built-in functions
    for simplicity.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by loading the MNIST dataset in TensorFlow. As the MNIST data
    has been used for many deep learning benchmarks, TensorFlow 2 already has convenient
    utilities for loading and formatting this data. To do so, we need to first install
    the `tensorflow-datasets` library:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After installing the package, we need to import it along with the required
    dependencies:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can download the MNIST data locally from **Google Cloud Storage** (**GCS**)
    using the builder functionality:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The dataset will now be available on disk on our machine. As noted earlier,
    this data is divided into a training and test dataset, which you can verify by
    taking a look at the `info` command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This gives the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the test dataset has 10,000 examples, the training dataset has
    60,000 examples, and the images are 28x28 pixels with a label from one of 10 classes
    (0 to 9).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at the training dataset:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can visually plot some examples using the `show_examples` function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This gives the following figure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16176_04_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: MNIST digit examples from the TensorFlow dataset'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: You can also see more clearly here the grayscale edges on the numbers where
    the anti-aliasing was applied to the original dataset to make the edges seem less
    jagged (the colors have also been flipped from the original example in *Figure
    4.1*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also plot an individual image by taking one element from the dataset,
    reshaping it to a 28x28 array, casting it as a 32-bit float, and plotting it in
    grayscale:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This gives the following figure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16176_04_03.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: A MNIST digit in TensorFlow'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'This is nice for visual inspection, but for our experiments in this chapter,
    we will actually need to flatten these images into a vector. To do so, we can
    use the `map()` function, and verify that the dataset is now flattened; note that
    we also need to cast to a float for use in the RBM later. The RBM also assumes
    binary (0 or 1) inputs, so we need to rescale the pixels, which range from 0 to
    256 to the range 0 to 1:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于视觉检查很好，但是在本章的实验中，我们实际上需要将这些图像展平成向量。为了做到这一点，我们可以使用`map（）`函数，并验证数据集现在已经被展平；请注意，我们还需要将其转换为浮点数以便稍后在RBM中使用。RBM还假设输入是二进制（0或1），所以我们需要重新缩放像素，范围从0到256到范围从0到1：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This gives a 784x1 vector, which is the "flattened" version of the pixels of
    the digit "4":'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这得到了一个784x1的向量，这是数字"4"的"展平"版本的像素：
- en: '![](img/B16176_04_04.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16176_04_04.png)'
- en: 'Figure 4.4: Flattening the MNIST digits in TensorFlow'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '图4.4: 在TensorFlow中将MNIST数字展平'
- en: Now that we have the MNIST data as a series of vectors, we are ready to start
    implementing an RBM to process this data and ultimately create a model capable
    of generating new images.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将MNIST数据处理成一系列向量，我们准备开始实现一个RBM来处理这些数据，最终创建一个能够生成新图像的模型。
- en: 'Restricted Boltzmann Machines: generating pixels with statistical mechanics'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受限玻尔兹曼机：用统计力学生成像素
- en: The neural network model that we will apply to the MNIST data has its origins
    in earlier research on how neurons in the mammalian brain might work together
    to transmit signals and encode patterns as memories. By using analogies to statistical
    mechanics in physics, this section will show you how simple networks can "learn"
    the distribution of image data and be used as building blocks for larger networks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用于MNIST数据的神经网络模型的起源可以追溯到对哺乳动物大脑中的神经元如何一起传递信号并编码模式作为记忆的早期研究。通过使用物理学中的统计力学类比，本节将向您展示简单的网络如何"学习"图像数据的分布，并且可以用作更大网络的构建模块。
- en: Hopfield networks and energy equations for neural networks
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 霍普菲尔德网络和神经网络的能量方程
- en: As we discussed in *Chapter 3*, *Building Blocks of Deep Neural Networks*, Hebbian
    Learning states, "Neurons that fire together, wire together",⁸ and many models,
    including the multi-layer perceptron, made use of this idea in order to develop
    learning rules. One of these models was the **Hopfield network**, developed in
    the 1970-80s by several researchers^(9 10). In this network, each "neuron" is
    connected to every other by a symmetric weight, but no self-connections (there
    are only connections between neurons, no self-loops).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第3章*讨论的*深度神经网络的基本组成部分*中所提到的，**赫布学习法**陈述："发射的神经元会产生联系"⁸，并且许多模型，包括多层感知器，都利用了这个想法来开发学习规则。其中一个模型就是**霍普菲尔德网络**，由几位研究人员在1970-80年代开发^(9
    10)。在这个网络中，每个"神经元"都通过对称权重与其他所有神经元相连，但没有自连接（只有神经元之间的连接，没有自环）。
- en: Unlike the multi-layer perceptrons and other architectures we studied in *Chapter
    3*, *Building Blocks of Deep Neural Networks,* the Hopfield network is an undirected
    graph, since the edges go "both ways."
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在*第3章*学习的多层感知器和其他架构不同，霍普菲尔德网络是一个无向图，因为边是"双向的"。
- en: '![](img/Chapter_04_05.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_04_05.png)'
- en: 'Figure 4.5: The Hopfield network'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '图4.5: 霍普菲尔德网络'
- en: 'The neurons in the Hopfield network take on binary values, either (-1, 1) or
    (0, 1), as a thresholded version of the tanh or sigmoidal activation function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 霍普菲尔德网络中的神经元采用二进制值，要么是(-1, 1)，要么是(0, 1)，作为双曲正切或Sigmoid激活函数的阈值版本：
- en: '![](img/B16176_04_001.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16176_04_001.png)'
- en: 'The threshold values (sigma) never change during training; to update the weights,
    a "Hebbian" approach is to use a set of *n* binary patterns (configurations of
    all the neurons) and update as:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值（sigma）在训练过程中不会发生变化；为了更新权重，可以使用"**赫布学习法**"来使用一组*n*个二进制模式（所有神经元的配置）进行更新：
- en: '![](img/B16176_04_002.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16176_04_002.png)'
- en: where *n* is the number of patterns, and *e* is the binary activations of neurons
    *i* and *j* in a particular configuration. Looking at this equation, you can see
    that if the neurons share a configuration, the connection between them is strengthened,
    while if they are opposite signs (one neuron has a sign of +1, the other -1),
    it is weakened. Following this rule to iteratively strengthen or weaken a connection
    leads the network to converge to a stable configuration that resembles a "memory"
    for a particular activation of the network, given some input. This represents
    a model for associative memory in biological organisms – the kind of memory that
    links unrelated ideas, just as the neurons in the Hopfield network are linked
    together^(11 12).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*n*是模式数，*e*是特定配置中神经元*i*和*j*的二进制激活。观察这个方程，你会发现如果神经元共享一个配置，它们之间的连接会被加强，而如果它们是相反的符号（一个神经元的符号为+1，另一个的符号为-1），它们之间的连接就会被削弱。按照这个规则迭代地加强或削弱连接，导致网络收敛到一个稳定的配置，类似于网络的特定激活的“记忆”，给定一些输入。这代表了生物有机体中的联想记忆模型——将不相关的思想链接在一起的记忆，就像Hopfield网络中的神经元被链接在一起一样。^(11
    12)
- en: 'Besides representing biological memory, Hopfield networks also have an interesting
    parallel to electromagnetism. If we consider each neuron as a particle or "charge,"
    we can describe the model in terms of a "free energy" equation that represents
    how the particles in this system mutually repulse/attract each other and where
    on the distribution of potential configurations the system lies relative to equilibrium:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表示生物记忆外，Hopfield网络还与电磁学有一个有趣的相似点。如果我们将每个神经元视为粒子或“电荷”，我们可以用一个“自由能”方程描述该模型，表示该系统中的粒子如何相互排斥/吸引，以及系统在潜在配置分布上相对于平衡点的位置：
- en: '![](img/B16176_04_003.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16176_04_003.png)'
- en: 'where w is the weights between neurons *i* and *j*, *s* is the "states" of
    those neurons (either 1, "on," or -1, "off"), and sigma is the threshold of each
    neuron (for example, the value that its total inputs must exceed to set it to
    "on"). When the Hopfield network is in its final configuration, it also minimizes
    the value of the energy function computed for the network, which is lowered by
    units with an identical state(s) being connected strongly (*w*). The probability
    associated with a particular configuration is given by the **Gibbs measure**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，w是神经元*i*和*j*之间的权重，*s*是这些神经元的“状态”（要么是1，“开”，要么是-1，“关”），sigma是每个神经元的阈值（例如，它的总输入必须超过的值，才能将其设置为“开”）。当Hopfield网络处于其最终配置中时，它还最小化了为网络计算的能量函数的值，其中具有相同状态的单元通过强连接（*w*）连接。与特定配置相关联的概率由**Gibbs测度**给出：
- en: '![](img/B16176_04_004.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16176_04_004.png)'
- en: 'Here, *Z(B)* is a normalizing constant that represents all possible configurations
    of the network, in the same respect as the normalizing constant in the Bayesian
    probability function you saw in *Chapter 1*, *An Introduction to Generative AI:
    "Drawing" Data from Models*.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*Z(B)*是一个归一化常数，表示与*“Chapter 1”，生成AI的介绍：“从模型中“绘制”数据* 中的贝叶斯概率函数中的归一化常数相同，表示网络的所有可能配置。
- en: Also notice in the energy function definition that the state of a neuron is
    only affected by local connections (rather than the state of every other neuron
    in the network, regardless of if it is connected); this is also known as the **Markov
    property**, since the state is "memoryless," depending only on its immediate "past"
    (neighbors). In fact, the *Hammersly-Clifford theorem* states that any distribution
    having this same memoryless property can be represented using the Gibbs measure.^(13)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意能量函数的定义中，神经元的状态只受到本地连接的影响（而不是受到所有网络中其他神经元的状态影响，无论它是否连接）；这也被称为**马尔科夫性质**，因为状态是“无记忆”的，仅取决于其立即“过去”（邻居）。实际上，*Hammersly-Clifford定理*表明，任何具有相同无记忆属性的分布都可以使用Gibbs测度来表示。^(13)
- en: Modeling data with uncertainty with Restricted Boltzmann Machines
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用受限玻尔兹曼机建模不确定性数据
- en: What other kinds of distributions might we be interested in? While useful from
    a theoretical perspective, one of the shortcomings of the Hopfield network is
    that it can't incorporate the kinds of uncertainty seen in actual physical or
    biological systems; rather than deterministically turning on or off, real-world
    problems often involve an element of chance – a magnet might flip polarity, or
    a neuron might fire at random.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能对其他种类的分布感兴趣吗？虽然Hopfield网络从理论角度来看很有用，但其缺点之一是无法纳入实际物理或生物系统中存在的不确定性；与确定性的打开或关闭不同，现实世界的问题通常涉及一定程度的偶然性
    - 磁铁可能会翻转极性，或者神经元可能会随机发射。
- en: This uncertainty, or *stochasticity*, is reflected in the *Boltzmann machine*,^(14)
    a variant of the Hopfield network in which half the neurons (the "visible" units)
    receive information from the environment, while half (the "hidden" units) only
    receive information from the visible units.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不确定性，或者*随机性*，反映在*Boltzmann机器*中^(14)——这是Hopfield网络的变体，其中一半的神经元（“可见”单元）从环境接收信息，而另一半（“隐藏”单元）只从可见单元接收信息。
- en: '![](img/Chapter_04_06.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_04_06.png)'
- en: 'Figure 4.6: The Boltzmann machine'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：Boltzmann机器
- en: The Boltzmann machine randomly turns on (1) or off (0) each neuron by sampling,
    and over many iterations converges to a stable state represented by the minima
    of the energy function. This is shown schematically in *Figure 4.6*, in which
    the white nodes of the network are "off," and the blue ones are "on;" if we were
    to simulate the activations in the network, these values would fluctuate over
    time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Boltzmann机器通过抽样随机打开（1）或关闭（0）每个神经元，并在许多迭代中收敛到能量函数的最小值所代表的稳定状态。这在*图4.6*中以示意图的形式显示，网络的白色节点为“关闭”，蓝色节点为“开启”；如果我们模拟网络中的激活，这些值将随时间波动。
- en: In theory, a model like this could be used, for example, to model the distribution
    of images, such as the MNIST data using the hidden nodes as a "barcode" that represents
    an underlying probability model for "activating" each pixel in the image. In practice,
    though, there are problems with this approach. Firstly, as the number of units
    in the Boltzmann network increases, the number of connections increases exponentially
    (for example, the number of potential configurations that has to be accounted
    for in the Gibbs measure's normalization constant explodes), as does the time
    needed to sample the network to an equilibrium state. Secondly, weights for units
    with intermediate activate probabilities (not strongly 0 or 1) will tend to fluctuate
    in a random walk pattern (for example, the probabilities will increase or decrease
    randomly but never stabilize to an equilibrium value) until the neurons converge,
    which also prolongs training.^(15)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，像这样的模型可以用来模拟图像的分布，例如使用隐藏节点作为表示图像中每个像素的基础概率模型的“条形码”。然而，在实践中，这种方法存在问题。首先，随着Boltzmann网络中单元的数量增加，连接的数量呈指数增长（例如，必须在Gibbs测度的归一化常数中考虑的潜在配置数量激增），同样需要采样网络到平衡状态所需的时间也随之增加。其次，具有中间激活概率的单元的权重往往会呈现随机行走模式（例如，概率会随机增加或减少，但永远不会稳定到平衡值），直到神经元收敛，这也延长了训练时间。^(15)
- en: 'A practical modification is to remove some of the connections in the Boltzmann
    machine, namely those between visible units and between hidden units, leaving
    only connections between the two types of neurons. This modification is known
    as the RBM, shown in *Figure 4.7*^(16):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实用的修改是删除Boltzmann机器中的一些连接，即可见单元之间的连接和隐藏单元之间的连接，仅保留两种类型神经元之间的连接。这种修改称为RBM，如*图4.7*所示^(16)：
- en: '![](img/Chapter_04_07.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_04_07.png)'
- en: 'Figure 4.7: RBM'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：RBM
- en: Imagine as described earlier that the visible units are input pixels from the
    MNIST dataset, and the hidden units are an encoded representation of that image.
    By sampling back and forth to convergence, we could create a generative model
    for images. We would just need a learning rule that would tell us how to update
    the weights to allow the energy function to converge to its minimum; this algorithm
    is **contrastive divergence** (**CD**). To understand why we need a special algorithm
    for RBMs, it helps to revisit the energy equation and how we might sample to get
    equilibrium for the network.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前描述的那样，可见单元是来自MNIST数据集的输入像素，而隐藏单元是该图像的编码表示。通过来回采样直到收敛，我们可以创建一个图像的生成模型。我们只需要一个学习规则，告诉我们如何更新权重以使能量函数收敛到其最小值；这个算法就是**对比散度**（**CD**）。为了理解为什么我们需要一个特殊的算法来处理RBM，有助于重新思考能量方程以及我们如何采样获得网络的平衡。
- en: 'Contrastive divergence: Approximating a gradient'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对比散度：梯度的近似
- en: 'If we refer back to *Chapter 1*, *An Introduction to Generative AI: "Drawing"
    Data from Models*, creating a generative model of images using an RBM essentially
    involves finding the probability distribution of images, using the energy equation^(17):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾*第1章* *生成式人工智能简介：从模型中“生成”数据*，使用RBM创建图像的生成模型本质上涉及找到图像的概率分布，使用能量方程^(17)：
- en: '![](img/B16176_04_005.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16176_04_005.png)'
- en: 'where *x* is an image, theta is the parameters of the model (the weights and
    biases), and *Z* is the partition function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*x*是一个图像，theta是模型的参数（权重和偏置），*Z*是分区函数：
- en: '![](img/B16176_04_006.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16176_04_006.png)'
- en: 'In order to find the parameters that optimize this distribution, we need to
    maximize the likelihood (product of each datapoint''s probability under a density
    function) based on data:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到优化这个分布的参数，我们需要基于数据最大化似然（每个数据点在密度函数下的概率乘积）：
- en: '![](img/B16176_04_007.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16176_04_007.png)'
- en: 'In practice, it''s a bit easier to use the negative log likelihood, as this
    is represented by a sum:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，使用负对数似然稍微容易一些，因为它表示为一个和：
- en: '![](img/B16176_04_008.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16176_04_008.png)'
- en: If the distribution *f* has a simple form, then we can just take the derivative
    of *E* with respect to parameters of *f*. For example, if *f* is a single normal
    distribution, then the values that maximize *E* with respect to mu (the mean)
    and sigma (the standard deviation) are, respectively, the sample mean and standard
    deviation; the partition function *Z* doesn't affect this calculation because
    the integral is 1, a constant, which becomes 0 once we take the logarithm.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分布*f*的形式简单，那么我们可以对*f*的参数进行导数。例如，如果*f*是一个单一的正态分布，那么最大化*E*关于mu（平均值）和sigma（标准差）的值分别是样本均值和标准差；分区函数*Z*不会影响这个计算，因为积分是1，一个常数，一旦我们取了对数，它就变成了0。
- en: If the distribution is instead a sum of *N* normal distributions, then the partial
    derivative of *mu(i)* (one of these distributions) with respect to *f* (the sum
    of all the *N* normal distributions) involves the mu and sigma of each other distribution
    as well. Because of this dependence, there is no closed-form solution (for example,
    a solution equation we can write out by rearranging terms or applying algebraic
    transformations) for the optimal value; instead, we need to use a gradient search
    method (such as the backpropagation algorithm we discussed in *Chapter 3*, *Building
    Blocks of Deep Neural Networks*) to iteratively find the optimal value of this
    function. Again, the integral of each of these *N* distributions is 1, meaning
    the partition function is the constant *log(N)*, making the derivative 0.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分布代替一个正态分布的总和，则*mu(i)*（这些分布中的一个）关于*f*（所有*N*个正态分布的总和）的偏导数同样涉及到每个其他分布的mu和sigma。由于这种依赖关系，对于最优值没有封闭形式解法（例如，我们可以通过重新排列项或应用代数转换写出的解方程）；相反，我们需要使用梯度搜索方法（例如我们在*第3章*
    *深度神经网络的构建基块*中讨论的反向传播算法）迭代地找到这个函数的最优值。同样，每个这些*N*个分布的积分都是1，意味着分区函数是常数*log(N)*，使得导数为0。
- en: What happens if the distribution *f* is a product, instead of a sum, of normal
    distributions? The partition function *Z* is now no longer a constant in this
    equation with respect to theta, the parameters; the value will depend on how and
    where these functions overlap when computing the integral – they could cancel
    each other out by being mutually exclusive (0) or overlapping (yielding a value
    greater than 1). In order to evaluate gradient descent steps, we would need to
    be able to compute this partition function using numerical methods. In the RBM
    example, this partition function for the configuration of 28x28 MNIST digits would
    have 784 logistic units, and a massive number (2^(784)) of possible configurations,
    making it unwieldy to evaluate every time we want to take a gradient.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there any other way we could optimize the value of this energy equation
    without taking a full gradient? Returning to the energy equation, let''s write
    out the gradient explicitly:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16176_04_009.png)![](img/B16176_04_010.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'The partition function *Z* can be further written as a function of the integral
    involving *X* and the parameters of *f*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16176_04_011.png)![](img/B16176_04_012.png)![](img/B16176_04_013.png)![](img/B16176_04_014.png)![](img/B16176_04_015.png)![](img/B16176_04_016.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: where *< >* represents an average over the observed data sampled from the distribution
    of *x*. In other words, we can approximate the integral by sampling from the data
    and computing the average, which allows us to avoid computing or approximating
    high-dimensional integrals.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: While we can't directly sample from *p(x)*, we can use a technique known as
    **Markov Chain Monte Carlo** (**MCMC**) sampling to generate data from the target
    distribution *p(x')*. As was described in our discussion on Hopfield networks,
    the "Markov" property means that this sampling only uses the last sample as input
    in determining the probability of the next datapoint in the simulation – this
    forms a "chain" in which each successive sampled datapoint becomes input to the
    next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The "Monte Carlo" in the name of this technique is a reference to a casino
    in the principality of Monaco, and denotes that, like the outcomes of gambling,
    these samples are generated through a random process. By generating these random
    samples, you can use *N* MCMC steps as an approximation of the average of a distribution
    that is otherwise difficult or impossible to integrate. When we put all of this
    together, we get the following gradient equation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16176_04_017.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: where *X* represents the data at each step in the MCMC chain, with *X*⁰ being
    the input data. While in theory you might think it would take a large number of
    steps for the chain to converge, in practice it has been observed that even *N=1*
    steps is enough to get a decent gradient approximation.^(18)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the end result is a *contrast* between the input data and the sampled
    data; thus, the method is named **contrastive divergence** as it involves the
    difference between two distributions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying this to our RBM example, we can follow this recipe to generate the
    required samples:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Take an input vector *v*
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute a "hidden" activation *h*
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the activation from (*2*) to generate a sampled visible state *v'*
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use (*3*) to generate a sampled hidden state *h'*
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the updates, which are simply the correlations of the visible and hidden
    units:![](img/B16176_04_018.png)![](img/B16176_04_019.png)![](img/B16176_04_020.png)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: where *b* and *c* are the bias terms of visible and hidden units, respectively,
    and *e* is the learning rate.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: This sampling is known as **Gibbs sampling**, a method in which we sample one
    unknown parameter of a distribution at a time while holding all others constant.
    Here we hold the visible or the hidden fixed and sample units in each step.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: With CD, we now have a way to perform gradient descent to learn the parameters
    of our RBM model; as it turns out, we can potentially compute an even better model
    by stacking RBMs in what is called a DBN.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Stacking Restricted Boltzmann Machines to generate images: the Deep Belief
    Network'
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen that an RBM with a single hidden layer can be used to learn a
    generative model of images; in fact, theoretical work has suggested that with
    a sufficiently large number of hidden units, an RBM can approximate *any* distribution
    with binary values.^(19) However, in practice, for very large input data, it may
    be more efficient to add additional layers, instead of a single large layer, allowing
    a more "compact" representation of the data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Researchers who developed DBNs also noted that adding additional layers can
    only lower the log likelihood of the lower bound of the approximation of the data
    reconstructed by the generative model.^(20) In this case, the hidden layer output
    *h* of the first layer becomes the input to a second RBM; we can keep adding other
    layers to make a deeper network. Furthermore, if we wanted to make this network
    capable of learning not only the distribution of the image (*x*) but also the
    label – which digit it represents from 0 to 9 (*y*) – we could add yet another
    layer to a stack of connected RBMs that is a probability distribution (softmax)
    over the 10 possible digit classes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'A problem with training a very deep graphical model such as stacked RBMs is
    the "explaining-away effect" that we discussed in *Chapter 3*, *Building Blocks
    of Deep Neural Networks*. Recall that the dependency between variables can complicate
    inference of the state of hidden variables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_04_08.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: The explaining-away effect in a Bayesian network^(21)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4.8*, the knowledge that the pavement is wet can be explained by
    a sprinkler being turned on, to the extent that the presence or absence of rain
    becomes irrelevant, meaning we can''t meaningfully infer the probability that
    it is raining. This is equivalent to saying that the posterior distribution (*Chapter
    1*, *An Introduction to Generative AI: "Drawing" Data from Models*) of the hidden
    units cannot be tractably computed, since they are correlated, which interferes
    with easily sampling the hidden states of the RBM.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to treat each of the units as independent in the likelihood
    function, which is known as *variational inference*; while this works in practice,
    it is not a satisfying solution given that we know that these units are in fact
    correlated.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: But where does this correlation come from? If we sample the state of the visible
    units in a single-layer RBM, we set the states of each hidden unit randomly since
    they are independent; thus the *prior distribution* over the hidden units is independent.
    Why is the posterior then correlated? Just as the knowledge (data) that the pavement
    is wet causes a correlation between the probabilities of a sprinkler and rainy
    weather, the correlation between pixel values causes the posterior distribution
    of the hidden units to be non-independent. This is because the pixels in the images
    aren't set randomly; based on which digit the image represents, groups of pixels
    are more or less likely to be bright or dark. In the 2006 paper *A Fast Learning
    Algorithm for Deep Belief Nets*,^(22) the authors hypothesized that this problem
    could be solved by computing a *complementary prior* that has exactly the opposite
    correlation to the likelihood, thus canceling out this dependence and making the
    posterior also independent.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute this *complementary prior*, we could use the posterior distribution
    over hidden units in a higher layer. The trick to generating such distributions
    is in a greedy, layer-wise procedure for "priming" the network of stacked RBMs
    in a multi-layer generative model, such that the weights can then be fine-tuned
    as a classification model. For example, let''s consider a three-layer model for
    the MNIST data (*Figure 4.9*):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16176_04_09.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: DBN architecture based on "A fast learning algorithm for deep belief
    nets" by Hinton et al.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The two 500-unit layers form representations of the MNIST digits, while the
    2000- and 10-unit layers are "associative memory" that correlates labels with
    the digit representation. The two first layers have directed connections (different
    weights) for upsampling and downsampling, while the top layers have undirected
    weights (the same weight for forward and backward passes).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: This model could be learned in stages. For the first 500-unit RBM, we would
    treat it as an undirected model by enforcing that the forward and backward weights
    are equal; we would then use CD to learn the parameters of this RBM. We would
    then fix these weights and learn a *second* (500-unit) RBM that uses the hidden
    units from the first layer as input "data," and repeat for the 2000-layer unit.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: After we have "primed" the network, we no longer need to enforce that the weights
    in the bottom layers are tied, and can fine-tune the weights using an algorithm
    known as "wake-sleep."^(23)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we take input data (the digits) and compute the activations of the
    other layers all the way up until the connections between the 2000- and 10-unit
    layers. We compute updates to the "generative weights" (those that compute the
    activations that yield image data from the network) pointing downward using the
    previously given gradient equations. This is the "wake" phase because if we consider
    the network as resembling a biological sensory system, then it receives input
    from the environment through this forward pass.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: For the 2000- and 10-unit layers, we use the sampling procedure for CD using
    the second 500-unit layer's output as "data" to update the undirected weights.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We then take the output of the 2000-layer unit and compute activations downward,
    updating the "recognition weights" (those that compute activations that lead to
    the classification of the image into one of the digit classes) pointing upward.
    This is called the "sleep" phase because it displays what is in the "memory" of
    the network, rather than taking data from outside.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: We then repeat *these steps* until convergence.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Note that in practice, instead of using undirected weights in the top layers
    of the network, we could replace the last layer with directed connections and
    a softmax classifier. This network would then technically no longer be a DBN,
    but rather a regular Deep Neural Network that we could optimize with backpropagation.
    This is an approach we will take in our own code, as we can then leverage TensorFlow's
    built-in gradient calculations, and it fits into the paradigm of the Model API.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the theoretical background to understand how a DBN
    is trained and how the pre-training approach resolves issues with the "explaining-away"
    effect, we will implement the whole model in code, showing how we can leverage
    TensorFlow 2's gradient tape functionality to implement CD as a custom learning
    algorithm.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Creating an RBM using the TensorFlow Keras layers API
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have an appreciation of some of the theoretical underpinnings of
    the RBM, let's look at how we can implement it using the TensorFlow 2.0 library.
    For this purpose, we will represent the RBM as a custom layer type using the Keras
    layers API.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Code in this chapter was adapted to TensorFlow 2 from the original Theano (another
    deep learning Python framework) code from deeplearning.net.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we extend `tf.keras.layer`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We input a number of hidden units, visible units, a learning rate for CD updates,
    and the number of steps to take with each CD pass. For the layers API, we are
    only required to implement two functions: `build()` and `call()`. `build()` is
    executed when we call `model.compile()`, and is used to initialize the weights
    of the network, including inferring the right size of the weights given the input
    dimensions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need a way to perform both forward and reverse samples from the model.
    For the forward pass, we need to compute sigmoidal activations from the input,
    and then stochastically turn the hidden units on or off based on the activation
    probability between 1 and 0 given by that sigmoidal activation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Likewise, we need a way to sample in reverse for the visible units:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also implement `call()` in the RBM class, which provides the forward pass
    we would use if we were to use the `fit()` method of the Model API for backpropagation
    (which we can do for fine-tuning later in our deep belief model):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To actually implement CD learning for each RBM, we need to create some additional
    functions. The first calculates the free energy, as you saw in the Gibbs measure
    earlier in this chapter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note here that we could have used the Bernoulli distribution from `tensorflow_probability`
    in order to perform this sampling, using the sigmoidal activations as the probabilities;
    however, this is slow and would cause performance issues when we need to repetitively
    sample during CD learning. Instead, we use a speedup in which we sample an array
    of uniform random numbers the same size as the sigmoidal array and then set the
    hidden unit as 1 if it is greater than the random number. Thus, if a sigmoidal
    activation is 0.9, it has a 90% probability of being greater than a randomly sampled
    uniform number, and is set to "on." This has the same behavior as sampling a Bernoulli
    variable with a probability of 0.9, but is computationally much more efficient.
    The reverse and visible samples are computed similarly. Finally, putting these
    together allows us to perform both forward and reverse Gibbs samples:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To perform the CD updates, we make use of TensorFlow 2''s eager execution and
    the `GradientTape` API you saw in *Chapter 3*, *Building Blocks of Deep Neural
    Networks*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We perform one or more sample steps, and compute the cost using the difference
    between the free energy of the data and the reconstructed data (which is cast
    as a constant using `tf.constant` so that we don''t treat it as a variable during
    autogradient calculation). We then compute the gradients of the three weight matrices
    and update their values, before returning our reconstruction cost as a way to
    monitor progress. The reconstruction cost is simply the cross-entropy loss between
    the input and reconstructed data:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'which represents the formula:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16176_04_021.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: where *y* is the target label, *y-hat* is the estimated label from the softmax
    function, and *N* is the number of elements in the dataset.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Note that we enforce the weights being equal by copying over the transposed
    value of the updated (recognition) weights into the generative weights. Keeping
    the two sets of weights separate will be useful later on when we perform updates
    only on the recognition (forward) or generative (backward) weights during the
    wake-sleep procedure.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together, we can initialize an RBM with 500 units like in Hinton''s
    paper24, call `build()` with the shape of the flattened MNIST digits, and run
    successive epochs of training:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After ~25 steps, the model should converge, and we can inspect the results.
    One parameter of interest is the weight matrix *w*; the shape is 784 (28x28) by
    500, so we could see each "column" as a 28x28 filter, similar to the kernels in
    the convolutional networks we studied in *Chapter 3*, *Building Blocks of Deep
    Neural Networks*. We can visualize a few of these to see what kinds of patterns
    they are recognizing in the images:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This provides a set of filters:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16176_04_10.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: DBN filters after training'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that these filters appear to represent different shapes that we
    would find in a digit image, such as curves or lines. We can also observe the
    reconstruction of the images by sampling from our data:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/B16176_04_11.png)![](img/B16176_04_12.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Original (right) and reconstructed (left) digits from DBN'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: We can see in *Figure 4.11* that the network has nicely captured the underlying
    data distribution, as our samples represent a recognizable binary form of the
    input images. Now that we have one layer working, let's continue by combining
    multiple RBMs in layers to create a more powerful model.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DBN with the Keras Model API
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now seen how to create a single-layer RBM to generate images; this
    is the building block required to create a full-fledged DBN. Usually, for a model
    in TensorFlow 2, we only need to extend `tf.keras.Model` and define an initialization
    (where the layers are defined) and a `call` function (for the forward pass). For
    our DBN model, we also need a few more custom functions to define its behavior.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in the initialization, we need to pass a list of dictionaries that contain
    the parameters for our RBM layers (`number_hidden_units`, `number_visible_units`,
    `learning_rate`, `cd_steps`):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note at the same time that we also initialize a set of sigmoidal dense layers
    with a softmax at the end, which we can use for fine-tuning through backpropagation
    once we''ve trained the model using the generative procedures outlined earlier.
    To train the DBN, we begin a new code block to start the generative learning process
    for the stack of RBMs:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice that for computational efficiency, we generate the input for each layer
    past the first by passing every datapoint through the prior layer in a forward
    pass using the `map()` function for the Dataset API, instead of having to generate
    these forward samples repeatedly. While this takes more memory, it greatly reduces
    the computation required. Each layer in the pre-training loop calls back to the
    CD loop you saw before, which is now a member function of the DBN class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once we have pre-trained in a greedy manner, we can proceed to the wake-sleep
    step. We start with the upward pass:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Again, note that we gather a list of the transformed forward passes at each
    stage so that we have the necessary inputs for the update formula. We''ve now
    added a function, `wake_update`, to the RBM class, which will compute updates
    only for the generative (downward) weights, in every layer except the last (the
    associate, undirected connections):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is almost identical to the CD update, except that we are only updating
    the generative weights and the visible unit bias terms. Once we compute the forward
    pass, we then perform a contrastive update on the associate memory in the top
    layer:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then need to compute the data for the `reverse` pass of the wake-sleep algorithm;
    we do this by again applying a mapping to the last layer input:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For the sleep pass, we need to traverse the RBM in reverse, updating only the
    non-associative (undirected) connections. We first need to map the required input
    for each layer in reverse:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then we perform a backward traversal of the layers, only updating the non-associative
    connections:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we are satisfied with the training progress, we can tune the model further
    using normal backpropagation. The last step in the wake-sleep procedure is to
    set all the dense layers with the results of the trained weights from the RBM
    layers:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have included a forward pass for a neural network in the DBN class using
    the call `function()`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This can be used in the `fit()` call in the TensorFlow API:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This begins to train the now pre-trained weights using backpropagation, to fine-tune
    the discriminative power of the model. One way to conceptually understand this
    fine-tuning is that the pre-training procedure guides the weights to a reasonable
    configuration that captures the "shape" of the data, which backpropagation can
    then tune for a particular classification task. Otherwise, starting from a completely
    random weight configuration, the parameters are too far from capturing the variation
    in the data to be efficiently navigated to an optimal configuration through backpropagation
    alone.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how to combine multiple RBMs in layers to create a DBN, and how
    to run a generative learning process on the end-to-end model using the TensorFlow
    2 API; in particular, we made use of the gradient tape to allow us to record and
    replay the gradients using a non-standard optimization algorithm (for example,
    not one of the default optimizers in the TensorFlow API), allowing us to plug
    a custom gradient update into the TensorFlow framework.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about one of the most important models from the
    beginnings of the deep learning revolution, the DBN. You saw that DBNs are constructed
    by stacking together RBMs, and how these undirected models can be trained using
    CD.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The chapter then described a greedy, layer-wise procedure for priming a DBN
    by sequentially training each of a stack of RBMs, which can then be fine-tuned
    using the wake-sleep algorithm or backpropagation. We then explored practical
    examples of using the TensorFlow 2 API to create an RBM layer and a DBN model,
    illustrating the use of the `GradientTape` class to compute updates using CD.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how, following the wake-sleep algorithm, we can compile the
    DBN as a normal Deep Neural Network and perform backpropagation for supervised
    training. We applied these models to MNIST data and saw how an RBM can generate
    digits after training converges, and has features resembling the convolutional
    filters described in *Chapter 3*, *Building Blocks of Deep Neural Networks*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: While the examples in the chapter involved significantly extending the basic
    layer and model classes of the TensorFlow Keras API, they should give you an idea
    of how to implement your own low-level alternative training procedures. Going
    forward, we will mostly stick to using the standard `fit()` and `predict()` methods,
    starting with our next topic, Variational Autoencoders, a sophisticated and computationally
    efficient way to generate image data.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LeCun, Yann; Léon Bottou; Yoshua Bengio; Patrick Haffner (1998). *Gradient-
    Based Learning Applied to Document Recognition*. Proceedings of the IEEE. 86 (11):
    2278–2324'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LeCun, Yann; Corinna Cortes; Christopher J.C. Burges. *MNIST handwritten digit
    database, Yann LeCun, Corinna Cortes, and Chris Burges*
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'NIST''s original datasets: [https://www.nist.gov/system/files/documents/srd/nistsd19.pdf](https://www.nist.gov/system/files/documents/srd/nistsd19.pdf)'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://upload.wikimedia.org/wikipedia/commons/thumb/2/27/MnistExamples.png/440px-MnistExamples.png](https://upload.wikimedia.org/wikipedia/commons/thumb/2/27/MnistExamples.png/440px-MnistExamples.png)'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'LeCun, Yann; Léon Bottou; Yoshua Bengio; Patrick Haffner (1998). *Gradient-Based
    Learning Applied to Document Recognition*. Proceedings of the IEEE. 86 (11): 2278–2324'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D. Ciregan, U. Meier and J. Schmidhuber, (2012) *Multi-column deep neural networks
    for image classification*, 2012 IEEE Conference on Computer Vision and Pattern
    Recognition, pp. 3642-3649\. [https://ieeexplore.ieee.org/document/6248110](https://ieeexplore.ieee.org/document/6248110)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hinton GE, Osindero S, Teh YW. (2006) *A fast learning algorithm for deep belief
    nets*. Neural Comput. 18(7):1527-54\. [https://www.cs.toronto.edu/~hinton/absps/fastnc.pdf](https://www.cs.toronto.edu/~hinton/absps/fastnc.pdf)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hebb, D. O. (1949). *The Organization of Behavior: A Neuropsychological Theory*.
    New York: Wiley and Sons'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gurney, Kevin (2002). *An Introduction to Neural Networks*. Routledge
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sathasivam, Saratha (2008). *Logic Learning in Hopfield Networks*.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hebb, D. O.. *The organization of behavior: A neuropsychological theory*. Lawrence
    Erlbaum, 2002.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suzuki, Wendy A. (2005). *Associative Learning and the Hippocampus*. Psychological
    Science Agenda. American Psychological Association. [https://www.apa.org/science/about/psa/2005/02/suzuki](https://www.apa.org/science/about/psa/2005/02/suzuki)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hammersley, J. M.; Clifford, P. (1971), Markov fields on finite graphs and
    lattices; Clifford, P. (1990), *Markov random fields in statistics*, in Grimmett,
    G. R.; Welsh, D. J. A. (eds.), *Disorder in Physical Systems: A Volume in Honour
    of John M. Hammersley*, Oxford University Press, pp. 19–32'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ackley, David H; Hinton, Geoffrey E; Sejnowski, Terrence J (1985), *A learning
    algorithm for Boltzmann machines* (PDF), Cognitive Science, 9 (1): 147–169'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Boltzmann machine*. Wikipedia. Retrieved April, 26, 2021 from [https://en.wikipedia.org/wiki/Boltzmann_machine](https://en.wikipedia.org/wiki/Boltzmann_machine)'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Smolensky, Paul (1986). *Chapter 6: Information Processing in Dynamical Systems:
    Foundations of Harmony Theory* (PDF). In Rumelhart, David E.; McLelland, James
    L. (eds.). *Parallel Distributed Processing: Explorations in the Microstructure
    of Cognition*, Volume 1: Foundations. MIT Press. pp. 194–281'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Woodford O. *Notes on Contrastive Divergence*. [http://www.robots.ox.ac.uk/~ojw/files/NotesOnCD.pdf](http://www.robots.ox.ac.uk/~ojw/files/NotesOnCD.pdf)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hinton, G E. (2000). *Training Products of Experts by Minimizing Contrastive
    Divergence*. [http://www.cs.utoronto.ca/~hinton/absps/nccd.pdf](http://www.cs.utoronto.ca/~hinton/absps/nccd.pdf)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Roux, N L., Bengio, Y. (2008). *Representational Power of Restricted Boltzmann
    Machines and Deep Belief Networks*. in Neural Computation, vol. 20, no. 6, pp.
    1631-1649\. [https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/representational_power.pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/representational_power.pdf)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hinton, G E. (2000). *Training Products of Experts by Minimizing Contrastive
    Divergence*. [http://www.cs.utoronto.ca/~hinton/absps/nccd.pdf](http://www.cs.utoronto.ca/~hinton/absps/nccd.pdf)
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pearl J., Russell S. (2000). *BAYESIAN NETWORKS*. [https://ftp.cs.ucla.edu/pub/stat_ser/r277.pdf](https://ftp.cs.ucla.edu/pub/stat_ser/r277.pdf)
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hinton GE, Osindero S, Teh YW. (2006) *A fast learning algorithm for deep belief
    nets*. Neural Comput. 18(7):1527-54\. [https://www.cs.toronto.edu/~hinton/absps/fastnc.pdf](https://www.cs.toronto.edu/~hinton/absps/fastnc.pdf)
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hinton GE, Osindero S, Teh YW. (2006) *A fast learning algorithm for deep belief
    nets*. Neural Comput. 18(7):1527-54\. [https://www.cs.toronto.edu/~hinton/absps/fastnc.pdf](https://www.cs.toronto.edu/~hinton/absps/fastnc.pdf)
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hinton GE, Osindero S, Teh YW. (2006) *A fast learning algorithm for deep belief
    nets*. Neural Comput. 18(7):1527-54\. [https://www.cs.toronto.edu/~hinton/absps/fastnc.pdf](https://www.cs.toronto.edu/~hinton/absps/fastnc.pdf)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
