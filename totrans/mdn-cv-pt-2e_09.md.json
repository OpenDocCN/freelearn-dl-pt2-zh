["```py\n    %pip install selectivesearch\n    %pip install torch_snippets\n    from torch_snippets import *\n    import selectivesearch\n    from skimage.segmentation import felzenszwalb \n    ```", "```py\n    !wget https://www.dropbox.com/s/l98leemr7/Hemanvi.jpeg\n    img = read('Hemanvi.jpeg', 1) \n    ```", "```py\n    segments_fz = felzenszwalb(img, scale=200) \n    ```", "```py\n    subplots([img, segments_fz],\n             titles=['Original Image',\n                     'Image post\\nfelzenszwalb segmentation'], sz=10, nc=2) \n    ```", "```py\n    %pip install selectivesearch\n    %pip install torch_snippets\n    from torch_snippets import *\n    import selectivesearch\n    !wget https://www.dropbox.com/s/l98leemr7/Hemanvi.jpeg\n    img = read('Hemanvi.jpeg', 1) \n    ```", "```py\n    def extract_candidates(img): \n    ```", "```py\n     img_lbl, regions = selectivesearch.selective_search(img, \n                                       scale=200,  min_size=100) \n    ```", "```py\n     img_area = np.prod(img.shape[:2])\n        candidates = [] \n    ```", "```py\n     for r in regions:\n            if r['rect'] in candidates: continue\n            if r['size'] < (0.05*img_area): continue\n            if r['size'] > (1*img_area): continue\n            x, y, w, h = r['rect']\n            candidates.append(list(r['rect']))\n        return candidates \n    ```", "```py\n    candidates = extract_candidates(img)\n    show(img, bbs=candidates) \n    ```", "```py\n    def get_iou(boxA, boxB, epsilon=1e-5): \n    ```", "```py\n     x1 = max(boxA[0], boxB[0])\n        y1 = max(boxA[1], boxB[1])\n        x2 = min(boxA[2], boxB[2])\n        y2 = min(boxA[3], boxB[3]) \n    ```", "```py\n     width = (x2 - x1)\n        height = (y2 - y1) \n    ```", "```py\n     if (width<0) or (height <0):\n            return 0.0\n        area_overlap = width * height \n    ```", "```py\n     area_a = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])\n        area_b = (boxB[2] - boxB[0]) * (boxB[3] - boxB[1])\n        area_combined = area_a + area_b - area_overlap \n    ```", "```py\n     iou = area_overlap / (area_combined+epsilon)\n        return iou \n    ```", "```py\n%pip install -q --upgrade selectivesearch torch_snippets\nfrom torch_snippets import *\nimport selectivesearch\nfrom google.colab import files\nfiles.upload() # upload kaggle.json file\n!mkdir -p ~/.kaggle\n!mv kaggle.json ~/.kaggle/\n!ls ~/.kaggle\n!chmod 600 /root/.kaggle/kaggle.json\n!kaggle datasets download -d sixhky/open-images-bus-trucks/\n!unzip -qq open-images-bus-trucks.zip\nfrom torchvision import transforms, models, datasets\nfrom torch_snippets import Report\nfrom torchvision.ops import nms\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu' \n```", "```py\n    IMAGE_ROOT = 'images/images'\n    DF_RAW = pd.read_csv('df.csv')\n    print(DF_RAW.head()) \n    ```", "```py\n    class OpenImages(Dataset):\n        def __init__(self, df, image_folder=IMAGE_ROOT):\n            self.root = image_folder\n            self.df = df\n            self.unique_images = df['ImageID'].unique()\n        def __len__(self): return len(self.unique_images) \n    ```", "```py\n     def __getitem__(self, ix):\n            image_id = self.unique_images[ix]\n            image_path = f'{self.root}/{image_id}.jpg'\n            # Convert BGR to RGB\n            image = cv2.imread(image_path, 1)[...,::-1]\n            h, w, _ = image.shape\n            df = self.df.copy()\n            df = df[df['ImageID'] == image_id]\n            boxes = df['XMin,YMin,XMax,YMax'.split(',')].values\n            boxes = (boxes*np.array([w,h,w,h])).astype(np.uint16).tolist()\n            classes = df['LabelName'].values.tolist()\n            return image, boxes, classes, image_path \n    ```", "```py\n    ds = OpenImages(df=DF_RAW)\n    im, bbs, clss, _ = ds[9]\n    show(im, bbs=bbs, texts=clss, sz=10) \n    ```", "```py\n    def extract_candidates(img):\n        img_lbl,regions = selectivesearch.selective_search(img,\n                                       scale=200, min_size=100)\n        img_area = np.prod(img.shape[:2])\n        candidates = []\n        for r in regions:\n            if r['rect'] in candidates: continue\n            if r['size'] < (0.05*img_area): continue\n            if r['size'] > (1*img_area): continue\n            x, y, w, h = r['rect']\n            candidates.append(list(r['rect']))\n        return candidates\n    def extract_iou(boxA, boxB, epsilon=1e-5):\n        x1 = max(boxA[0], boxB[0])\n        y1 = max(boxA[1], boxB[1])\n        x2 = min(boxA[2], boxB[2])\n        y2 = min(boxA[3], boxB[3])\n        width = (x2 - x1)\n        height = (y2 - y1)\n        if (width<0) or (height <0):\n            return 0.0\n        area_overlap = width * height\n        area_a = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])\n        area_b = (boxB[2] - boxB[0]) * (boxB[3] - boxB[1])\n        area_combined = area_a + area_b - area_overlap\n        iou = area_overlap / (area_combined+epsilon)\n        return iou \n    ```", "```py\n    FPATHS, GTBBS, CLSS, DELTAS, ROIS, IOUS = [],[],[],[],[],[] \n    ```", "```py\n    N = 500\n    for ix, (im, bbs, labels, fpath) in enumerate(ds):\n        if(ix==N):\n            break \n    ```", "```py\n     H, W, _ = im.shape\n        candidates = extract_candidates(im)\n        candidates = np.array([(x,y,x+w,y+h) for x,y,w,h in candidates]) \n    ```", "```py\n     ious, rois, clss, deltas = [], [], [], [] \n    ```", "```py\n     ious = np.array([[extract_iou(candidate, _bb_) for \\\n                    candidate in candidates] for _bb_ in bbs]).T \n    ```", "```py\n     for jx, candidate in enumerate(candidates):\n            cx,cy,cX,cY = candidate \n    ```", "```py\n     candidate_ious = ious[jx] \n    ```", "```py\n     best_iou_at = np.argmax(candidate_ious)\n            best_iou = candidate_ious[best_iou_at]\n            best_bb = _x,_y,_X,_Y = bbs[best_iou_at] \n    ```", "```py\n     if best_iou > 0.3: clss.append(labels[best_iou_at])\n            else : clss.append('background') \n    ```", "```py\n     delta = np.array([_x-cx, _y-cy, _X-cX, _Y-cY]) / np.array([W,H,W,H])\n            deltas.append(delta)\n            rois.append(candidate / np.array([W,H,W,H])) \n    ```", "```py\n     FPATHS.append(fpath)\n        IOUS.append(ious)\n        ROIS.append(rois)\n        CLSS.append(clss)\n        DELTAS.append(deltas)\n        GTBBS.append(bbs) \n    ```", "```py\n    FPATHS = [f'{IMAGE_ROOT}/{stem(f)}.jpg' for f in FPATHS]\n    FPATHS, GTBBS, CLSS, DELTAS, ROIS = [item for item in \\\n                                         [FPATHS, GTBBS, \\\n                                          CLSS, DELTAS, ROIS]] \n    ```", "```py\n    targets = pd.DataFrame(flatten(CLSS), columns=['label'])\n    label2target = {l:t for t,l in enumerate(targets['label'].unique())}\n    target2label = {t:l for l,t in label2target.items()}\n    background_class = label2target['background'] \n    ```", "```py\n    normalize= transforms.Normalize(mean=[0.485, 0.456, 0.406],\n                                    std=[0.229, 0.224, 0.225]) \n    ```", "```py\n    def preprocess_image(img):\n        img = torch.tensor(img).permute(2,0,1)\n        img = normalize(img)\n        return img.to(device).float() \n    ```", "```py\n    def decode(_y):\n        _, preds = _y.max(-1)\n        return preds \n    ```", "```py\n    class RCNNDataset(Dataset):\n        def __init__(self, fpaths, rois, labels, deltas, gtbbs):\n            self.fpaths = fpaths\n            self.gtbbs = gtbbs\n            self.rois = rois\n            self.labels = labels\n            self.deltas = deltas\n        def __len__(self): return len(self.fpaths) \n    ```", "```py\n     def __getitem__(self, ix):\n            fpath = str(self.fpaths[ix])\n            image = cv2.imread(fpath, 1)[...,::-1]\n            H, W, _ = image.shape\n            sh = np.array([W,H,W,H])\n            gtbbs = self.gtbbs[ix]\n            rois = self.rois[ix]\n            bbs = (np.array(rois)*sh).astype(np.uint16)\n            labels = self.labels[ix]\n            deltas = self.deltas[ix]\n            crops = [image[y:Y,x:X] for (x,y,X,Y) in bbs]\n            return image,crops,bbs,labels,deltas,gtbbs,fpath \n    ```", "```py\n     def collate_fn(self, batch):\n            input, rois, rixs, labels, deltas =[],[],[],[],[]\n            for ix in range(len(batch)):\n                image, crops, image_bbs, image_labels, \\\n                    image_deltas, image_gt_bbs, \\\n                    image_fpath = batch[ix]\n                crops = [cv2.resize(crop, (224,224)) for crop in crops]\n                crops = [preprocess_image(crop/255.)[None] for crop in crops]\n                input.extend(crops)\n                labels.extend([label2target[c] for c in image_labels])\n                deltas.extend(image_deltas)\n            input = torch.cat(input).to(device)\n            labels = torch.Tensor(labels).long().to(device)\n            deltas = torch.Tensor(deltas).float().to(device)\n            return input, labels, deltas \n    ```", "```py\n    n_train = 9*len(FPATHS)//10\n    train_ds = RCNNDataset(FPATHS[:n_train],ROIS[:n_train],\n                           CLSS[:n_train], DELTAS[:n_train],\n                           GTBBS[:n_train])\n    test_ds = RCNNDataset(FPATHS[n_train:], ROIS[n_train:],\n                          CLSS[n_train:], DELTAS[n_train:],\n                          GTBBS[n_train:])\n    from torch.utils.data import TensorDataset, DataLoader\n    train_loader = DataLoader(train_ds, batch_size=2,\n                              collate_fn=train_ds.collate_fn,\n                              drop_last=True)\n    test_loader = DataLoader(test_ds, batch_size=2,\n                             collate_fn=test_ds.collate_fn,\n                             drop_last=True) \n    ```", "```py\n    vgg_backbone = models.vgg16(pretrained=True)\n    vgg_backbone.classifier = nn.Sequential()\n    for param in vgg_backbone.parameters():\n        param.requires_grad = False\n    vgg_backbone.eval().to(device) \n    ```", "```py\n    class RCNN(nn.Module):\n        def __init__(self):\n            super().__init__() \n    ```", "```py\n     feature_dim = 25088\n            self.backbone = vgg_backbone\n            self.cls_score = nn.Linear(feature_dim, len(label2target))\n            self.bbox = nn.Sequential(\n                              nn.Linear(feature_dim, 512),\n                              nn.ReLU(),\n                              nn.Linear(512, 4),\n                              nn.Tanh(),\n                            ) \n    ```", "```py\n     self.cel = nn.CrossEntropyLoss()\n            self.sl1 = nn.L1Loss() \n    ```", "```py\n     def forward(self, input):\n            feat = self.backbone(input)\n            cls_score = self.cls_score(feat)\n            bbox = self.bbox(feat)\n            return cls_score, bbox \n    ```", "```py\n     def calc_loss(self, probs, _deltas, labels, deltas):\n            detection_loss = self.cel(probs, labels)\n            ixs, = torch.where(labels != 0)\n            _deltas = _deltas[ixs]\n            deltas = deltas[ixs]\n            self.lmb = 10.0\n            if len(ixs) > 0:\n                regression_loss = self.sl1(_deltas, deltas)\n                return detection_loss + self.lmb *\\\n                    regression_loss, detection_loss.detach(),\n                    regression_loss.detach()\n            else:\n                regression_loss = 0\n                return detection_loss + self.lmb regression_loss, \\\n                       detection_loss.detach(), regression_loss \n    ```", "```py\n    def train_batch(inputs, model, optimizer, criterion):\n        input, clss, deltas = inputs\n        model.train()\n        optimizer.zero_grad()\n        _clss, _deltas = model(input)\n        loss, loc_loss, regr_loss = criterion(_clss, _deltas, clss, deltas)\n        accs = clss == decode(_clss)\n        loss.backward()\n        optimizer.step()\n        return loss.detach(), loc_loss, regr_loss, accs.cpu().numpy() \n    ```", "```py\n    @torch.no_grad()\n    def validate_batch(inputs, model, criterion):\n        input, clss, deltas = inputs\n        with torch.no_grad():\n            model.eval()\n            _clss,_deltas = model(input)\n            loss,loc_loss,regr_loss = criterion(_clss, _deltas, clss, deltas)\n            _, _clss = _clss.max(-1)\n            accs = clss == _clss\n        return _clss,_deltas,loss.detach(), \\\n                      loc_loss, regr_loss, accs.cpu().numpy() \n    ```", "```py\n    rcnn = RCNN().to(device)\n    criterion = rcnn.calc_loss\n    optimizer = optim.SGD(rcnn.parameters(), lr=1e-3)\n    n_epochs = 5\n    log = Report(n_epochs) \n    ```", "```py\n    for epoch in range(n_epochs):\n        _n = len(train_loader)\n        for ix, inputs in enumerate(train_loader):\n            loss, loc_loss,regr_loss,accs = train_batch(inputs, rcnn,\n                                            optimizer, criterion)\n            pos = (epoch + (ix+1)/_n)\n            log.record(pos, trn_loss=loss.item(),\n                       trn_loc_loss=loc_loss,\n                       trn_regr_loss=regr_loss,\n                       trn_acc=accs.mean(), end='\\r')\n\n        _n = len(test_loader)\n        for ix,inputs in enumerate(test_loader):\n            _clss, _deltas, loss, loc_loss, regr_loss, \\\n            accs = validate_batch(inputs, rcnn, criterion)\n            pos = (epoch + (ix+1)/_n)\n            log.record(pos, val_loss=loss.item(),\n                    val_loc_loss=loc_loss,\n                    val_regr_loss=regr_loss,\n                    val_acc=accs.mean(), end='\\r')\n    # Plotting training and validation metrics\n    log.plot_epochs('trn_loss,val_loss'.split(',')) \n    ```", "```py\n    def test_predictions(filename, show_output=True):\n        img = np.array(cv2.imread(filename, 1)[...,::-1])\n        candidates = extract_candidates(img)\n        candidates = [(x,y,x+w,y+h) for x,y,w,h in candidates] \n    ```", "```py\n     input = []\n        for candidate in candidates:\n            x,y,X,Y = candidate\n            crop = cv2.resize(img[y:Y,x:X], (224,224))\n            input.append(preprocess_image(crop/255.)[None])\n        input = torch.cat(input).to(device) \n    ```", "```py\n     with torch.no_grad():\n            rcnn.eval()\n            probs, deltas = rcnn(input)\n            probs = torch.nn.functional.softmax(probs, -1)\n            confs, clss = torch.max(probs, -1) \n    ```", "```py\n     candidates = np.array(candidates)\n        confs,clss,probs,deltas=[tensor.detach().cpu().numpy() \\\n                                  for tensor in [confs, clss, probs, deltas]]\n        ixs = clss!=background_class\n        confs,clss,probs,deltas,candidates = [tensor[ixs] for \\\n               tensor in [confs,clss, probs, deltas,candidates]]\n        bbs = (candidates + deltas).astype(np.uint16) \n    ```", "```py\n     ixs = nms(torch.tensor(bbs.astype(np.float32)),\n                                     torch.tensor(confs), 0.05)\n        confs,clss,probs,deltas,candidates,bbs=[tensor[ixs] \\\n                   for tensor in [confs, clss, probs, deltas, candidates, bbs]]\n        if len(ixs) == 1:\n            confs, clss, probs, deltas, candidates, bbs = \\\n                    [tensor[None] for tensor in [confs, clss,\n                             probs, deltas, candidates, bbs]] \n    ```", "```py\n     if len(confs) == 0 and not show_output:\n            return (0,0,224,224), 'background', 0\n        if len(confs) > 0:\n            best_pred = np.argmax(confs)\n            best_conf = np.max(confs)\n            best_bb = bbs[best_pred]\n            x,y,X,Y = best_bb \n    ```", "```py\n     _, ax = plt.subplots(1, 2, figsize=(20,10))\n        show(img, ax=ax[0])\n        ax[0].grid(False)\n        ax[0].set_title('Original image')\n        if len(confs) == 0:\n            ax[1].imshow(img)\n            ax[1].set_title('No objects')\n            plt.show()\n            return\n        ax[1].set_title(target2label[clss[best_pred]])\n        show(img, bbs=bbs.tolist(),\n            texts=[target2label[c] for c in clss.tolist()],\n            ax=ax[1], title='predicted bounding box and class')\n        plt.show()\n        return (x,y,X,Y),target2label[clss[best_pred]],best_conf \n    ```", "```py\n    image, crops, bbs, labels, deltas, gtbbs, fpath = test_ds[7]\n    test_predictions(fpath) \n    ```", "```py\n    class FRCNNDataset(Dataset):\n        def __init__(self, fpaths, rois, labels, deltas, gtbbs):\n            self.fpaths = fpaths\n            self.gtbbs = gtbbs\n            self.rois = rois\n            self.labels = labels\n            self.deltas = deltas\n        def __len__(self): return len(self.fpaths)\n        def __getitem__(self, ix):\n            fpath = str(self.fpaths[ix])\n            image = cv2.imread(fpath, 1)[...,::-1]\n            gtbbs = self.gtbbs[ix]\n            rois = self.rois[ix]\n            labels = self.labels[ix]\n            deltas = self.deltas[ix]\n            assert len(rois) == len(labels) == len(deltas), \\\n                f'{len(rois)}, {len(labels)}, {len(deltas)}'\n            return image, rois, labels, deltas, gtbbs, fpath\n        def collate_fn(self, batch):\n            input, rois, rixs, labels, deltas = [],[],[],[],[]\n            for ix in range(len(batch)):\n                image, image_rois, image_labels, image_deltas, \\\n                    image_gt_bbs, image_fpath = batch[ix]\n                image = cv2.resize(image, (224,224))\n                input.append(preprocess_image(image/255.)[None])\n                rois.extend(image_rois)\n                rixs.extend([ix]*len(image_rois))\n                labels.extend([label2target[c] for c in image_labels])\n                deltas.extend(image_deltas)\n            input = torch.cat(input).to(device)\n            rois = torch.Tensor(rois).float().to(device)\n            rixs = torch.Tensor(rixs).float().to(device)\n            labels = torch.Tensor(labels).long().to(device)\n            deltas = torch.Tensor(deltas).float().to(device)\n            return input, rois, rixs, labels, deltas \n    ```", "```py\n    n_train = 9*len(FPATHS)//10\n    train_ds = FRCNNDataset(FPATHS[:n_train],ROIS[:n_train],\n                            CLSS[:n_train], DELTAS[:n_train],\n                            GTBBS[:n_train])\n    test_ds = FRCNNDataset(FPATHS[n_train:], ROIS[n_train:],\n                           CLSS[n_train:], DELTAS[n_train:],\n                           GTBBS[n_train:])\n    from torch.utils.data import TensorDataset, DataLoader\n    train_loader = DataLoader(train_ds, batch_size=2,\n                              collate_fn=train_ds.collate_fn,\n                              drop_last=True)\n    test_loader = DataLoader(test_ds, batch_size=2,\n                             collate_fn=test_ds.collate_fn,\n                             drop_last=True) \n    ```", "```py\n    from torchvision.ops import RoIPool \n    ```", "```py\n    class FRCNN(nn.Module):\n        def __init__(self):\n            super().__init__() \n    ```", "```py\n     rawnet= torchvision.models.vgg16_bn(pretrained=True)\n            for param in rawnet.features.parameters():\n                param.requires_grad = False \n    ```", "```py\n     self.seq = nn.Sequential(*list(\\rawnet.features.children())[:-1]) \n    ```", "```py\n     self.roipool = RoIPool(7, spatial_scale=14/224) \n    ```", "```py\n     feature_dim = 512*7*7\n            self.cls_score = nn.Linear(feature_dim, len(label2target))\n            self.bbox = nn.Sequential(\n                              nn.Linear(feature_dim, 512),\n                              nn.ReLU(),\n                              nn.Linear(512, 4),\n                              nn.Tanh(),\n                            ) \n    ```", "```py\n     self.cel = nn.CrossEntropyLoss()\n            self.sl1 = nn.L1Loss() \n    ```", "```py\n     def forward(self, input, rois, ridx): \n    ```", "```py\n     res = input\n            res = self.seq(res) \n    ```", "```py\n     rois = torch.cat([ridx.unsqueeze(-1), rois*224], dim=-1)\n            res = self.roipool(res, rois)\n            feat = res.view(len(res), -1)\n            cls_score = self.cls_score(feat)\n            bbox=self.bbox(feat)#.view(-1,len(label2target),4)\n            return cls_score, bbox \n    ```", "```py\n     def calc_loss(self, probs, _deltas, labels, deltas):\n            detection_loss = self.cel(probs, labels)\n            ixs, = torch.where(labels != background_class)\n            _deltas = _deltas[ixs]\n            deltas = deltas[ixs]\n            self.lmb = 10.0\n            if len(ixs) > 0:\n                regression_loss = self.sl1(_deltas, deltas)\n                return detection_loss + self.lmb * regression_loss, \\\n                       detection_loss.detach(), regression_loss.detach()\n            else:\n                regression_loss = 0\n                return detection_loss + self.lmb * regression_loss, \\\n                       detection_loss.detach(), regression_loss \n    ```", "```py\n    def train_batch(inputs, model, optimizer, criterion):\n        input, rois, rixs, clss, deltas = inputs\n        model.train()\n        optimizer.zero_grad()\n        _clss, _deltas = model(input, rois, rixs)\n        loss, loc_loss, regr_loss =criterion(_clss,_deltas, clss, deltas)\n        accs = clss == decode(_clss)\n        loss.backward()\n        optimizer.step()\n        return loss.detach(), loc_loss, regr_loss, accs.cpu().numpy()\n    def validate_batch(inputs, model, criterion):\n        input, rois, rixs, clss, deltas = inputs\n        with torch.no_grad():\n            model.eval()\n            _clss,_deltas = model(input, rois, rixs)\n            loss, loc_loss,regr_loss = criterion(_clss, _deltas, clss, deltas)\n            _clss = decode(_clss)\n            accs = clss == _clss\n        return _clss,_deltas,loss.detach(),loc_loss,regr_loss, accs.cpu().numpy() \n    ```", "```py\n    frcnn = FRCNN().to(device)\n    criterion = frcnn.calc_loss\n    optimizer = optim.SGD(frcnn.parameters(), lr=1e-3)\n    n_epochs = 5\n    log = Report(n_epochs)\n    for epoch in range(n_epochs):\n        _n = len(train_loader)\n        for ix, inputs in enumerate(train_loader):\n            loss, loc_loss,regr_loss, accs = train_batch(inputs,\n                                    frcnn, optimizer, criterion)\n            pos = (epoch + (ix+1)/_n)\n            log.record(pos, trn_loss=loss.item(),\n                       trn_loc_loss=loc_loss,\n                       trn_regr_loss=regr_loss,\n                       trn_acc=accs.mean(), end='\\r')\n\n        _n = len(test_loader)\n        for ix,inputs in enumerate(test_loader):\n            _clss, _deltas, loss, \\\n            loc_loss, regr_loss, accs = validate_batch(inputs,\n                                               frcnn, criterion)\n            pos = (epoch + (ix+1)/_n)\n            log.record(pos, val_loss=loss.item(),\n                    val_loc_loss=loc_loss,\n                    val_regr_loss=regr_loss,\n                    val_acc=accs.mean(), end='\\r')\n    # Plotting training and validation metrics\n    log.plot_epochs('trn_loss,val_loss'.split(',')) \n    ```", "```py\n    import matplotlib.pyplot as plt\n    %matplotlib inline\n    import matplotlib.patches as mpatches\n    from torchvision.ops import nms\n    from PIL import Image\n    def test_predictions(filename):\n        img = cv2.resize(np.array(Image.open(filename)), (224,224)) \n    ```", "```py\n     candidates = extract_candidates(img)\n        candidates = [(x,y,x+w,y+h) for x,y,w,h in candidates] \n    ```", "```py\n     input = preprocess_image(img/255.)[None]\n        rois = [[x/224,y/224,X/224,Y/224] for x,y,X,Y in candidates] \n    ```", "```py\n     rixs = np.array([0]*len(rois)) \n    ```", "```py\n     rois,rixs = [torch.Tensor(item).to(device) for item in [rois, rixs]]\n        with torch.no_grad():\n            frcnn.eval()\n            probs, deltas = frcnn(input, rois, rixs)\n            confs, clss = torch.max(probs, -1) \n    ```", "```py\n     candidates = np.array(candidates)\n        confs,clss,probs,deltas=[tensor.detach().cpu().numpy() \\\n                 for tensor in [confs, clss, probs, deltas]]\n\n        ixs = clss!=background_class\n        confs, clss, probs,deltas,candidates= [tensor[ixs] for \\\n              tensor in [confs, clss, probs, deltas,candidates]]\n        bbs = candidates + deltas \n    ```", "```py\n     ixs = nms(torch.tensor(bbs.astype(np.float32)),\n                    torch.tensor(confs), 0.05)\n        confs, clss, probs,deltas,candidates,bbs= [tensor[ixs] \\ \n                      for tensor in [confs,clss,probs, deltas, candidates, bbs]]\n        if len(ixs) == 1:\n            confs, clss, probs, deltas, candidates, bbs = \\\n                        [tensor[None] for tensor in [confs,clss,\n                                probs, deltas, candidates, bbs]]\n\n        bbs = bbs.astype(np.uint16) \n    ```", "```py\n     _, ax = plt.subplots(1, 2, figsize=(20,10))\n        show(img, ax=ax[0])\n        ax[0].grid(False)\n        ax[0].set_title(filename.split('/')[-1])\n        if len(confs) == 0:\n            ax[1].imshow(img)\n            ax[1].set_title('No objects')\n            plt.show()\n            return\n        else:\n            show(img,bbs=bbs.tolist(),\n        texts=[target2label[c] for c in clss.tolist()],ax=ax[1])\n            plt.show() \n    ```", "```py\n    test_predictions(test_ds[29][-1]) \n    ```"]