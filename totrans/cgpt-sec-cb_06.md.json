["```py\n    import openai\n    from openai import OpenAI\n    import os\n    from mitreattack.stix20 import MitreAttackData\n    openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n    ```", "```py\n    mitre_attack_data = MitreAttackData(\"enterprise-attack.json\")\n    ```", "```py\n    def extract_keywords_from_description(description):\n        # Define the merged prompt\n        prompt = (f\"Given the cybersecurity scenario description: '{description}', identify and list the key terms, \"\n                  \"techniques, or technologies relevant to MITRE ATT&CK. Extract TTPs from the scenario. \"\n                  \"If the description is too basic, expand upon it with additional details, applicable campaign, \"\n                  \"or attack types based on dataset knowledge. Then, extract the TTPs from the revised description.\")\n        # Set up the messages for the OpenAI API\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": \"You are a cybersecurity professional with more than 25 years of experience.\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt\n            }\n        ]\n        # Make the API call\n        try:\n            client = OpenAI()\n            response = client.chat.completions.create(\n                model=\"gpt-3.5-turbo\",\n                messages=messages,\n                max_tokens=2048,\n                n=1,\n                stop=None,\n                temperature=0.7\n            )\n            response_content = response.choices[0].message.content.strip()\n            keywords = response_content.split(', ')\n            return keywords\n        except Exception as e:\n            print(\"An error occurred while connecting to the OpenAI API:\", e)\n            return []\n    ```", "```py\n    def score_matches(matches, keywords):\n        scores = []\n        for match in matches:\n            score = sum([keyword in match['name'] for keyword in keywords]) + \\\n                    sum([keyword in match['description'] for keyword in keywords])\n            scores.append((match, score))\n        return scores\n    def search_dataset_for_matches(keywords):\n        matches = []\n        for item in mitre_attack_data.get_techniques():\n            if any(keyword in item['name'] for keyword in keywords):\n                matches.append(item)\n            elif 'description' in item and any(keyword in item['description'] for keyword in keywords):\n                matches.append(item)\n        return matches\n    ```", "```py\n    def generate_ttp_chain(match):\n        # Create a prompt for GPT-3 to generate a TTP chain for the provided match\n        prompt = (f\"Given the MITRE ATT&CK technique '{match['name']}' and its description '{match['description']}', \"\n                  \"generate an example scenario and TTP chain demonstrating its use.\")\n        # Set up the messages for the OpenAI API\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": \"You are a cybersecurity professional with expertise in MITRE ATT&CK techniques.\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt\n            }\n        ]\n        # Make the API call\n        try:\n            client = OpenAI()\n            response = client.chat.completions.create(\n                model=\"gpt-3.5-turbo\",\n                messages=messages,\n                max_tokens=2048,\n                n=1,\n                stop=None,\n                temperature=0.7\n            )\n            response_content = response.choices[0].message.content.strip()\n            return response_content\n        except Exception as e:\n            print(\"An error occurred while generating the TTP chain:\", e)\n            return \"Unable to generate TTP chain.\"\n    ```", "```py\n    description = input(\"Enter your scenario description: \")\n    keywords = extract_keywords_from_description(description)\n    matches = search_dataset_for_matches(keywords)\n    scored_matches = score_matches(matches, keywords)\n    # Sort by score in descending order and take the top 3\n    top_matches = sorted(scored_matches, key=lambda x: x[1], reverse=True)[:3]\n    print(\"Top 3 matches from the MITRE ATT&CK dataset:\")\n    for match, score in top_matches:\n        print(\"Name:\", match['name'])\n        print(\"Summary:\", match['description'])\n        ttp_chain = generate_ttp_chain(match)\n        print(\"Example Scenario and TTP Chain:\", ttp_chain)\n        print(\"-\" * 50)\n    ```", "```py\nimport openai\nfrom openai import OpenAI\nimport os\nfrom mitreattack.stix20 import MitreAttackData\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\n# Load the MITRE ATT&CK dataset using MitreAttackData\nmitre_attack_data = MitreAttackData(\"enterprise-attack.json\")\ndef extract_keywords_from_description(description):\n    # Define the merged prompt\n    prompt = (f\"Given the cybersecurity scenario description: '{description}', identify and list the key terms, \"\n              \"techniques, or technologies relevant to MITRE ATT&CK. Extract TTPs from the scenario. \"\n              \"If the description is too basic, expand upon it with additional details, applicable campaign, \"\n              \"or attack types based on dataset knowledge. Then, extract the TTPs from the revised description.\")\n    # Set up the messages for the OpenAI API\n    messages = [\n        {\n            \"role\": \"system\",\n            \"content\": \"You are a cybersecurity professional with more than 25 years of experience.\"\n        },\n        {\n            \"role\": \"user\",\n            \"content\": prompt\n        }\n    ]\n    # Make the API call\n    try:\n        response = openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=messages,\n            max_tokens=2048,\n            n=1,\n            stop=None,\n            temperature=0.7\n        )\n        response_content = response.choices[0].message.content.strip()\n        keywords = response_content.split(', ')\n        return keywords\n    except Exception as e:\n        print(\"An error occurred while connecting to the OpenAI API:\", e)\n        return []\ndef score_matches(matches, keywords):\n    scores = []\n    for match in matches:\n        score = sum([keyword in match['name'] for keyword in keywords]) + \\\n                sum([keyword in match['description'] for keyword in keywords])\n        scores.append((match, score))\n    return scores\ndef search_dataset_for_matches(keywords):\n    matches = []\n    for item in mitre_attack_data.get_techniques():\n        if any(keyword in item['name'] for keyword in keywords):\n            matches.append(item)\n        elif 'description' in item and any(keyword in item['description'] for keyword in keywords):\n            matches.append(item)\n    return matches\ndef generate_ttp_chain(match):\n    # Create a prompt for GPT-3 to generate a TTP chain for the provided match\n    prompt = (f\"Given the MITRE ATT&CK technique '{match['name']}' and its description '{match['description']}', \"\n              \"generate an example scenario and TTP chain demonstrating its use.\")\n    # Set up the messages for the OpenAI API\n    messages = [\n        {\n            \"role\": \"system\",\n            \"content\": \"You are a cybersecurity professional with expertise in MITRE ATT&CK techniques.\"\n        },\n        {\n            \"role\": \"user\",\n            \"content\": prompt\n        }\n    ]\n    # Make the API call\n    try:\n        client = OpenAI()\n        response = client.chat.completions.create\n        (\n            model=\"gpt-3.5-turbo\",\n            messages=messages,\n            max_tokens=2048,\n            n=1,\n            stop=None,\n            temperature=0.7\n        )\n        response_content = response.choices[0].message.content.strip()\n        return response_content\n    except Exception as e:\n        print(\"An error occurred while generating the TTP chain:\", e)\n        return \"Unable to generate TTP chain.\"\n# Sample usage:\ndescription = input(\"Enter your scenario description: \")\nkeywords = extract_keywords_from_description(description)\nmatches = search_dataset_for_matches(keywords)\nscored_matches = score_matches(matches, keywords)\n# Sort by score in descending order and take the top 3\ntop_matches = sorted(scored_matches, key=lambda x: x[1], reverse=True)[:3]\nprint(\"Top 3 matches from the MITRE ATT&CK dataset:\")\nfor match, score in top_matches:\n    print(\"Name:\", match['name'])\n    print(\"Summary:\", match['description'])\n    ttp_chain = generate_ttp_chain(match)\n    print(\"Example Scenario and TTP Chain:\", ttp_chain)\n    print(\"-\" * 50)\n```", "```py\n    def write_to_file(matches):\n        with open(\"red_team_scenarios.txt\", \"w\") as file:\n            for match in matches:\n                file.write(\"Name: \" + match['name'] + \"\\n\")\n                file.write(\"Summary: \" + match['summary'] + \"\\n\")\n                file.write(\"Example Scenario: \" + match['scenario'] + \"\\n\")\n                file.write(\"-\" * 50 + \"\\n\")\n    write_to_file(top_matches)\n    ```", "```py\n    You are a cybersecurity professional with 25 years of experience, specializing in red team tactics. Think step-by-step and create a detailed list of steps to perform OSINT, as part of a cyber penetration test.\n    ```", "```py\n    \"You are a cybersecurity professional with 25 years of experience, specializing in red team tactics. Think step-by-step and provide more detail on how I achieve the following. Include any applicable tools, apps, and resources.\n    Identify the Target: Identify the target organization or individual you will be focusing on during the OSINT phase. Gather as much information as possible about the target, such as the organization's name, website, key personnel, or any other relevant details.\"\n    ```", "```py\n    \"You are a cybersecurity professional specializing in red team tactics. I am a cybersecurity professional and I have a scenario where I need to find exposed documents on a my own domain. Please provide a list of example Google dorks that I can use to discover such vulnerabilities as part of an authorized exercise on my own authorized domain.\"\n    ```", "```py\n    import requests\n    import time\n    ```", "```py\n    API_KEY = 'YOUR_GOOGLE_API_KEY'\n    CSE_ID = 'YOUR_CUSTOM_SEARCH_ENGINE_ID'\n    SEARCH_URL = \"https://www.googleapis.com/customsearch/v1?q={query}&key={api_key}&cx={cse_id}\"\n    ```", "```py\n    dorks = [\n        'site:example.com filetype:pdf',\n        'intitle:\"index of\" site:example.com',\n        'inurl:admin site:example.com',\n        'filetype:sql site:example.com',\n        # ... add other dorks here ...\n    ]\n    ```", "```py\n    def get_search_results(query):\n        \"\"\"Fetch the Google search results.\"\"\"\n        response = requests.get(SEARCH_URL.format(query=query, api_key=API_KEY, cse_id=CSE_ID))\n        if response.status_code == 200:\n            return response.json()\n        else:\n            print(\"Error:\", response.status_code)\n            return {}\n    ```", "```py\n    def main():\n        with open(\"dork_results.txt\", \"a\") as outfile:\n            for dork in dorks:\n                print(f\"Running dork: {dork}\")\n                results = get_search_results(dork)\n                if 'items' in results:\n                    for item in results['items']:\n                        print(item['title'])\n                        print(item['link'])\n                        outfile.write(item['title'] + \"\\n\")\n                        outfile.write(item['link'] + \"\\n\")\n                        outfile.write(\"-\" * 50 + \"\\n\")\n                else:\n                    print(\"No results found or reached API limit!\")\n                # To not hit the rate limit, introduce a delay between requests\n                time.sleep(20)\n    ```", "```py\nimport requests\nimport time\n# Google Custom Search JSON API configuration\nAPI_KEY = 'YOUR_GOOGLE_API_KEY'\nCSE_ID = 'YOUR_CUSTOM_SEARCH_ENGINE_ID'\nSEARCH_URL = \"https://www.googleapis.com/customsearch/v1?q={query}&key={api_key}&cx={cse_id}\"\n# List of Google dorks\ndorks = [\n    'site:example.com filetype:pdf',\n    'intitle:\"index of\" site:example.com',\n    'inurl:admin site:example.com',\n    'filetype:sql site:example.com',\n    # ... add other dorks here ...\n]\ndef get_search_results(query):\n    \"\"\"Fetch the Google search results.\"\"\"\n    response = requests.get(SEARCH_URL.format(query=query, api_key=API_KEY, cse_id=CSE_ID))\n    if response.status_code == 200:\n        return response.json()\n    else:\n        print(\"Error:\", response.status_code)\n        return {}\ndef main():\n    with open(\"dork_results.txt\", \"a\") as outfile:\n        for dork in dorks:\n            print(f\"Running dork: {dork}\")\n            results = get_search_results(dork)\n            if 'items' in results:\n                for item in results['items']:\n                    print(item['title'])\n                    print(item['link'])\n                    outfile.write(item['title'] + \"\\n\")\n                    outfile.write(item['link'] + \"\\n\")\n                    outfile.write(\"-\" * 50 + \"\\n\")\n            else:\n                print(\"No results found or reached API limit!\")\n            # To not hit the rate limit, introduce a delay between requests\n            time.sleep(20)\nif __name__ == '__main__':\n    main()\n```", "```py\n    API_KEY = 'YOUR_GOOGLE_API_KEY'\n    CSE_ID = 'YOUR_CUSTOM_SEARCH_ENGINE_ID'\n    SEARCH_URL = https://www.googleapis.com/customsearch/v1?q={query}&key={api_key}&cx={cse_id}\n    ```", "```py\n    You are a cybersecurity professional with more than 25 years of experience, specializing in red team tactics. As part of an authorized penetration test, and using your knowledge of OSINT and social engineering tactics, analyze the following sample job description for useful OSINT data. Be sure to include any correlations and conclusions you might draw.\n    ```", "```py\n    You are a cybersecurity professional with more than 25 years of experience, specializing in red team tactics. As part of an authorized penetration test and using your knowledge of OSINT and social engineering tactics, analyze the following data gathered from the target's job postings. Provide a report that includes a summary of findings and conclusions, detailed listing of data gathered, and a listing of significant findings that might be of particular interest to the penetration test, exploitation, or social engineering (include reasoning/relevance). Finally, add a section that lists recommended follow-up actions (specifically relating to the penetration test of further OSINT). Use markdown language formatting. Use the following report format:\n    #OSINT Report Title\n    ##Summary\n    ##Details\n    ##Significant Findings\n    ##Recommended Follow-up Actions\n    ```", "```py\n    import openai\n    from openai import OpenAI\n    import os\n    import subprocess\n    ```", "```py\n    def open_file(filepath): #Open and read a file\n        with open(filepath, 'r', encoding='UTF-8') as infile:\n            return infile.read()\n    ```", "```py\n    def gpt_3(prompt):\n        try:\n            client = OpenAI()\n            response = client.chat.completions.create(\n                model=\"gpt-3.5-turbo\", \n                prompt=prompt,\n                temperature=0.1,\n                max_tokens=600,\n            )\n            text = response.choices[0].message.content.strip()\n            return text\n        except openai.error.APIError as e:\n            print(f\"\\nError communicating with the API.\")\n            print(f\"\\nError: {e}\")\n            print(\"\\nRetrying...\")\n            return gpt_3(prompt)\n    ```", "```py\n    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, bufsize=1, universal_newlines=True)\n    ```", "```py\n    while True:\n        request = input(\"\\nEnter request: \")\n        if not request:\n            break\n        if request == \"quit\":\n            break\n        prompt = open_file(\"prompt4.txt\").replace('{INPUT}', request)\n        command = gpt_3(prompt)\n        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, bufsize=1, universal_newlines=True)\n        print(\"\\n\" + command + \"\\n\")\n        with process:\n            for line in process.stdout:\n                print(line, end='', flush=True)\n        exit_code = process.wait()\n    ```", "```py\n    append_file(\"command-log.txt\", \"Request: \" + request + \"\\nCommand: \" + command + \"\\n\\n\")\n    ```", "```py\n    Provide me with the Windows CLI command necessary to complete the following request:\n    {INPUT}\n    Assume I have all necessary apps, tools, and commands necessary to complete the request. Provide me with the command only and do not generate anything further. Do not provide any explanation. Provide the simplest form of the command possible unless I ask for special options, considerations, output, etc.. If the request does require a compound command, provide all necessary operators, options, pipes, etc.. as a single one-line command. Do not provide me more than one variation or more than one line.\n    ```", "```py\nimport openai\nfrom openai import OpenAI\nimport os\nimport subprocess\ndef open_file(filepath): #Open and read a file\n    with open(filepath, 'r', encoding='UTF-8') as infile:\n        return infile.read()\ndef save_file(filepath, content): #Create a new file or overwrite an existing one.\n    with open(filepath, 'w', encoding='UTF-8') as outfile:\n        outfile.write(content)\ndef append_file(filepath, content): #Create a new file or append an existing one.\n    with open(filepath, 'a', encoding='UTF-8') as outfile:\n        outfile.write(content)\n#openai.api_key = os.getenv(\"OPENAI_API_KEY\") #Use this if you prefer to use the key in an environment variable.\nopenai.api_key = open_file('openai-key.txt') #Grabs your OpenAI key from a file\ndef gpt_3(prompt): #Sets up and runs the request to the OpenAI API\n    try:\n        client = OpenAI()\n        response = client.chat.completions.create(\n            model=\"gpt-3.5-turbo\", \n            prompt=prompt,\n            temperature=0.1,\n            max_tokens=600,\n        )\n        text = response['choices'].message.content.strip()\n        return text\n    except openai.error.APIError as e: #Returns and error and retries if there is an issue communicating with the API\n        print(f\"\\nError communicating with the API.\")\n        print(f\"\\nError: {e}\") #More detailed error output\n        print(\"\\nRetrying...\")\n        return gpt_3(prompt)\nwhile True: #Keeps the script running until we issue the \"quit\" command at the request prompt\n    request = input(\"\\nEnter request: \")\n    if not request:\n        break\n    if request == \"quit\":\n        break\n    prompt = open_file(\"prompt4.txt\").replace('{INPUT}', request) #Merges our request input with the pre-written prompt file\n    command = gpt_3(prompt)\n    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, bufsize=1, universal_newlines=True) #Prepares the API response to run in an OS as a command\n    print(\"\\n\" + command + \"\\n\")\n    with process: #Runs the command in the OS and gives real-time feedback\n        for line in process.stdout:\n            print(line, end='', flush=True)\n    exit_code = process.wait()\n    append_file(\"command-log.txt\", \"Request: \" + request + \"\\nCommand: \" + command + \"\\n\\n\") #Write the request and GPT generated command to a log\n```"]