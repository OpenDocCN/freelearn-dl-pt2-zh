- en: Heuristic Search Techniques and Logical Inference
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce a broad range of problem-solving tools. We
    will start by looking at ontologies and knowledge-based reasoning before moving
    on to optimization in the context of **Boolean satisfiability** (**SAT**) and
    combinatorial optimization, where we'll simulate the result of individual behavior and
    coordination in society. Finally, we'll implement Monte Carlo tree search to find
    the best moves in chess.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be dealing with various techniques in this chapter, including logic solvers,
    graph embeddings, **genetic algorithms** (**GA**), **particle swarm optimization**
    (**PSO**), SAT solvers, **simulated annealing** (**SA**), ant colony optimization,
    multi-agent systems, and Monte Carlo tree search.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Making decisions based on knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving the n-queens problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the shortest bus route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating the spread of a disease
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a chess engine with Monte Carlo tree search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Making decisions based on knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a lot of background knowledge is available about a topic, why not use it
    when making decisions? This is called a knowledge-based system. Inference engines
    in expert systems and unification, as done in logic solvers, are examples of this.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to retrieve knowledge when making decisions is based on representing
    knowledge in a graph. Every node in the graph represents a concept, while every
    edge represents a relationship. Both can be embedded and represented as numerical
    features that express their location with respect to the other elements of the
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll go through two examples for each of these possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: From Aristotle to Linnaeus to today's mathematicians and physicists, people
    have tried to put order into the world by categorizing objects into a systematic
    order, called taxonomy. Mathematically, taxonomies are expressed as graphs, which
    represent information as tuples *(s, o), *in that subject s which is connected
    to object o; or triplets *(s, p, o)*, in that *a* is related to (a predicate of)* p* to
    *o*. A frequently used type of taxonomy is the ISA taxonomy, where relationships
    are of the type is*-a*. For example, a car is a vehicle, and a plane is also a
    vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll use a logic solver interfaced from the `nltk` (**natural
    language toolkit**) library from Python, and then use the graph libraries known
    as `networkx` and `karateclub`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pip` command you''ll need to use to download these libraries is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For the second part of this recipe, we'll also need to download the zoo dataset
    from Kaggle, which is available at [https://www.kaggle.com/uciml/zoo-animal-classification](https://www.kaggle.com/uciml/zoo-animal-classification).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we explained in the introduction to this recipe, we'll look at two different
    problems from two different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with logical reasoning using a logic solver.
  prefs: []
  type: TYPE_NORMAL
- en: Logical reasoning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this part of this recipe, we'll look at a simple example of logical reasoning
    using libraries bundled with the `nltk` library. There are many other ways to
    approach logical inference, some of which we'll look at in the *See also...* section
    at the end of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use a very simple toy problem that you could find in any *101 – Introduction
    to Logic* book, though a more complex approach to such problems could be taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our problem is well-known: if all men are mortal, and Socrates is a man, is
    Socrates mortal?'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can express this very naturally in `nltk`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The reasoning provided by the solver can also be read naturally, so we won't
    explain this here. We'll learn how this works internally in the *How it works...*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at knowledge embedding.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge embedding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this part of this recipe, we'll try to make use of how information is interrelated
    by embedding it into a multidimensional space that can serve as part of featurization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''ll load the data, preprocess it, embed it, and then test our embedding
    by classifying species, given their new features. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dataset loading and preprocessing**: First, we''ll load the zoo dataset into
    pandas, as we''ve done many times already. Then, we''ll make sure that the binary
    columns are represented as `bool` instead of `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The zoo dataset contains 101 animals, each with features describing whether
    it, for example, has hair or produces milk. Here, the target class is the biological
    class of the animal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Graph embedding**: The `get_triplet()` function returns triplets for binary
    and integer elements in the format (*s*, *p*, *o*). Note that we create triplets
    from the full dataset, rather than just the training dataset. However, to avoid
    target leakage, we don''t create triplets from the target for data points outside
    the training set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create our triplets. Let''s take a look at some of
    them to get an idea of what they look like. The following are the first 20 entries
    we get; we used `triplets[:20]` to obtain them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block shows a few examples of the resultant triplets. In
    total, we got 842 triplets out of 101 rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can load this dataset into a graph using the `networkx` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Vocabulary` class is a wrapper for the `label2id` and `id2label` dictionaries.
    We need this because some graph embedding algorithms don't accept string names
    for nodes or relationships. Here, we converted the concept labels into IDs before
    storing them in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can embed the graph numerically with different algorithms. We''ll use
    `Walklets` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows that every concept in the graph will be represented
    by a 5-dimensional vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can test whether these features are useful for predicting the target
    (`the animal`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This looks quite good, though the technique only becomes really interesting
    if we have a knowledge base that goes beyond our training set. It is hard to show
    graph embedding without loading millions of triplets or huge graphs. We'll mention
    a few large knowledge bases in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll look at the basic concepts behind this recipe, as well
    as its corresponding methods. First, we'll cover logical reasoning and logic provers,
    before looking at knowledge embedding and graph embedding with Walklets.
  prefs: []
  type: TYPE_NORMAL
- en: Logical reasoning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logical reasoning is a term that bridges logical inference techniques such as
    deduction, induction, and abduction. **Abductive reasoning**, which is often used
    in expert systems, is the process of examining the available observations and
    deriving possible conclusions (the **best explanation**) from them.
  prefs: []
  type: TYPE_NORMAL
- en: An expert system is a reasoning system that emulates the decision-making abilities
    of human experts. Expert systems are designed to solve complex problems by reasoning through
    bodies of knowledge, represented mainly as if-then-else rules (this is called
    a **knowledge base**).
  prefs: []
  type: TYPE_NORMAL
- en: '**Inductive reasoning** is about determining a conclusion while following the
    initial premises and a rule. In **deductive reasoning**, we infer a rule from
    observations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply logical reasoning, a linguistic statement has to be encoded as a well-formed
    logical formula so that we can apply logical calculus. A well-formed formula can
    contain the following entities:'
  prefs: []
  type: TYPE_NORMAL
- en: Predicate symbols such as *P*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The equality symbol, ![](img/545096dd-fa85-4d9d-a871-cdefbe354cef.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Negation, ![](img/53c24013-9588-4000-a136-097c75269a05.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary connectives such as ![](img/98e2563b-94db-4ae8-afc4-4f8657c8ae33.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantifiers such as ![](img/75440140-643f-4d1a-a844-d114521c3111.png) (for all)
    and ![](img/0bf2d4e5-1c93-4fdb-8686-ab6e6004fc8d.png) (there exists).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the reasoning that *Socrates is a man. Man is mortal. Therefore,
    Socrates is mortal*, can be expressed as a logical statement using propositional
    logic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8ac40e5-3dcc-4ed0-b84b-bcdf306724c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we'll look at logic provers.
  prefs: []
  type: TYPE_NORMAL
- en: Logic provers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Automated theorem proving is a wide field that includes work based on logical
    theorems and mathematical formulas. We've already looked at the problem of proving
    a first-order logic equation that consists of logical equations. A search algorithm
    is combined with logical equations so that the satisfiability of a propositional
    formula can be decided on (see the *Solving the n-queens problem* recipe in this
    chapter), as well as the validity of a sentence, given a set of axioms. The *Resolution
    Theorem Prover* in `nltk` provides other functionality, such as unification, subsumption,
    and **question answering** (**QA**): [http://www.nltk.org/howto/resolution.html](http://www.nltk.org/howto/resolution.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we'll look at knowledge embedding.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge embedding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **knowledge embedding** (**KE**) refers to the distributed representations
    of concepts derived from their relationships. These are often represented in a
    **knowledge graph** (**KG**).
  prefs: []
  type: TYPE_NORMAL
- en: 'A well-known example of a KG is **WordNet** (G.A. Miller and others, *WordNet:
    An online lexical database*; 1990), which provides synonyms, hypernyms, and other
    expansions of words, similar to a thesaurus, and is available with different GUIs
    and an appropriate command line for all major operating systems. WordNet is available
    in more than 200 languages, and each word (synset) is related to other words over
    directed semantic relationships, such as hypernyms or hyponyms, meronyms or holonyms,
    and others.'
  prefs: []
  type: TYPE_NORMAL
- en: KGs can be used in **natural language processing** (**NLP**) applications to
    support decision-making, where they can be used effectively as lookup engines
    or for reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge embeddings are low-dimensional representations of concept relationships
    and can be extracted using embedding or more generic dimensionality reduction
    methods. In the next subsection, we'll look at the Walklet embedding method.
  prefs: []
  type: TYPE_NORMAL
- en: Graph embedding with Walklets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Walklet algorithm basically applies the Word2Vec skipgram algorithm to vertices
    in a graph, so instead of embeddings of words (the original application of Word2Vec),
    we'll get embeddings of concepts based on their connections. The Walklet algorithm subsamples
    short random walks on the vertices of a graph, as paths, which are then passed
    to the shallow neural network (see the following diagram) for skipgram training.
  prefs: []
  type: TYPE_NORMAL
- en: The skipgram algorithm (Mikolov and others 2013; [https://arxiv.org/abs/1301.3781](https://arxiv.org/abs/1301.3781))
    predicts the context of words (that is, vertices) based on the word itself. Each
    word is featurized as a continuous bag of words vector (in practice, each word
    gets indexed in a dictionary that we use), and we predict the indexes of the surrounding
    words (concepts) based on hidden layer projection. The dimensionality of this
    hidden layer's projection and the window size of the context are the main parameters
    of the algorithm. After training, we use the hidden layer as the embedding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the skipgram network architecture, which
    contains an input layer, a hidden layer, and an output layer of word predictions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fed0371-75d1-4335-9469-b7c20c468b6d.png)'
  prefs: []
  type: TYPE_IMG
- en: '*w(t)* refers to the current word (or concept), while *w(t-2)*, *w(t-1)*, *w(t+1)*,
    and *w(t+2)* refer to two words before and after, respectively. We predict the
    word context based on the current word. As we''ve already mentioned, the size
    of the context (window size) is a hyperparameter of the skipgram algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: A related algorithm is the **continuous bag-of-words algorithm** (**CBOW**),
    where the architecture is inverted - we predict a single word based on the context.
    Both are based on the hypothesis that words that co-occur have related meaning
    or that they have distributional similarity, which implies that they are similar
    in terms of their meaning. This is called a **distributional hypothesis** (Harris,
    1954, *Distributional structure*).
  prefs: []
  type: TYPE_NORMAL
- en: The Walklet algorithm performs well on large graphs and – since it's a neural
    network – can be trained online. You can find out more about Walklets in the 2017
    paper by Brian Perozzi and others, *Don't Walk, Skip! Online Learning of Multi-scale** Network
    Embeddings*([https://arxiv.org/abs/1605.02115](https://arxiv.org/abs/1605.02115)).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are libraries that can be used for logical inference in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: SymPy: [https://docs.sympy.org/latest/modules/logic.html](https://docs.sympy.org/latest/modules/logic.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kanren logic programming: [https://github.com/logpy/logpy](https://github.com/logpy/logpy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyDatalog: [https://sites.google.com/site/pydatalog/](https://sites.google.com/site/pydatalog/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've been following the inference guide in `nltk` for this recipe. You can
    find more tools at the official `nltk` website: [http://www.nltk.org/howto/inference.html](http://www.nltk.org/howto/inference.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other libraries for graph embedding are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: KarateClub: [https://karateclub.readthedocs.io/en/latest/index.html](https://karateclub.readthedocs.io/en/latest/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pykg2vec: [https://github.com/Sujit-O/pykg2vec](https://github.com/Sujit-O/pykg2vec)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyTorch BigGraph (by Facebook Research): [https://github.com/facebookresearch/PyTorch-BigGraph](https://github.com/facebookresearch/PyTorch-BigGraph)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphVite: [https://graphvite.io/](https://graphvite.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AmpliGraph (by Accenture): [https://docs.ampligraph.org/](https://docs.ampligraph.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pyRDF2Vec: [https://github.com/IBCNServices/pyRDF2Vec](https://github.com/IBCNServices/pyRDF2Vec)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KarateClub, which is maintained by Benedek Rozemberczki, a PhD student at the
    University of Edinburgh, contains many implementations of unsupervised graph embedding
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some graph libraries provide link prediction as well. This means that, for
    a given set of nodes, you can infer whether a relationship to other nodes exists.
    A review of link prediction can be found in *Knowledge Graph Embedding for Link
    Prediction: A Comparative Analysis*, by Andrea Rossi and others. (2020; [https://arxiv.org/abs/2002.00819](https://arxiv.org/abs/2002.00819)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some resources for reasoning about the real world and/or with common sense
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ActionCores: [http://www.actioncores.org/apidoc.html#pracinference](http://www.actioncores.org/apidoc.html#pracinference)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KagNet: [https://github.com/INK-USC/KagNet](https://github.com/INK-USC/KagNet)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allen AI Commonsense Knowledge Graphs: [https://mosaic.allenai.org/projects/commonsense-knowledge-graphs](https://mosaic.allenai.org/projects/commonsense-knowledge-graphs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Commonsense Reasoning Problem Page* at NYU CS: [http://commonsensereasoning.org/problem_page.html](http://commonsensereasoning.org/problem_page.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning on graphs: Open Graph Benchmark: Datasets for Machine Learning on
    Graphs, Hu and others, 2020* ([https://arxiv.org/pdf/2005.00687.pdf](https://arxiv.org/pdf/2005.00687.pdf))
    is another reference for graph embedding with machine learning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several large real-world knowledge databases available, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Wikidata: [https://www.wikidata.org/](https://www.wikidata.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conceptnet5: [https://github.com/commonsense/conceptnet5](https://github.com/commonsense/conceptnet5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Open Multilingual Wordnet: [http://compling.hss.ntu.edu.sg/omw/](http://compling.hss.ntu.edu.sg/omw/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yago: [https://github.com/yago-naga/yago3](https://github.com/yago-naga/yago3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving the n-queens problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mathematical logic, satisfiability is about whether a formula can be valid
    under some interpretation (parameters). We say that a formula is unsatisfiable
    if it can't be true under any interpretation. A **Boolean satisfiability problem**,
    or **SAT**, is all about whether a Boolean formula is valid (satisfiable) under
    any of the values of its parameters. Since many problems can be reduced to SAT
    problems, and solvers and optimizations for it exist, it is an important class
    of problems.
  prefs: []
  type: TYPE_NORMAL
- en: SAT problems have been proven to be NP-complete. NP-completeness (short for
    **nondeterministic polynomial time**) means that a solution to a problem can be
    verified in polynomial time. Note that this doesn't mean that a solution can be
    found quickly, only that a solution can be verified quickly. NP-complete problems
    are often approached with search heuristics and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll address a SAT problem in various ways. We'll take a relatively
    simple and well-studied case known as the n-queens problem, where we try to place
    queens on a chessboard of *n* by *n* squares so that any column, row, and diagonal
    can only take, at most, one queen.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll apply a GA, then PSO, and then a specialized SAT solver.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll be using the `dd` solver for one of the approaches in this recipe. To
    install it, we also need the `omega` library. We can get both by using the `pip`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the dd SAT solver libraries later, but first, we'll look at some other
    algorithmic approaches.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start with the GA.
  prefs: []
  type: TYPE_NORMAL
- en: Genetic algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we''ll define how a chromosome is represented and how it can mutate.
    Then, we''ll define a feedback loop for testing these chromosomes and changing
    them. We''ll explain the algorithm itself in the *How it works...* section, toward
    the end of this recipe. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Representing a solution** (a chromosome): An object-oriented style lends
    itself to defining chromosomes. Let''s look at our implementation. First, we need
    to know what a chromosome is and what it does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates our basic data structure, which contains a candidate
    solution that can replicate and mutate. This code refers to a cost function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a cost function so that we know how to fit our genes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can select genes based on this cost function (see the `fitness()` method).
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing the main algorithm**: The GA for the n-queens problem is as follows
    (we''ve omitted the visualization here):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This class contains the population of chromosomes and can have methods applied
    to it (population control, if you like), such as what parents to use (`get_parents()`)
    and mating them (`cross_over()`). Take note of the `iterate()` method, which is
    where the main logic is implemented. We'll comment on the main decisions we've
    made here in the *How it works...* section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the algorithm**: We execute our algorithm by simply instantiating
    a `GeneticQueen` and calling `iterate()`. We can also put in a few extra lines
    to get regular updates and to collect fitness data over time. We then run the
    algorithm, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can visualize the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding code, we''ll get a single run that looks like this
    (yours may look different):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac966a3c-1d5d-4a9a-9d61-b5f3c6051cc9.png)'
  prefs: []
  type: TYPE_IMG
- en: This took close to 8 seconds to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following plot shows the fitness of the best chromosome at each iteration
    of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58a57946-e6ab-4001-a30c-753e83544296.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that the fitness of the algorithm doesn't always improve; it
    can also go down. We could have chosen to keep the best chromosome here. In that
    case, we wouldn't have seen any decline (but the potential downside is that we
    could have ended up in a local minimum).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to PSO!
  prefs: []
  type: TYPE_NORMAL
- en: Particle swarm optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this part of this recipe, we''ll be implementing a PSO algorithm for the
    n-queens problem from scratch. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Representing a solution**: Similar to the GA, we need to define what a solution
    looks like. In PSO, this means we define a particle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the main data structure that we'll be working with. It contains a candidate
    solution. Applying PSO will involve changing a bunch of these particles. We'll
    explain how `Particle` works in more detail in the *How it works...* section.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the same cost function that we defined for the GA. This
    cost function tells us how well our particles fit the given problem – in other
    words, how good a property vector is.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll wrap our initialization and the main algorithm into a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `get_best_particle()` method returns the best configuration and the best
    score. Take note of the `iterate()` method, which updates our particles and returns
    the best particle, along with its score. Details regarding this update are provided
    in the *How it works...* section. The optimization process itself is done using
    a few formulas that are relatively simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also want to display our solutions. The code for showing the board positions
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the main algorithm for PSO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to what we did in the case of the GA, we track how well our solutions
    do over the iterations (via our cost function). The main function returns the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`best_particle`: The best solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scores`: The best scores over our iterations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned previously, we'll explain how all of this works in the *How
    it works...* section.
  prefs: []
  type: TYPE_NORMAL
- en: You can view the output of the algorithm being run with *n = 8* at [https://github.com/PacktPublishing/Artificial-Intelligence-with-Python-Cookbook/blob/master/chapter05/solving-n-queens.md](https://github.com/PacktPublishing/Artificial-Intelligence-with-Python-Cookbook/blob/master/chapter05/solving-n-queens.md).
  prefs: []
  type: TYPE_NORMAL
- en: We are using the chess library for visualization here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following plot, you can see the quality of the solutions over our iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1882e481-9689-40e1-bc00-9e98ff95a298.png)'
  prefs: []
  type: TYPE_IMG
- en: Since all the particles maintain their own records of the best solution, the
    score can never decline. At iteration 1,323, we reached a solution and the algorithm
    stopped.
  prefs: []
  type: TYPE_NORMAL
- en: SAT solver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is heavily based on the example that can be found in the `dd` library,
    copyright of California Institute of Technology, at [https://github.com/tulip-control/dd/blob/0f6d16483cc13078edebac9e89d1d4b99d22991e/examples/queens.py](https://github.com/tulip-control/dd/blob/0f6d16483cc13078edebac9e89d1d4b99d22991e/examples/queens.py).
  prefs: []
  type: TYPE_NORMAL
- en: In a modern SAT solver in Python, we can define our constraints as simple functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, there''s one formula that incorporates all the constraints. Once
    all the constraints have been satisfied (or the conjunction of all the constraints),
    the solution is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the constraint for `at_least_one_queen_per_row`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we take disjunctions over the queens on each row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main run looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When we run this, we should see an example solution. We should also get some
    statistics regarding how many solutions were found and how long it took to find them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is our example solution for the eight queens problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adf9eaae-ec96-44ba-aa1f-6f99090ae6a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The textual output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This solver not only got all the solutions (we only visualized one of them)
    but was also about twice as fast as the GA!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll explain the different approaches we employed in this
    recipe, starting with the GA.
  prefs: []
  type: TYPE_NORMAL
- en: Genetic algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The GA is quite simple at heart: we maintain a set of candidate solutions (called
    chromosomes) and we have two operations we can use to change them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cross-over`: Two chromosomes have children (which means they mix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutation:` A chromosome changes randomly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A chromosome has a candidate solution that's stored in `configuration`. When
    initializing a chromosome, we have to give it either the number of queens or the
    initial configuration. We covered what chromosomes actually are previously in
    this chapter. If a configuration is not given, then we need to create one with
    a list comprehension, such as `[random.randint(1, nq) for _ in range(nq)]`.
  prefs: []
  type: TYPE_NORMAL
- en: A chromosome can calculate its own fitness; here, we used the same cost function
    that we used previously, but this time, we scaled it to be between 0 and 1, where
    1 means we found a solution and anything in-between shows how close we are to
    getting a solution. A chromosome can also mutate itself; that is, it can randomly
    change one of its values.
  prefs: []
  type: TYPE_NORMAL
- en: 'At each iteration of the algorithm, we create a new generation of chromosomes
    by using these two operations. The algorithm itself is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we initialize our first generation of chromosomes with different values
    representing the different parameters of the solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we calculate the fitness of our chromosomes. This can be done by interacting
    with the environment or it could be intrinsic to the solution, as in our combinatorial
    problem of the nine queens problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we create a new generation of chromosomes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose parents while taking their fitness into account
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutate a few chromosomes according to a certain probability
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we repeat from *Step 2* until the fitness is high enough or we have
    iterated a lot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've expressed the last step very loosely here. Basically, we can decide when
    the fitness is high enough and how many times we want to iterate. These are our
    stopping criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very legible in our implementation of `GeneticQueen.iterate()`, so
    let''s have another look for visualization purposes (only slightly simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A major decision we have to make regarding the GA is whether we maintain the
    best solution or whether all the chromosomes (even the best) must die (potentially
    after giving birth to offspring). Here, each iteration creates a completely new
    generation.
  prefs: []
  type: TYPE_NORMAL
- en: We randomly choose parents by weighting them by their fitness, where the fittest
    are more likely to be chosen. The `cross-over` function in our implementation
    randomly decides between two of the parents for each parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main hyperparameters and major decisions that must be made for the GA are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Population size (how many chromosomes do we have?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutation rate (how much do chromosomes change when they mutate?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many (and which) chromosomes create offspring? Typically, these are the
    ones with the highest fitness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are our stopping criteria? Typically, there's a threshold value for the
    algorithm's fitness and a set number of iterations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, the GA is quite flexible and very intuitive. In the next section,
    we'll look at PSO.
  prefs: []
  type: TYPE_NORMAL
- en: Particle swarm optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We started our implementation with the `Particle` data structure. To initialize
    a particle, we pass the number of queens (`N`) or the vectors for our velocities
    and parameters. Basically, a particle has a configuration, or a set of parameters –
    a vector, in this case – that fits a problem to a certain degree (`current_particle`),
    and a velocity (similar to a learning rate). Each property vector from a particle
    represents the queens' positions.
  prefs: []
  type: TYPE_NORMAL
- en: PSO then applies changes to particles in a particular way. PSO is a combination
    of local search and global search; that is, at each particle, we try to direct
    our search toward the best particle globally and the best the particle has been
    in the past. A particle maintains a record of its best instantiation; that is,
    the vector of its best parameters and the corresponding score. We also maintain
    the corresponding velocities of the parameters. These velocities can slow down,
    increase, or change direction according to the formula being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'PSO takes a few parameters, as follows (most of these were named in our implementation;
    here, we''re omitting the ones that are specific to our nine queens problem):'
  prefs: []
  type: TYPE_NORMAL
- en: '`omega`: The decay parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phip`: Controls the contribution of the local search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phig`: Controls the contribution of the global search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n_particles`: The number of particles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_iterations`: Used for early stopping without a solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our PSO problem, there were two deltas, `delta_p` and `delta_g`, where *p*
    and *g* stand for particle and global, respectively. This is because of one of
    them is calculated with respect to the particle's historic best and the other
    is calculated with respect to the particle's global best.
  prefs: []
  type: TYPE_NORMAL
- en: 'The update is calculated according to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, `rp` and `rg` are random numbers and `phip` and `phig` are the local and
    global factors, respectively. They refer to either a unique particle or all the
    particles, as shown in the `delta_p` and `delta_g` variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also another parameter, `omega`, that regulates the decay of the current
    velocities. At each iteration, the new velocities are calculated according to
    the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In turn, the particle parameters are incremented according to their velocities.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the algorithm is sensitive to what's chosen for `phip`, `phig`, and `omega`.
  prefs: []
  type: TYPE_NORMAL
- en: Our cost function (or goodness function) calculates the score for a particle
    according to a given configuration of queens. This configuration is represented
    as a list of indexes in the range ]0, N-1[*.* For each pair of queens, the function
    checks whether they overlap either in the diagonal, vertical, or horizontal sense.
    Each non-conflicting check awards a point, so the maximal number of points is![](img/f0965a57-dba1-4252-a522-06eced1f26c9.png).
    This is 28 for the 8 queens problem.
  prefs: []
  type: TYPE_NORMAL
- en: SAT solver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are lots of different ways **specialized satisfiability** (**SAT**) solvers
    work. A survey by Weiwei Gong and Xu Zhou (2017) provides a broad overview of
    the different approaches: [https://aip.scitation.org/doi/abs/10.1063/1.4981999](https://aip.scitation.org/doi/abs/10.1063/1.4981999).
  prefs: []
  type: TYPE_NORMAL
- en: The `dd` solver, which we used in our recipe, works using **binary decision
    diagrams** (**BDD**), which were introduced by Randal Bryant (*Graph-based algorithms
    for Boolean function manipulation*, 1986). Binary decision diagrams (sometimes
    called **branching programs**) are constraints represented as Boolean functions
    as opposed to other encodings, such as negation normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a BDD, an algorithm or a set of constraints is expressed as a Boolean function
    over a Boolean domain of dimension, *n*, that evaluates to true or false:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0c150ba-9740-4023-a19f-3ea43deae487.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that we can represent problems as binary trees or, equivalently,
    as truth tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s look at an example. We can enumerate all the states
    over our binary variables (*x1*, *x2*, and *x3*) and then come up with a final
    state that''s the result of *f*. The following truth table summarizes the states
    of our variables, as well as our function evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *x1* | *x2* | *x3* | *f* |'
  prefs: []
  type: TYPE_TB
- en: '| False | False | False | False |'
  prefs: []
  type: TYPE_TB
- en: '| False | False | True | False |'
  prefs: []
  type: TYPE_TB
- en: '| False | True | False | False |'
  prefs: []
  type: TYPE_TB
- en: '| False | True | True | False |'
  prefs: []
  type: TYPE_TB
- en: '| True | False | False | True |'
  prefs: []
  type: TYPE_TB
- en: '| True | False | True | False |'
  prefs: []
  type: TYPE_TB
- en: '| True | True | False | True |'
  prefs: []
  type: TYPE_TB
- en: '| True | True | True | True |'
  prefs: []
  type: TYPE_TB
- en: 'This corresponds to the following binary tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea715312-19c9-45ce-a2ae-bcc9a3124140.png)'
  prefs: []
  type: TYPE_IMG
- en: Binary trees and truth tables have highly optimized library implementations,
    which means they can run very fast. This explains how we got our results so quickly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are lots of other SAT solvers in Python, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft''s PDP solver: [https://github.com/microsoft/PDP-Solver](https://github.com/microsoft/PDP-Solver)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Z3, by Microsoft Research: [https://github.com/Z3Prover/z3](https://github.com/Z3Prover/z3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python bindings to picosat, developed by Continuum: [https://github.com/ContinuumIO/pycosat](https://github.com/ContinuumIO/pycosat)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A discussion of the SAT solver, when applied to Sudoku, can be found here: [https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/](https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/).
  prefs: []
  type: TYPE_NORMAL
- en: An example of Z3 for the Knights and Knaves problem can be found here: [https://jamiecollinson.com/blog/solving-knights-and-knaves-with-z3/](https://jamiecollinson.com/blog/solving-knights-and-knaves-with-z3/).
  prefs: []
  type: TYPE_NORMAL
- en: Finding the shortest bus route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding the shortest bus route implies finding a path that connects points (bus
    stops) on a map. This is an instance of the traveling salesman problem. In this
    recipe, we'll approach the problem of finding the shortest bus route with different
    algorithms, including simulated annealing and ant colony optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from standard dependencies such as `scipy` and `numpy`, which we always
    rely on, we'll be using the `scikit-opt` library, which implements many different
    algorithms for swarm intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Swarm intelligence is the collective behavior of decentralized, self-organized
    systems that leads to the emergence of apparent intelligence in the eyes of an
    observer. This concept is used in work based on artificial intelligence. Natural
    systems, such as ant colonies, bird flocking, hawks hunting, animal herding, and
    bacterial growth, display a certain level of intelligence at the global level,
    even though ants, birds, and hawks typically exhibit relatively simple behavior.
    Swarm algorithms, which are inspired by biology, include the genetic algorithm,
    particle swarm optimization, simulated annealing, and ant colony optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install `scikit-opt` with `pip` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to tackle the traveling salesman problem.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, we'll approach our shortest bus route problem in
    two different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a list of coordinates (longitude, latitude) for bus
    stops. The difficulty of the problem depends on the number of stops (`N`). Here,
    we''ve set `N` to `15`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also precalculate a distance matrix between stops, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can feed this distance matrix into the two algorithms to save time.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with simulated annealing.
  prefs: []
  type: TYPE_NORMAL
- en: Simulated annealing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this subsection, we''ll write our algorithm for finding the shortest bus
    route. This is based on Luke Mile''s Python implementation of simulated annealing,
    when applied to the traveling salesman problem: [https://gist.github.com/qpwo/a46274751cc5db2ab1d936980072a134](https://gist.github.com/qpwo/a46274751cc5db2ab1d936980072a134).
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation itself is short and succinct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to call the algorithm, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the final solution – the path looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b06783a1-cd08-427f-8393-fa053648e368.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also plot the internal distance measure of the algorithm. Please note
    how this internal cost function goes down all the time until about 800,000 iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ed8b401-9405-4b86-a9ca-6bfbc670008e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's try out ant colony optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Ant colony optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we''re loading the implementation from a library. We''ll explain the
    details of this in the *How it works...* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We are using the distance calculations based on the point distances (`distance_matrix`)
    we retrieved previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we can plot the best path and the path distance over iterations, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2836f8ea-47e2-447a-b4d6-8e60b7fef4b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Once again, we can see the final path, which is the result of our optimization
    (the subplot on the left), as well as the distance as it goes down over iterations
    of the algorithm (the subplot on the right).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The shortest bus route problem is an example of the **traveling salesman problem** (**TSP**),
    which, in turn, is a well-known example of combinatorial optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Combinatorial optimization refers to using combinatorial techniques to solve
    discrete optimization problems. In other words, it is the act of finding a solution
    among a combination of objects. Discrete, in this case, means that there are a
    finite number of options. The intelligence part of combinatorial optimization
    goes into either reducing the search space or accelerating the search. The traveling
    salesman problem, the minimum spanning tree problem, the marriage problem, and
    the knapsack problem are all applications of combinatorial optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TSP can be stated as follows: given a list of towns to visit, which is
    the shortest path that traverses all of them and leads back to the point of origin?
    The TSP has applications in domains such as planning, logistics, and microchip design.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at simulated annealing and ant colony optimization in
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Simulated annealing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simulated annealing is a probabilistic optimization technique. The name comes
    from metallurgy, where heating and cooling is used to reduce the defects in materials.
    Briefly, at each iteration, a state transition (a change) can occur. If the change
    is successful, the system will lower its temperature. This can be repeated until
    the state is good enough or until we reach a certain number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we randomly initialized our city tour and then iterated for
    simulated annealing. The main idea of SA is that the rate of changes depends on
    a certain temperature. In our implementation, we decreased the temperature logistically
    from 4 to 0. In each iteration, we tried swapping (we could have tried other operations)
    two random bus stops, indexes *i* and *j* in our path (tour), where *i < j*, and
    then we calculated the sum of distances to *i* from *i-1* to *i*, from *i* to
    *i+1*, from *j-1* to *j*, and from *j* to *j+1* (see `calc_distance`). We also
    needed a distance measure for `calc_distance`. We chose the Euclidean distance
    here, but we could have chosen others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The temperature gets factored in when we need to decide whether to accept the
    swap. We calculate the exponential of the difference in path length before and
    after the swap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a27925b2-5ca8-464f-a966-f4cd0733f1e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, we draw a random number. We accept the change if this random number is
    lower than our expression; otherwise, we undo it.
  prefs: []
  type: TYPE_NORMAL
- en: Ant colony optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name suggests, **ant colony optimization** is inspired by ant colonies.
    Let''s use pheromones, which are secreted by ants as they follow a path, as an
    analogy: here, the agents have candidate solutions that are more attractive the
    closer they get to the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, ant number *k* moves from state *x* to state *y* with the following probability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cca21206-5116-4d0a-b6bb-b7d3d9bae156.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Tau* is the pheromone trail that''s deposited between *x* and *y*. The *eta*
    parameter controls the influence of the pheromone, where *eta* to the power of
    *beta* is the state transition (for example, one over the cost of the transition).
    Pheromone trails are updated according to how good the overall solution that included
    the state transition was.'
  prefs: []
  type: TYPE_NORMAL
- en: The `scikit-opt` function does the heavy lifting here. We only have to pass
    a few parameters, such as the distance function, the number of points, the number
    of ants in the population, the number of iterations, and the distance matrix,
    before calling `run()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also solve this problem as a mixed-integer problem. The Python-MIP library
    solves mixed-integer problems, and you can find an example for the TSP at [https://python-mip.readthedocs.io/en/latest/examples.html](https://python-mip.readthedocs.io/en/latest/examples.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The TSP can be solved with a Hopfield Network as well, as explained in this
    tutorial: [https://www.tutorialspoint.com/artificial_neural_network/artificial_neural_network_optimization_using_hopfield.htm](https://www.tutorialspoint.com/artificial_neural_network/artificial_neural_network_optimization_using_hopfield.htm).
    A cuckoo search approach is discussed here: [https://github.com/Ashwin-Surana/cuckoo-search](https://github.com/Ashwin-Surana/cuckoo-search).'
  prefs: []
  type: TYPE_NORMAL
- en: '`scikit-opt` is a powerful library for heuristic algorithms. It includes the
    following algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: Differential evolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Genetic algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle swarm optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulated annealing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ant colony algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immune algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial fish swarm algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `scikit-opt` documentation contains more examples of solving the TSP: [https://scikit-opt.github.io/scikit-opt/#/en/README?id=_22-genetic-algorithm-for-tsptravelling-salesman-problem](https://scikit-opt.github.io/scikit-opt/#/en/README?id=_22-genetic-algorithm-for-tsptravelling-salesman-problem). Another
    library similar to `scikit-opt` is `pyswarms`, available at [https://pyswarms.readthedocs.io/en/latest/index.html](https://pyswarms.readthedocs.io/en/latest/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the introduction to this recipe, transport logistics has
    its own application in the TSP, even in its purest form. A dataset of 30,000 public
    buses, minibuses, and vans in Mexico is available at [https://thelivinglib.org/mapaton-cdmx/](https://thelivinglib.org/mapaton-cdmx/).
  prefs: []
  type: TYPE_NORMAL
- en: Simulating the spread of a disease
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandemics such as smallpox, tuberculosis, and the Black Death have affected
    the human population significantly throughout history. As of 2020, Covid-19 is
    spreading through populations all over the world, and the politics and economics
    of getting the virus under control with little casualties have been widely discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding Covid-19, to libertarians, Sweden was, for some time, the poster child
    for how you didn't need a lockdown, although secondary factors such as having
    a high proportion of single-person households and a cultural tendency to social
    distance weren't taken into account. Recently, fatalities in Sweden have been
    on the rise, and its per capita rate is one of the highest recorded ([https://www.worldometers.info/coronavirus/](https://www.worldometers.info/coronavirus/)).
  prefs: []
  type: TYPE_NORMAL
- en: In the UK, the initial response was to rely on herd immunity, and the lockdown
    was declared only weeks after other countries had already imposed it. The **National
    Health Service** (**NHS**) were using makeshift beds and renting beds in commercial
    hospitals because they didn't have the capacity to cope.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **multi-agent system** (**MAS**) is a computer simulation consisting of participants
    known as agents. The individual agents can respond heuristically or based on reinforcement
    learning. Conjunctively, the system behavior of these agents responding to each
    other and to the environment can be applied to study topics, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cooperation and coordination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed constraint optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication and negotiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed problem solving, especially distributed constraint optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, a relatively simple, multi-agent simulation will show you how
    different responses can cause a difference in the number of fatalities, and the
    spread, of a pandemic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be using the `mesa` multi-agent modeling library to implement our multi-agent
    simulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pip` command for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to go!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This simulation is based on work by Maple Rain Research Co., Ltd. For this recipe,
    we've made a few changes regarding introducing factors such as hospital beds and
    lockdown policies, and we've also changed how infections and active cases are
    accounted for. You can find the complete code at [https://github.com/benman1/covid19-sim-mesa](https://github.com/benman1/covid19-sim-mesa).
  prefs: []
  type: TYPE_NORMAL
- en: 'Disclaimer: This recipe''s intent is not to provide medical advice, nor are
    we qualified medical practitioners or specialists.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to define our agents through the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This defines an agent as a person with a health and quarantine status.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need a few methods to change how other properties can change. We won''t
    go through all of them, just the ones that should suffice for you to gain an understanding
    of how everything comes together. The core thing we need to understand is what
    agents do while they''re infected. Basically, while infected, we need to understand
    whether the agents infect others, die from the infection, or recover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see quite a few variables that are defined at the model level,
    such as `self.model.critical_rate`, `self.model.hospital_factor`, and `self.model.recovery_period`. We'll
    look at these model variables in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a way for our agents to record their position, which is what in
    `mesa` is called a `MultiGrid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is relatively straightforward. If agents move, they move within their neighborhood;
    that is, the next adjacent cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entry method, which is called at every cycle (iteration), is the `step()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Agents move at every step if they are alive. Here''s what happens when they
    move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the main logic of our agents; that is, `Person`. Now, let's look
    at how everything comes together at the model level. This can be found in the
    `Simulation` class inside `model.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the agents are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates as many agents as we need. Some of them will be infected
    according to the `start_infected` parameter. We also add the agents to a map of
    cells organized in a grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to define a few data collectors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables in this dictionary of lists are appended in every cycle so that
    we can plot them or evaluate them statistically. As an example, let''s see how
    the `active_cases` function is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When called, the function iterates over the agents in the model and counts the
    ones whose status is `infected`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, just like for `Person`, the main logic of `Simulation` is in the `step()`
    method, which advances the model by one cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how different lockdown policies affect deaths and the spread of the
    disease over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the same set of variables that we used previously in these simulations.
    We''ve set them so that they roughly correspond to the UK according to a factor
    of 1/1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We'll explain the motivation for the grid in the *How it works...* section.
  prefs: []
  type: TYPE_NORMAL
- en: Lockdown is declared by the `lockdown_policy` method, which is passed to the
    constructor of `Simulation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the data when no lockdown was introduced. We can create
    this policy if our `policy` function always returns `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting graph shows our five collected variables over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dadc7951-0559-418e-8da7-a54ec51e1248.png)'
  prefs: []
  type: TYPE_IMG
- en: Overall, we have 8,774 deaths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see several waves of infections as lockdown is lifted early according
    to this policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this simulation, we get a completely different result, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb631cd4-91dc-4621-bfaa-b39786d40cec.png)'
  prefs: []
  type: TYPE_IMG
- en: The rectangular shape around 250 iterations shows when lockdown was declared
    (ignore the scale or shape). Overall, we can see that this resulted in 20,663
    deaths. This extremely high death rate –much higher than the `critical_rate` parameter –
    has been set to 5% due to reinfection before immunity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare this to a very cautious policy of declaring lockdown every time
    the death rate rises or if the rate of infected in the population rises above
    20% within (roughly) 3 weeks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'With a single lockdown, we get the following graph, which shows about 600 deaths
    overall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0201d7c-7781-4da1-8408-76ad16e461d5.png)'
  prefs: []
  type: TYPE_IMG
- en: You can change these parameters or play with the logic to create more sophisticated
    and/or realistic simulations.
  prefs: []
  type: TYPE_NORMAL
- en: More details around the original work can be found online ([https://teck78.blogspot.com/2020/04/using-mesa-framework-to-simulate-spread.html](https://teck78.blogspot.com/2020/04/using-mesa-framework-to-simulate-spread.html)).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simulation is quite simple: it''s composed of agents and proceeds in iterations
    (called cycles). Each agent represents a part of the population.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, a certain population is infected with the disease. At each cycle (which
    corresponds to 1 hour), infected people can go to the hospital (if there's capacity),
    die, or make progress toward recovery. They can also go into quarantine. While
    alive, not recovered, and not in quarantine, they can infect other people in spatial
    proximity to them. When recovering, agents can become immune.
  prefs: []
  type: TYPE_NORMAL
- en: At each cycle, agents can move around. They move to a new position if they're
    not in quarantine or the national lockdown has been declared; otherwise, they
    stay in place. If a person is infected, they can die, go to the hospital, recover,
    infect others, or go into quarantine.
  prefs: []
  type: TYPE_NORMAL
- en: 'A national lockdown can be declared according to different policies, depending
    on death and infection rates. This is the main focus of our simulation: how does
    the introduction of a national lockdown affect fatalities?'
  prefs: []
  type: TYPE_NORMAL
- en: We need to consider different variables for this. One is population density.
    We can introduce population density by putting our agents on a map or a grid,
    where the grid size is defined by `grid_x` and `grid_y`. The `infect_rate` parameter
    must be tweaked according to grid size and population density.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a lot more parameters to take into account here, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initial_infected` is the rate at which the population is initially infected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recovery_period` declares the number of cycles (roughly in hours) it takes
    to recover after being infected, with `0` for never.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`critical_rate` is the rate over the whole recovery period in which an ill
    person can get critically ill, which means they''d go to the hospital, if possible,
    or die.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hospital_capacity_rate` is the number of hospital beds per person over the
    whole population. We found this through online searches ([https://www.hsj.co.uk/acute-care/nhs-hospitals-have-four-times-more-empty-beds-than-normal/7027392.article](https://www.hsj.co.uk/acute-care/nhs-hospitals-have-four-times-more-empty-beds-than-normal/7027392.article), [https://www.kingsfund.org.uk/publications/nhs-hospital-bed-numbers](https://www.kingsfund.org.uk/publications/nhs-hospital-bed-numbers)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's also `active_ratio`, which defines how active a person is; `quarantine_rate`,
    which determines how likely someone will go into self-quarantine (if not the hospital); and `immunity_chance`,
    which is relevant after recovery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simulation is going to run for a set amount of `cycles`, and our lockdown
    policy is declared in the `lockdown_policy` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `step()` method of `Simulation`, we performed data collection. Then,
    we checked whether the hospitals can take on any more patients according to the `free_beds` variable.
    Then, we ran the agents with `self.schedule.step()`. If we were in lockdown, we
    counted down. Lockdown is set from `False` to the `lockdown_period` variable (by
    taking liberty with Python's duck typing) once lockdown is declared.
  prefs: []
  type: TYPE_NORMAL
- en: The `lockdown_policy()` function determines how long the national lockdown should
    be, given how many agents are infected and deaths over time (lists). Here, 0 means
    we don't declare lockdown.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the simulations can take a long time to run, it can be very slow to try
    out parameters. Instead of having to do a full run, and only then see if we get
    the desired effect or not, we can use the live plotting functionality of `matplotlib.`
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get faster feedback, let''s live plot the simulation loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will continuously (every 10 cycles) update our plot of the simulation parameters.
    Instead of having to wait for a full simulation, we can abort it if it doesn't
    work out.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find out more about mesa''s multi-agent-based modeling in Python at
    [https://mesa.readthedocs.io/en/master/](https://mesa.readthedocs.io/en/master/)).
    Some other multi-agent libraries are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: MAgent specializes in 2D environments with a very large number of agents that
    learn through reinforcement learning: [https://github.com/PettingZoo-Team/MAgent](https://github.com/PettingZoo-Team/MAgent).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: osBrain and PADE are general-purpose multi-agent system libraries. They can
    be found at [https://osbrain.readthedocs.io/en/stable/](https://osbrain.readthedocs.io/en/stable/) and [https://pade.readthedocs.io/en/latest/](https://pade.readthedocs.io/en/latest/),
    respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SimPy is a discrete event simulator that can be used for a broader range of
    simulations: [https://simpy.readthedocs.io/en/latest/](https://simpy.readthedocs.io/en/latest/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other simulators have also been released, most prominently the CovidSim microsimulation
    model ([https://github.com/mrc-ide/covid-sim](https://github.com/mrc-ide/covid-sim)),
    which was developed by the MRC Centre for Global Infectious Disease Analysis,
    hosted at Imperial College, London.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a chess engine with Monte Carlo tree search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chess is a two-player board game that's been popular as a game of wits since
    the 15th century. A computer beat the first human player in the 1950s (a complete
    novice) before one beat the human world champion in 1997\. They have since moved
    on to having superhuman intelligence. One of the main difficulties of writing
    a chess engine – a computer program that plays chess – is searching through the
    many variations and combinations and picking the best one.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll use Monte Carlo tree search to create a basic chess engine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use the `python-chess` library for visualization, to get valid moves,
    and to know if a state is terminal. We can install it with the `pip` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We'll be using this library for visualization, to generate valid moves at each
    position, and to check if we've reached a final position.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on a minimal implementation of Monte Carlo tree search
    by Luke Miles at [https://gist.github.com/qpwo/c538c6f73727e254fdc7fab81024f6e1](https://gist.github.com/qpwo/c538c6f73727e254fdc7fab81024f6e1).
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll look at the code we'll be using to define our tree search class,
    and then look at how the search works. After that, we'll learn how this can be
    adapted to chess.
  prefs: []
  type: TYPE_NORMAL
- en: Tree search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A tree search is a search that employs a search tree as a data structure. In
    general, in a search tree, nodes (or leaves) represent a concept or a situation,
    and these are then connected over edges (branches). The tree search traverses
    the tree to come up with the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the tree search class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We'll look at these variables in more detail in the *How it works...* section.
    We'll be adding more methods to this class shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different steps in our tree search are performed in our `do_rollout` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Each `rollout()` call adds one layer to our tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get through the four main steps in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `select` step finds a leaf node from which no simulation has been initiated
    yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is defined recursively, so if we don't find an unexplored node, we explore
    a child of the current node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expansion step adds the children nodes – the nodes that can be reached
    via valid moves, given a board position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This function updates the `children` dictionary with the descendants (or children)
    of the node. These nodes are any valid board positions that can be reached from
    the node in a single move.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simulation step runs a series of moves until the game is ended:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This function plays out the simulation until the end of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The backpropagation step associates a reward with each step of the path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need a way to choose the best move, which can be as simple as going
    through the `Q` and `N` dictionaries and choosing the descendent with the maximum
    utility (reward):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We set the score of any unseen node to `-infinity`, in order to avoid choosing
    an unseen move.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let's learn how to use a node for our chess implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is based on the `python-chess` library, it is relatively easy to
    implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We've omitted a few methods here, but don't worry – we will be covering them
    in the *How it works...* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything has been prepared, we can finally play chess.
  prefs: []
  type: TYPE_NORMAL
- en: Playing chess
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's play some chess!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is just a simple loop with a graphical prompt stating the board
    position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You should then be asked to enter a move to go to a certain position on the
    chessboard. After each move, a board will appear, showing the current position
    of the chess pieces. This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b028c2ce-c138-4008-bf02-ab37d0372fa8.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that moves have to be entered in UCI notation. If you enter the move in
    a format that's square to square – for example, a2a4 – it should always work.
  prefs: []
  type: TYPE_NORMAL
- en: The playing strength being used here isn't very high, but it should still be
    easy to see a few improvements that you can make while play around with it. Note
    that this implementation is not parallelized.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In **Monte Carlo tree search** (**MCTS**), we apply the Monte Carlo method –
    which is basically random sampling – in order to obtain an idea of the strength
    of the moves that are made by the player. For each move, we play random moves
    until the game finishes. If we do this often enough, we'll get a good estimate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tree search maintains different variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Q` is the total reward of each node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`N` is the total visit count for each node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`children` holds the children of each node – the nodes that can be reached
    from a board position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A node is a board state in our case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These dictionaries are important because we average the utility of a node (a
    board state) over rewards, and we sample nodes based on how often (or rather,
    how little) they have been visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each iteration of the search consists of four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Selection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expansion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simulation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Backpropagation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The selection step, at its most basic, looks for a node (such as a board position)
    that hasn't been explored yet.
  prefs: []
  type: TYPE_NORMAL
- en: The expansion step updates the `children` dictionary with the children of the
    selected node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simulation step is straightforward: we play out a chain of random moves
    until a terminal position is reached and return the reward. Since this is a two-player,
    zero-sum board game, we have to invert the reward when it''s the opponent''s turn.'
  prefs: []
  type: TYPE_NORMAL
- en: The backpropagation step follows the path in a backward direction to associate
    the reward with all the nodes in the explored path. The `_backpropagate()` method backtracks all
    the nodes along a series of moves (a path), attributes them with a reward, and
    updates the number of visits.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for implementing a node, nodes must be hashable and comparable since we''ll
    store them in the dictionaries we mentioned previously. So, here, we need to implement
    the `__hash__` and `__eq__` methods. We omitted them previously since we didn''t
    need them to understand the algorithm itself, so we''ve added them here for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `__repr__()` method can be quite useful when you are debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the main functionality of the `ChessGame` class, we also need the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`find_children()`: Finds all possible successors from the current node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_random_child()`: Finds a random successor from the current node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_terminal()`: Determines whether a node is terminal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reward()`: Provides a reward for the current node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please take a look at the implementation of `ChessGame` again to see this in
    action.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One major extension of MCTS is **Upper Confidence Trees** (**UCTs**), which
    are used to balance exploration and exploitation. The first Go programs to reach
    dan level on a 9x9 board used MCTS with UCT.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `UCT` extension, we have to go back to our `MCTS` class and
    make a couple of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `uct()` function applies the **Upper-Confidence-Bound** (**UCB**) formula,
    which provides a move with a score. The score of node *n* is the sum of the number
    of simulations won among all simulations, starting with node *n*, plus a confidence
    term:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cd15c9a-842a-4e93-9c8b-6866bed8a6e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *c* is a constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to replace the last line of code so that it uses `_uct_select()` instead
    of ` _select()` for recursion. Here, we''ll replace the last line of `_select()` so
    that it states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Making this change should increase the agent's playing strength further.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find out more about UCTs, take a look at the following article on MoGO regarding
    the first computer Go program to reach dan level on a 9x9 board: [https://hal.inria.fr/file/index/docid/369786/filename/TCIAIG-2008-0010_Accepted_.pdf](https://hal.inria.fr/file/index/docid/369786/filename/TCIAIG-2008-0010_Accepted_.pdf).
    It also provides a description of MCTS in pseudocode.
  prefs: []
  type: TYPE_NORMAL
- en: The easyAI library contains a lot of different search algorithms: [https://zulko.github.io/easyAI/index.html](https://zulko.github.io/easyAI/index.html).
  prefs: []
  type: TYPE_NORMAL
