["```py\nimport torch\nfrom autoPyTorch import AutoNetClassification\n```", "```py\ntrain_ds = datasets.MNIST(...)\ntest_ds = datasets.MNIST(...)\n```", "```py\nX_train, X_test, y_train, y_test = train_ds.data.numpy().reshape(-1, 28*28), test_ds.data.numpy().reshape(-1, 28*28) ,train_ds.targets.numpy(), test_ds.targets.numpy()\n```", "```py\nautoPyTorch = AutoNetClassification(\"tiny_cs\",  # config preset\n             log_level='info', max_runtime=2000, min_budget=100, max_budget=1500)\n```", "```py\nautoPyTorch.fit(X_train, y_train, validation_split=0.1)\n```", "```py\ny_pred = autoPyTorch.predict(X_test)print(\"Accuracy score\", np.mean(y_pred.reshape(-1) == y_test))\n```", "```py\npytorch_model = autoPyTorch.get_pytorch_model()\nprint(pytorch_model)\n```", "```py\nx = torch.randn(1, pytorch_model[0].in_features)\ny = pytorch_model(x)\narch = make_dot(y.mean(), params=dict(pytorch_model.named_parameters()))\narch.format=\"pdf\"\narch.filename = \"convnet_arch\"\narch.render(view=False)\n```", "```py\nautoPyTorch.get_hyperparameter_search_space()\n```", "```py\nimport torch\nimport optuna\n```", "```py\nclass ConvNet(nn.Module):\n    def __init__(self, trial):\n        super(ConvNet, self).__init__()\n        num_conv_layers =  trial.suggest_int(\"num_conv_layers\", 1, 4)\n        num_fc_layers = trial.suggest_int(\"num_fc_layers\", 1, 2)\n```", "```py\n self.layers = []\n        input_depth = 1 # grayscale image\n        for i in range(num_conv_layers):\n            output_depth = trial.suggest_int(f\"conv_depth_{i}\", 16, 64)\n            self.layers.append(nn.Conv2d(input_depth, output_depth, 3, 1))\n            self.layers.append(nn.ReLU())\n            input_depth = output_depth\n        self.layers.append(nn.MaxPool2d(2))\n        p = trial.suggest_float(f\"conv_dropout_{i}\", 0.1, 0.4)\n        self.layers.append(nn.Dropout(p))\n        self.layers.append(nn.Flatten())\n```", "```py\n input_feat = self._get_flatten_shape()\n        for i in range(num_fc_layers):\n            output_feat = trial.suggest_int(f\"fc_output_feat_{i}\", 16, 64)\n            self.layers.append(nn.Linear(input_feat, output_feat))\n            self.layers.append(nn.ReLU())\n            p = trial.suggest_float(f\"fc_dropout_{i}\", 0.1, 0.4)\n            self.layers.append(nn.Dropout(p))\n            input_feat = output_feat\n        self.layers.append(nn.Linear(input_feat, 10))\n        self.layers.append(nn.LogSoftmax(dim=1))\n        self.model = nn.Sequential(*self.layers)\n    def _get_flatten_shape(self):\n        conv_model = nn.Sequential(*self.layers)\n        op_feat = conv_model(torch.rand(1, 1, 28, 28))\n        n_size = op_feat.data.view(1, -1).size(1)\n        return n_size\n```", "```py\n def forward(self, x):\n        return self.model(x)\n```", "```py\ntrain_dataloader = torch.utils.data.DataLoader(...)\ntest_dataloader = ...\n```", "```py\ndef train(model, device, train_dataloader, optim, epoch):\n    for b_i, (X, y) in enumerate(train_dataloader):\n        …\n```", "```py\ndef test(model, device, test_dataloader):\n    with torch.no_grad():\n        for X, y in test_dataloader:\n            …\n    accuracy = 100\\. * success/ len(test_dataloader.dataset)\n    return accuracy\n```", "```py\ndef objective(trial):\n    model = ConvNet(trial)\n    opt_name = trial.suggest_categorical(\"optimizer\", [\"Adam\", \"Adadelta\", \"RMSprop\", \"SGD\"])\n    lr = trial.suggest_float(\"lr\", 1e-1, 5e-1, log=True)\n    optimizer = getattr(optim,opt_name)(model.parameters(), lr=lr)    \n    for epoch in range(1, 3):\n        train(model, device, train_dataloader, optimizer, epoch)\n        accuracy = test(model, device,test_dataloader)\n        trial.report(accuracy, epoch)\n        if trial.should_prune():\n            raise optuna.exceptions.TrialPruned()\n    return accuracy\n```", "```py\nstudy = optuna.create_study(study_name=\"mastering_pytorch\", direction=\"maximize\")\nstudy.optimize(objective, n_trials=10, timeout=2000)\n```", "```py\npruned_trials = [t for t in study.trials if t.state == optuna.trial.TrialState.PRUNED]complete_trials = [t for t in study.trials if t.state == optuna.trial.TrialState.COMPLETE]\n```", "```py\nprint(\"results: \")\ntrial = study.best_trial\nfor key, value in trial.params.items():\n    print(\"{}: {}\".format(key, value))\n```"]