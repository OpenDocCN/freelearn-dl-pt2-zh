["```py\nimport h2o\nh2o.init()\n```", "```py\n%matplotlib inline\nimport pandas as pd\nfrom matplotlib import cm\nimport matplotlib.pyplot as plt \nimport numpy as np\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 20, 12\nfrom six.moves import range\n```", "```py\ntrain_with_label = h2o.import_file(\"http://h2o-public-test-data.s3.amazonaws.com/bigdata/laptop/mnist/train.csv.gz\")\ntest_with_label = h2o.import_file(\"http://h2o-public-test-data.s3.amazonaws.com/bigdata/laptop/mnist/test.csv.gz\")\n```", "```py\npredictors = list(range(0,784))\ntrain = train_with_label[predictors]\ntest = test_with_label[predictors]\n```", "```py\nfrom h2o.estimators.deeplearning import H2OAutoEncoderEstimator\nmodel = H2OAutoEncoderEstimator(activation=\"Tanh\", hidden=[20], ignore_const_cols=False, epochs=1)\nmodel.train(x=predictors,training_frame=train)\n```", "```py\ntest_rec_error = model.anomaly(test)\n```", "```py\ntest_rec_error.describe()\n```", "```py\ntest_rec_error_df = test_rec_error.as_data_frame()\ntest_rec_error_df['id'] = test_rec_error_df.index\ntest_rec_error_df.plot(kind='scatter', x='id', y='Reconstruction.MSE')\n```", "```py\ntest_with_error = test_with_label.cbind(test_rec_error)\noutlier = test_with_error[test_with_error['Reconstruction.MSE'] > 1.0][0, :]\noutlier_recon = model.predict(outlier[predictors]).cbind(outlier['Reconstruction.MSE'])\n```", "```py\ndef plot_digit(digit, title):\n    df = digit.as_data_frame()\n    pixels = df[predictors].values.reshape((28, 28))\n    error = df['Reconstruction.MSE'][0]\n    fig = plt.figure()\n    plt.title(title)\n    plt.imshow(pixels, cmap='gray')\n    error_caption = 'MSE: {}'.format(round(error,2)) \n    fig.text(.1,.1,error_caption)\n    plt.show()\n```", "```py\nplot_digit(outlier, 'outlier')\nplot_digit(outlier_recon, 'outlier_recon')\n```", "```py\ntest_rec_error.as_data_frame().hist(bins=1000, range=[0.0, 0.07])\n```", "```py\ndigits_of_3 = test_with_error[(test_with_error['C785'] == 3) & (test_with_error['Reconstruction.MSE'] < 0.02)]\n```", "```py\ndef plot_multi_digits(digits, nx, ny, title):\n    df = digits[0:(nx * ny),:].as_data_frame()\n    images = [digit.reshape((28,28)) for digit in df[predictors].values]\n\n    errors = df['Reconstruction.MSE'].values\n    fig = plt.figure()\n    plt.title(title)\n    plt.xticks(np.array([]))\n    plt.yticks(np.array([]))\n    for x in range(nx):\n        for y in range(ny):\n            index = nx*y+x\n            ax = fig.add_subplot(ny, nx, index + 1)\n            ax.imshow(images[index], cmap='gray')\n            plt.xticks(np.array([]))\n            plt.yticks(np.array([]))\n            error_caption = '{} - MSE: {}'.format(index, round(errors[index],2)) \n            ax.text(.1,.1,error_caption)\n    plt.show()\n```", "```py\nplot_multi_digits(digits_of_3, 6, 6, \"good digits of 3\")\nplot_multi_digits(model.predict(digits_of_3[predictors]).cbind(digits_of_3['Reconstruction.MSE']), 6, 6, \"good reconstructed digits of 3\")\n```", "```py\ngood_digit_of_3 = digits_of_3[1, :]\nbottom_left_area = [(y * 28 + x) for y in range(11,28) for x in range (0, 11)]\ngood_digit_of_3[bottom_left_area] = outlier[bottom_left_area]\ngood_digit_of_3['Reconstruction.MSE'] = model.anomaly(good_digit_of_3)\nplot_digit(good_digit_of_3, 'good digit of 3 with copied bottom left from outlier')\n```", "```py\nsorted_test_with_error_df = test_with_error.as_data_frame().sort_values(by='Reconstruction.MSE')\ntest_good = sorted_test_with_error_df[:100]\nplot_multi_digits(test_good, 10, 10, \"good digits\")\n```", "```py\ntest_ugly = sorted_test_with_error_df.tail(100)\nplot_multi_digits(test_ugly, 10, 10, \"ugly digits\")\n```", "```py\necg_data = h2o.import_file(\"http://h2o-public-test-data.s3.amazonaws.com/smalldata/anomaly/ecg_discord_test.csv\")\ntrain_ecg = ecg_data[:20:, :]\ntest_ecg = ecg_data[:23, :]\n```", "```py\ndef plot_stacked_time_series(df, title):\n    stacked = df.stack()\n    stacked = stacked.reset_index()\n    total = [data[0].values for name, data in stacked.groupby('level_0')]\n    pd.DataFrame({idx:pos for idx, pos in enumerate(total)}, index=data['level_1']).plot(title=title)\n    plt.legend(bbox_to_anchor=(1.05, 1))\n```", "```py\nplot_stacked_time_series(ecg_data.as_data_frame(), \"ECG data set\")\n```", "```py\nfrom h2o.estimators.deeplearning import H2OAutoEncoderEstimator\nseed = 1\nmodel = H2OAutoEncoderEstimator(\n    activation=\"Tanh\",\n    hidden=[50,20, 2, 20, 50],\n    epochs=100,\n    seed=seed,\n    reproducible=True)\nmodel.train(\n    x=train_ecg.names,\n    training_frame=train_ecg\n)\n```", "```py\nplot_stacked_time_series(model.predict(ecg\n_data).as_data_frame(), \"Reconstructed test set\")\n\n```", "```py\nrecon_error = model.anomaly(test_ecg)\nplt.figure()\ndf = recon_error.as_data_frame(True)\ndf[\"sample_index\"] = df.index\ndf.plot(kind=\"scatter\", x=\"sample_index\", y=\"Reconstruction.MSE\", title = \"reconstruction error\")\n```", "```py\nfrom matplotlib import cm\ndef plot_bidimensional(model, test, recon_error, layer, title):\n    bidimensional_data = model.deepfeatures(test, layer).cbind(recon_error).as_data_frame()\n    cmap = cm.get_cmap('Spectral')\n    fig, ax = plt.subplots()\n    bidimensional_data.plot(kind='scatter', \n                            x= 'DF.L{}.C1'.format(layer+1), \n                            y= 'DF.L{}.C2'.format(layer+1), \n                            s = 500,\n                            c = 'Reconstruction.MSE',\n                            title = title,\n                            ax = ax,\n                            colormap=cmap)\n    layer_column = 'DF.L{}.C'.format(layer + 1)\n    columns = [layer_column + '1', layer_column + '2']\n    for k, v in bidimensional_data[columns].iterrows():\n        ax.annotate(k, v, size=20, verticalalignment='bottom', horizontalalignment='left')\n    fig.canvas.draw()\n```", "```py\nplot_bidimensional(model, test_ecg, recon_error, 2, \"2D representation of data points seed {}\".format(seed))\n```"]