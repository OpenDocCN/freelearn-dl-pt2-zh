- en: '*Chapter 6*: Content Filtering'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B16854_01_ePub_AM.xhtml#_idTextAnchor016), *Introducing GPT-3
    and the OpenAI API*, we briefly mentioned that a content filtering model is available
    to recognize potentially offensive or harmful language. We also discussed the
    fact that GPT-3 will, at times, generate completions that some may find inappropriate
    or hurtful. In this chapter, you will learn how to implement content filtering
    to prevent users of your application from seeing offensive or potentially harmful
    completions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will be covering in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Preventing inappropriate and offensive results
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding content filtering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the content filtering process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering content with JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering content with Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires that you have access to the **OpenAI API**. You can request
    access by visiting [https://openapi.com](https://openapi.com).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Preventing inappropriate and offensive results
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GPT-3 will, at times, generate text that could be considered inappropriate to
    some users. This could be profanity, text with inappropriate racial, religious,
    or political language, or sexually inappropriate/explicit content, or text that
    is dark or violent in nature. This is not because GPT-3 is trying to be mean or
    hurtful – it's just a language model that generates text based on a statistical
    probability – it has no concept of *mean* or *inappropriate*. But GPT-3 was trained
    using data from the internet, which unfortunately contains plenty of offensive
    content. So, as a result, there will be times that the model generates inappropriate
    content in a completion. Thankfully, as developers, there are things we can do
    to prevent users from seeing potentially inappropriate responses from GPT-3.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to avoid inappropriate content is to use your prompt text to
    steer the model away from generating potentially offensive results. Generally,
    GPT-3 will mirror the structure and content of the prompt. So, you can steer the
    model away from potentially offensive results by telling the model that the completion
    should be friendly, or polite, for example. But you'll need to test regardless.
    Words such as "friendly" can also result in sexual content. So, use the prompt
    to guide the model and refine the wording based on the results you're seeing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, here are two example prompts and associated completions for
    a hypothetical customer service question. In the example, **#$%@!** is used in
    place of the expletives (swear words) that were used in the original prompts and
    completions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prompt:'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Completion:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Example 2:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prompt:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Completion:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The only difference between the two prompts is that the second example contains
    *Polite Response:* at the end rather than just *Response:*. This is enough to
    guide the model to generate a response with more appropriate language. To guide
    the model further, you could also provide one or more samples with polite responses
    to examples of aggressive or impolite customer questions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 两个提示之间的唯一区别是，第二个示例末尾包含*Polite Response:*，而不仅仅是*Response:*。这足以指导模型生成更适当语言的回应。为了进一步指导模型，您还可以提供一个或多个对于攻击性或不礼貌客户问题的样本，以便提供有礼貌回应。
- en: The main point here is that the prompt is the first, and easiest, way to minimize
    inappropriate responses.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是提示是最小化不适当回应的第一种，也是最容易的方法。
- en: Another way to prevent inappropriate completions is to limit what can be returned
    for a completion. For example, if you're classifying or summarizing text, the
    model will be limited in terms of what could be included in the results.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种防止不当完成的方法是限制完成的返回内容。例如，如果你正在对文本进行分类或总结，模型将在结果中包含的内容方面受到限制。
- en: In cases where completions aren't constrained, for example, if you're generating
    a response for a chatbot, you'll want to use content filtering, which we'll discuss
    next. Also, Zero-Shot prompts, without examples, are more likely to result in
    unpredictable completions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在不受约束的完成情况下，例如，如果你为聊天机器人生成回应，你将希望使用内容过滤，这将在接下来进行讨论。此外，零-shot提示，没有示例，很可能会导致不可预测的完成。
- en: Understanding content filtering
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解内容过滤
- en: Content filtering is about blocking or hiding content that may be deemed offensive,
    inappropriate, or even dangerous. In our case, we're talking about content that
    GPT-3 generates that we don't want users of our application to see.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 内容过滤是指阻止或隐藏可能被视为冒犯、不当或甚至危险的内容。在我们的情况下，我们谈论的是GPT-3生成的内容，我们不希望我们的应用用户看到的内容。
- en: To filter potentially offensive or unsafe text, we'll need to write a little
    bit of code to evaluate text that GPT-3 generates and classify it as safe, sensitive,
    or unsafe. The cool part is that we can use GPT-3 to do the classifications. So,
    it's kind of like self-policing but with a bit of help from our code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了过滤潜在的冒犯或不安全的文本，我们需要编写一小段代码来评估GPT-3生成的文本，并对其进行安全、敏感或不安全的分类。Cool的地方在于我们可以使用GPT-3来进行分类。因此，这有点像自我管理，但在一定程度上依靠我们的代码进行辅助。
- en: 'At a high level, here is how we make it work:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次上看，这是我们如何使其工作的方式：
- en: GPT-3 generates a completion to a prompt.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPT-3对提示生成一个完成。
- en: The completion text is submitted back to a GPT-3 filter engine.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成的文本被提交回GPT-3过滤引擎。
- en: The filter engine returns a classification (safe, sensitive, unsafe).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤引擎返回一个分类（安全、敏感、不安全）。
- en: The original completion text is blocked or sent back to the user based on the
    classification.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据分类，原始完成文本被屏蔽或发送回用户。
- en: Optionally, if the completion text is sensitive, or unsafe, a new safe completion
    could be generated and sent without the user knowing that some content was blocked.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，如果完成文本是敏感的或不安全的，可以生成一个新的安全完成并发送，而用户并不知道某些内容被屏蔽了。
- en: Content filtering is done using the completions endpoint. However, a specialized
    content filter engine is used along with some specific settings, and a specially
    formatted prompt.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 内容过滤是使用完成的端点进行的。然而，需要使用专门的内容过滤引擎以及一些特定设置和特殊格式的提示。
- en: As this is being written, the available content filtering engine is **content-filter-alpha-c4**.
    So, the URL we'd use for the completions endpoint with that engine would be [https://api.openai.com/v1/engines/content-filter-alpha-c4/completions](https://api.openai.com/v1/engines/content-filter-alpha-c4/completions).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，可用的内容过滤引擎为**content-filter-alpha-c4**。因此，我们将在该引擎的URL中使用用于完成的端点，如[https://api.openai.com/v1/engines/content-filter-alpha-c4/completions](https://api.openai.com/v1/engines/content-filter-alpha-c4/completions)。
- en: 'Again, there are some specific requirements for parameters that need to be
    included with the API request. Specifically, we need to include the following
    parameters and associated values:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一遍，需要在API请求中包含一些特定参数的具体要求。具体来说，我们需要包括以下参数和相关数值：
- en: '`1`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`0.0`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.0`'
- en: '`0`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`'
- en: Finally, the prompt for content filtering must be formatted in a specific way.
    The prompt format is `"<|endoftext|>[prompt]\n--\nLabel:"`. The `[prompt]` part
    would just be replaced with the text we want the content filter to evaluate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，内容过滤的提示必须以特定方式格式化。提示格式为`"<|endoftext|>[prompt]\n--\nLabel:"`。`[prompt]`部分将被替换为我们希望内容过滤器评估的文本。
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Content filtering is in beta at the time of publishing. There is a good chance
    that the engine ID may have changed by the time you're reading this. For that
    reason, be sure to review the OpenAI content filter documents located at [https://beta.openai.com/docs/engines/content-filter](https://beta.openai.com/docs/engines/content-filter).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is an example of the JSON we''d post to the completions endpoint.
    In this example, the text we''re evaluating is *Once upon a time*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s pretty safe to assume that *Once upon a time* would be considered safe.
    So, if that was the text we were applying the filter to, we could expect a response
    that would look something like the following example, showing the text is 0 –
    safe:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that in the JSON response object, there is an element named **choices**.
    This element contains a JSON array of objects. Each object contains a text property
    that will represent the content filter classification for one completion. The
    value will always be one of the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '**0 – Safe**: Nothing about the text seems potentially offensive or unsafe.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1 – Sensitive**: Sensitive topics may include text with political, religious,
    racial, or nationality-related content.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2 – Unsafe**: The text contains language that some would consider mean, hurtful,
    explicit, offensive, profane, prejudiced, or hateful, or language that most would
    consider **Not Safe for Work** (**NSFW**), or language that might portray certain
    groups/people in a harmful manner.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An array is sent back for the choices element because it''s possible to send
    multiple prompts with one request. For example, if you wanted to see whether any
    individual words in a sentence were unsafe, you might split the sentence into
    an array of words and send each word as a prompt. Here is an example of a request
    that sends *Oh hi* as two prompts – one word for each:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Given the previous example with an array of prompts, you''ll see a response
    that looks something like the following. Note now that there are multiple objects
    in the choices array – one for each word/prompt:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The choices array has a zero-based index value that corresponds to the index
    of the item in the prompt array that was passed in, meaning that the choices object
    for the first prompt/word (which was "*Oh"* in our example) has an index value
    of 0\. In this example, we just sent two words (*"Oh"* and *"hi"*), and both got
    classified as a 0 (safe). However, if you were to change one of the words to your
    favorite (or least favorite) swear word, you'd see the classification change to
    2 (unsafe) for the item with the index that corresponds to the word you changed
    (assuming you use a swear word that most English-speaking people would find offensive).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Something else to keep in mind is that the filter engine is not 100% accurate
    and will err on the side of caution. So, you'll likely see false positives – words
    being classified as sensitive or unsafe that are actually safe. This is something
    you might have already seen in the Playground. Even topics that mention politics
    or religion, for example, usually get flagged. It's always better to be safe than
    sorry, but you'll want to consider how this might potentially impact your application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要牢记的事情是，过滤引擎并不是100%准确，而是更倾向于谨慎。因此，您可能会看到误报 - 一些实际上是安全的单词被标记为敏感或不安全的情况。这可能是您在Playground中已经看到的情况。甚至提及政治或宗教等话题通常会被标记。小心总比后悔要好，但您需要考虑这可能如何潜在影响到您的应用程序。
- en: 'So, to recap, you can use the OpenAI API completions endpoint to classify potentially
    sensitive or unsafe text. You just need to do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简要总结一下，您可以使用OpenAI API完成端点来对潜在的敏感或不安全文本进行分类。您只需要执行以下操作：
- en: Use a content filter engine.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内容过滤引擎。
- en: Set `max_tokens` to `1`, `temperature` to `0.0`, and `top_p` to `0`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`max_tokens`设置为`1`，`temperature`设置为`0.0`，`top_p`设置为`0`。
- en: Format your prompt as `"<|endoftext|>your text here\n--\nLabel:"`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的提示格式化为`"<|endoftext|>your text here\n--\nLabel:"`。
- en: Alright, let's use Postman to get familiar with how content filtering works.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们使用Postman熟悉一下内容过滤的工作原理。
- en: Testing the content filtering process
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试内容过滤流程
- en: 'Later in this chapter, we''re going to create a simple content filter in code.
    But before we do, let''s use Postman to test the general content filtering approach:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将会在代码中创建一个简单的内容过滤。但在此之前，让我们使用Postman测试一下通用的内容过滤方法：
- en: Log in to [Postman.com](http://Postman.com).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录[Postman.com](http://Postman.com)。
- en: Open the Exploring GPT-3 workspace that we created in [*Chapter 4*](B16854_04_ePub_AM.xhtml#_idTextAnchor074),
    *Working with the OpenAI API*.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在[*第4章*](B16854_04_ePub_AM.xhtml#_idTextAnchor074)中创建的Exploring GPT-3工作空间，*使用OpenAI
    API*。
- en: Create a new Postman collection named **Chapter 06**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**第06章**的新Postman集合。
- en: Create a new request named **Content Filter - Example 1**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**内容过滤 - 示例1**的新请求。
- en: Set the request type to **POST**, and the request URL to [https://api.openai.com/v1/engines/content-filter-alpha-c4/completions](https://api.openai.com/v1/engines/content-filter-alpha-c4/completions),
    as shown in the following screenshot:![Figure 6.1 – Setting the filter endpoint
    in Postman
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求类型设置为**POST**，并将请求URL设置为[https://api.openai.com/v1/engines/content-filter-alpha-c4/completions](https://api.openai.com/v1/engines/content-filter-alpha-c4/completions)，如下面的屏幕截图所示:![图6.1
    - 在Postman中设置过滤端点
- en: '](img/B16854_06_001.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_001.jpg)'
- en: Figure 6.1 – Setting the filter endpoint in Postman
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.1 - 在Postman中设置过滤端点
- en: Set the request body to **raw** and the body type to **JSON**, as in the following
    screenshot:![Figure 6.2 – Filter parameters in Postman
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求主体设置为**原始**，并将主体类型设置为**JSON**，如以下屏幕截图所示:![图6.2 - Postman中的过滤参数
- en: '](img/B16854_06_002.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_002.jpg)'
- en: Figure 6.2 – Filter parameters in Postman
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.2 - Postman中的过滤参数
- en: 'Add the following JSON object to the request body:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下JSON对象添加到请求主体中：
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Click the send button and review the JSON response. The response will look
    something like the following screenshot:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '单击发送按钮并查看JSON响应。响应将类似于以下屏幕截图:'
- en: '![Figure 6.3 – Postman filter results'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 - Postman过滤结果'
- en: '](img/B16854_06_003.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_06_003.jpg)'
- en: Figure 6.3 – Postman filter results
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 - Postman过滤结果
- en: In the response, you should notice that the text value is **1** (sensitive)
    for the choices item with an index of **0**. As you might guess, that's likely
    because the text *Are you religious*? could be considered a sensitive topic.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应中，您会注意到索引为**0**的选择项的文本值为**1**（敏感）。正如您所猜的那样，这很可能是因为文本*Are you religious*?
    可能被视为敏感话题。
- en: Before moving on, try changing the prompt text to something that you suspect
    might be considered sensitive or unsafe and see how it gets classified. After
    getting familiar with the content filtering process, move on to the next section
    to try it out in JavaScript.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，尝试将提示文字更改为您认为可能被视为敏感或不安全的内容，并查看其分类情况。熟悉内容过滤流程后，继续下一节，在JavaScript中尝试应用。
- en: Filtering content with JavaScript
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript过滤内容
- en: 'In this section, we''ll look at a simple content filtering code example using
    JavaScript. We could write all the code ourselves, but there is a cool feature
    in Postman that generates code snippets for the requests we create. So, let''s
    give that a try:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: To see Postman-generated code snippets, click on the **code** button on the
    right-side menu. The arrow in the following screenshot is pointing to the **</>**
    icon, which is the button to click:![Figure 6.4 – Code button to open the code
    pane
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16854_06_004.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.4 – Code button to open the code pane
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After clicking the code button, a code snippet pane will open in Postman. Change
    the code snippet type to **NodeJs – Axios** by selecting it from the drop-down
    list. Then, click the copy button shown in the following screenshot. This will
    copy the code snippet to your clipboard:![Figure 6.5 – Postman code snippet for
    Node.js – Axios
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16854_06_005.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.5 – Postman code snippet for Node.js – Axios
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After copying the code snippet to the clipboard, perform the following steps:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Log in to [replit.com](http://replit.com) and open your `chapter06`.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c) Create a file in the `chapter06` folder named `filter.js`.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d) Paste the code snippet from Postman into the `filter.js` file.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The resulting code should look like the following screenshot. However, there
    is one small change we need to make before we can run the file:![Figure 6.6 –
    Code copied from the Postman snippet to the replit.com file
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16854_06_006.jpg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, after updating the authorization line, the final code should be the following:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows the preceding code in [replit.com](http://replit.com):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Postman code snippet modified for replit.com'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_06_007.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Postman code snippet modified for replit.com
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the code is very similar to the code we wrote in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098),
    *Using the OpenAI API in Code*, when we discussed calling the completions endpoint.
    We just need to edit the `run` command in the `.replit` file to run the code in
    our `chapter06/filter.js` file. Then we can carry out a test:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'So, update the `.replit` file to the following:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After updating the `.replit` file, click the green **Run** button and you should
    see results in the console window that are similar to the following screenshot:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Results from running chapter06/filter.js'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_06_008.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Results from running chapter06/filter.js
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example that classifies all of the text in a single prompt.
    Let's take a look at another example that classifies each word in a string and
    classifies each word as safe, sensitive, or unsafe.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Flagging unsafe words with Node.js/JavaScript
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this example, we''ll start by creating a new file named `chapter06/flag.js`
    and copying in the code from `chapter06/filter.js` as a starting point. From there,
    we''re going to modify the code in `chapter06/flag.js` to list each word with
    a classification value (0 = safe, 1 = sensitive, 2 = unsafe). To begin, perform
    the following steps to create our starting point:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Log in to [replit.com](http://replit.com) and open your **exploring-gpt3-node**
    repl.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file in the `chapter06` folder named `flag.js`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste the entire contents of `chapter06/filter.js` into `chapter06/flag.js`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `.replit` file to run `chapter06/flag.js` by using the following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ll start by adding a variable to hold the text we want to filter. We''ll
    add this code just under the first line. So, the first two lines will be as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we''ll add a variable to hold an array of prompts and set the initial
    value to an empty array. This will get populated with a prompt for each word from
    our text input:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we''ll split our `textInput` into an array of words and populate the `prompts`
    array with a prompt for each word. Since we''re sending the prompts to the filter
    engine, we''ll also need to format each prompt item properly. So, we''ll add the
    following code after our `prompts` variable. This code splits the text input into
    individual words, loops through each word to create a prompt item, and then adds
    the prompt item to the `prompts` array:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we will update the data variable that was created by Postman. We''ll use
    our `prompts` array as the prompt value rather than the hardcoded value from Postman.
    So, we''ll change the data variable to the following:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we''ll modify the output with code that loops through the word array
    and classifies each word using the results from the filter. To do that, replace
    the line that contains `console.log(JSON.stringify(response.data));` with the
    following code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After making that last code edit, we can run the code again and this time we''ll
    see a response like the following:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Content filter results for each word in a text input'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_06_009.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Content filter results for each word in a text input
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice now that the word (`religion`) has a text value of *1* (sensitive).
    If you change the `textInput` value with text that contains the more offensive
    word, you can run the code again to see how each word is classified. In a real-world
    implementation, you might replace or redact words that are sensitive or unsafe,
    which could now easily be done with the results from the API using a similar approach.
    We'll look at doing that in [*Chapter 7*](B16854_07_ePub_AM.xhtml#_idTextAnchor136),
    *Generating and Transforming Text*, but for now, let's look at content filtering
    with Python.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Filtering content with Python
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s see how to implement content filtering with Python. Unless you skipped
    over *Filtering content with JavaScript*, you can probably guess how we''re going
    to get started with a Python content filtering example – we''re going to use a
    code snippet generated by Postman:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用 Python 实现内容过滤。除非你跳过了“*使用 JavaScript 过滤内容*”，否则你可能能够猜到我们要如何开始使用 Python
    实现内容过滤的示例——我们会使用由 Postman 生成的代码片段：
- en: So, start by opening the code snippet pane in Postman. Then, click the code
    button in the right-hand menu. The code button is where the arrow in the following
    screenshot is pointing:![Figure 6.10 – Code button to open the code pane
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，首先需要在 Postman 中打开代码片段窗格。然后，点击右侧菜单中的代码按钮。箭头指向的即为代码按钮，如下面的截图所示：![图 6.10 – 打开代码窗格的代码按钮
- en: '](img/B16854_06_010.jpg)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_010.jpg)'
- en: Figure 6.10 – Code button to open the code pane
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.10 – 打开代码窗格的代码按钮
- en: After clicking the code button, the code snippet pane will open. Change the
    code snippet type to **Python – Requests** by selecting it from the drop-down
    list. Then, click the copy button shown in the following screenshot. This will
    copy the code snippet to your clipboard:![Figure 6.11 – Postman code snippet for
    Python – requests
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击代码按钮后，代码片段窗格会打开。更改代码片段类型为 **Python – Requests**，方法是从下拉列表中选择它，然后单击下面截图中所示的复制按钮。这将将代码片段复制到你的剪贴板：![图
    6.11 – 用于 Python – requests 的 Postman 代码片段
- en: '](img/B16854_06_011.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_011.jpg)'
- en: Figure 6.11 – Postman code snippet for Python – requests
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.11 – 用于 Python – requests 的 Postman 代码片段
- en: 'After copying the code snippet to the clipboard, perform the following steps:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码片段复制到剪贴板后，执行以下步骤：
- en: a) Log in to [replit.com](http://replit.com) and open your `chapter06`.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 登录 [replit.com](http://replit.com)，并打开你的 `chapter06`。
- en: c) Create a file in the `chapter06` folder named `filter.py`.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 创建一个在 `chapter06` 文件夹中命名为 `filter.py` 的文件。
- en: d) Paste the snippet from Postman into the `filter.py` file.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 将 Postman 代码片段粘贴到 `filter.py` 文件中。
- en: The resulting code should look like the following screenshot. But you will see
    that your API key is hardcoded – it is blurred in the screenshot. The hardcoded
    API key is the first thing we will change:![Figure 6.12 – Code copied from the
    Postman snippet to the repl.it file
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终代码应该如下截图所示。但是你会发现你的 API Key 是硬编码的 —— 它在截图中被模糊处理了。硬编码的 API Key 是我们要更改的第一项内容：![图
    6.12 – 从 Postman 代码段复制到 repl.it 文件
- en: '](img/B16854_06_012.jpg)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_012.jpg)'
- en: Figure 6.12 – Code copied from the Postman snippet to the repl.it file
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.12 – 从 Postman 代码段复制到 repl.it 文件
- en: 'To remove the hardcoded API key from our code file, we will import the Python
    `os` library first so we can read the `OPENAI_API_KEY` environment variable that
    we set in the `.env` file in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098),
    *Using the OpenAI API in Code*. So, we''ll add the following code to the first
    line of our `filter.py` file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从我们的代码文件中删除硬编码的 API Key，在 `filter.py` 文件的第一行添加以下代码，这样我们就可以读取在[*使用 OpenAI API
    进行代码编写*](B16854_05_ePub_AM.xhtml#_idTextAnchor098)中设置的 `.env` 文件中的 `OPENAI_API_KEY`
    环境变量了：
- en: '[PRE18]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After importing the Python `os` library, we can get the API key value for the
    authorization header from our environment variable. In the preceding *Figure 6.12*,
    you would be editing *line 7* to the following:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 Python 的 `os` 库后，我们可以从环境变量获取授权头的 API Key 值。在先前的 *图 6.12* 中，你需要将 *第 7 行* 编辑为以下内容：
- en: '[PRE19]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After updating the authorization line, the final code should be the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新授权行后，最终代码应如下所示：
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The following screenshot shows the preceding code in [replit.com](http://replit.com):![Figure
    6.13 – Postman Python code snippet modified for replit.com
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的截图展示了前面章节中修改的 Postman Python 代码片段在 [replit.com](http://replit.com) 中的效果：![图
    6.13 – 修改后的用于 repl.git.com 的 Postman Python 代码片段
- en: '](img/B16854_06_013.jpg)'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_013.jpg)'
- en: Figure 6.13 – Postman Python code snippet modified for replit.com
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.13 – 修改后的用于 repl.git.com 的 Postman Python 代码片段
- en: 'At this point, the code is very similar to the code we wrote in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098),
    *Using the OpenAI API in Code*, when we discussed calling the completions endpoint
    using Python. We just need to edit the `run` command in the `.replit` file to
    run the code in our `chapter06/filter.py` file. Then we can carry out a test.
    So, update the `.replit` file to the following:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，代码与我们在前一章“[*使用 OpenAI API 进行代码编写*](B16854_05_ePub_AM.xhtml#_idTextAnchor098)”中编写的代码非常相似，那时我们讨论了使用
    Python 调用完成端点。我们只需编辑 `.replit` 文件中的 `run` 命令，以运行我们的 `chapter06/filter.py` 文件中的代码。然后我们可以进行测试。因此，请将
    `.replit` 文件更新为以下内容：
- en: '[PRE21]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After updating the `.replit` file, click the green **Run** button and you should
    see results in the console window that are similar to the following screenshot:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Results from running chapter06/filter.py'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_06_014.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – Results from running chapter06/filter.py
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example that classifies all of the text in a single prompt.
    Let's now take a look at another example that classifies each word in a string
    and replaces unsafe words.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Flagging unsafe words with Python
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this example, we''ll start by creating a new file named `chapter06/flag.py`
    and copying in the code from `chapter06/filter.py` as a starting point. From there,
    we''re going to modify the code in `chapter06/flag.py` to list each word with
    a classification value (0 = safe, 1 = sensitive, 2 = unsafe). To begin, perform
    the following steps to create our starting point:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Log in to replit.com and open `your exploring-gpt3-python` repl.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file in the `chapter06` folder named `flag.py`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste the entire contents of `chapter06/filter.py` into `chapter06/flag.py`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `.replit` file to run `chapter06/flag.py` using the following command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `chapter06/flag.py` file, we''ll add a variable to hold the text we
    want to filter. We''ll add the following code just under the third line (after
    the last line that starts with `import`):'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we''ll add a variable to hold an array of prompts and set the initial
    value to an empty array. This will get populated with a prompt for each word from
    our text input:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we''ll split our `textInput` into an array of words and populate the `prompts`
    array with a prompt for each word. Since we''re sending the prompts to the filter
    engine, we''ll also need to format each prompt item properly. So, we''ll add the
    following code after our `prompts` variable. This code splits the text input into
    individual words, loops through each word to create a prompt item, and adds the
    prompt item to the `prompts` array:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we will update the payload variable that was created by Postman to a Python
    object rather than a string. This makes it a little more readable and easier to
    include our `prompts` array. So, replace the payload variable with the following
    code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we''ll replace the last line of code, `print(response.text)`, with
    the following code that loops through the results and adds a classification (0
    = safe, 1 = sensitive, 2 = unsafe) for each word:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After making that final code edit, we can click the **Run** button and this
    time we''ll see a response like the following:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Content filter results for each word in a text input using
    Python'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_06_015.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – Content filter results for each word in a text input using Python
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice in the console that the word (`religion`) has a text value of
    **1** (sensitive). In a real-world application, you'd use a similar approach to
    redact or replace unsafe and sensitive words. But keep in mind that no content
    filtering process is perfect. Language is constantly evolving, and the context
    of words can change meanings, which might cause the content filter to miss or
    falsely flag content. So, it's important to consider this in the design of your
    filtering approach.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how GPT-3 might, at times, generate inappropriate
    content. We also discussed what we can do to prevent and detect inappropriate
    content. You learned how prompts can be used to prevent the likelihood that inappropriate
    content is generated, and how content filtering can be used to classify content
    as safe, sensitive, or unsafe.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: We reviewed how the completions endpoint can be used for content filtering and
    how to implement content filtering using both JavaScript and Python.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take what we learned in this chapter, along with
    what we learned in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098), *Calling
    the OpenAI API in Code*, and use that knowledge to build a GPT-3 powered chatbot.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
