- en: '*Chapter 6*: Content Filtering'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第六章*：内容过滤'
- en: In [*Chapter 1*](B16854_01_ePub_AM.xhtml#_idTextAnchor016), *Introducing GPT-3
    and the OpenAI API*, we briefly mentioned that a content filtering model is available
    to recognize potentially offensive or harmful language. We also discussed the
    fact that GPT-3 will, at times, generate completions that some may find inappropriate
    or hurtful. In this chapter, you will learn how to implement content filtering
    to prevent users of your application from seeing offensive or potentially harmful
    completions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B16854_01_ePub_AM.xhtml#_idTextAnchor016)中，*介绍 GPT-3 和 OpenAI API*，我们简要提到了一个内容过滤模型，用于识别潜在的冒犯或有害语言。我们还讨论了
    GPT-3 有时会生成一些可能被一些人认为不当或伤害的完成。在本章中，您将学习如何实现内容过滤，以防止您的应用程序用户看到冒犯性或可能有害的完成。
- en: 'The topics we will be covering in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Preventing inappropriate and offensive results
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预防不当和冒犯性结果
- en: Understanding content filtering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解内容过滤
- en: Testing the content filtering process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试内容过滤过程
- en: Filtering content with JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JavaScript 进行内容过滤
- en: Filtering content with Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 进行内容过滤
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires that you have access to the **OpenAI API**. You can request
    access by visiting [https://openapi.com](https://openapi.com).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求您能够访问**OpenAI API**。您可以通过访问[https://openapi.com](https://openapi.com)来请求访问权限。
- en: Preventing inappropriate and offensive results
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防不当和冒犯性结果
- en: GPT-3 will, at times, generate text that could be considered inappropriate to
    some users. This could be profanity, text with inappropriate racial, religious,
    or political language, or sexually inappropriate/explicit content, or text that
    is dark or violent in nature. This is not because GPT-3 is trying to be mean or
    hurtful – it's just a language model that generates text based on a statistical
    probability – it has no concept of *mean* or *inappropriate*. But GPT-3 was trained
    using data from the internet, which unfortunately contains plenty of offensive
    content. So, as a result, there will be times that the model generates inappropriate
    content in a completion. Thankfully, as developers, there are things we can do
    to prevent users from seeing potentially inappropriate responses from GPT-3.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，GPT-3 会生成一些被一些用户认为不当的文本。这可能是粗话、含有不当的种族、宗教或政治用语，或者性不当/露骨的内容，或者性质黑暗或暴力的文本。这并不是因为
    GPT-3 试图恶意或伤害别人——它只是一个根据统计概率生成文本的语言模型——它没有*恶意*或*不当*的概念。但 GPT-3 是使用互联网数据进行训练的，而互联网上不幸存在大量冒犯性内容。因此，模型有时会生成不适当的内容。值得庆幸的是，作为开发者，我们可以采取措施防止用户看到
    GPT-3 可能生成的不适当响应。
- en: The simplest way to avoid inappropriate content is to use your prompt text to
    steer the model away from generating potentially offensive results. Generally,
    GPT-3 will mirror the structure and content of the prompt. So, you can steer the
    model away from potentially offensive results by telling the model that the completion
    should be friendly, or polite, for example. But you'll need to test regardless.
    Words such as "friendly" can also result in sexual content. So, use the prompt
    to guide the model and refine the wording based on the results you're seeing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 避免不适当内容的最简单方法是利用您的提示文本来引导模型避免生成可能不适当的结果。一般来说，GPT-3 会模仿提示的结构和内容。因此，您可以通过告诉模型完成应该友好或礼貌，来引导模型远离可能的不适当结果，例如。但是无论如何，您都需要测试。例如，“友好”这样的词也可能导致性内容。因此，请使用提示来引导模型，并根据您看到的结果来精确控制措辞。
- en: 'To illustrate, here are two example prompts and associated completions for
    a hypothetical customer service question. In the example, **#$%@!** is used in
    place of the expletives (swear words) that were used in the original prompts and
    completions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，这里有两个假设客服问题的示例提示和相关完成。在示例中，**#$%@!** 用于代替原始提示和完成中使用的脏话（诅咒词）。
- en: 'Example 1:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '示例 1:'
- en: 'Prompt:'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '提示:'
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Completion:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '完成:'
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Example 2:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '示例 2:'
- en: 'Prompt:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '提示:'
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Completion:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '完成:'
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The only difference between the two prompts is that the second example contains
    *Polite Response:* at the end rather than just *Response:*. This is enough to
    guide the model to generate a response with more appropriate language. To guide
    the model further, you could also provide one or more samples with polite responses
    to examples of aggressive or impolite customer questions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 两个提示之间的唯一区别是，第二个示例末尾包含*Polite Response:*，而不仅仅是*Response:*。这足以指导模型生成更适当语言的回应。为了进一步指导模型，您还可以提供一个或多个对于攻击性或不礼貌客户问题的样本，以便提供有礼貌回应。
- en: The main point here is that the prompt is the first, and easiest, way to minimize
    inappropriate responses.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是提示是最小化不适当回应的第一种，也是最容易的方法。
- en: Another way to prevent inappropriate completions is to limit what can be returned
    for a completion. For example, if you're classifying or summarizing text, the
    model will be limited in terms of what could be included in the results.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种防止不当完成的方法是限制完成的返回内容。例如，如果你正在对文本进行分类或总结，模型将在结果中包含的内容方面受到限制。
- en: In cases where completions aren't constrained, for example, if you're generating
    a response for a chatbot, you'll want to use content filtering, which we'll discuss
    next. Also, Zero-Shot prompts, without examples, are more likely to result in
    unpredictable completions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在不受约束的完成情况下，例如，如果你为聊天机器人生成回应，你将希望使用内容过滤，这将在接下来进行讨论。此外，零-shot提示，没有示例，很可能会导致不可预测的完成。
- en: Understanding content filtering
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解内容过滤
- en: Content filtering is about blocking or hiding content that may be deemed offensive,
    inappropriate, or even dangerous. In our case, we're talking about content that
    GPT-3 generates that we don't want users of our application to see.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 内容过滤是指阻止或隐藏可能被视为冒犯、不当或甚至危险的内容。在我们的情况下，我们谈论的是GPT-3生成的内容，我们不希望我们的应用用户看到的内容。
- en: To filter potentially offensive or unsafe text, we'll need to write a little
    bit of code to evaluate text that GPT-3 generates and classify it as safe, sensitive,
    or unsafe. The cool part is that we can use GPT-3 to do the classifications. So,
    it's kind of like self-policing but with a bit of help from our code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了过滤潜在的冒犯或不安全的文本，我们需要编写一小段代码来评估GPT-3生成的文本，并对其进行安全、敏感或不安全的分类。Cool的地方在于我们可以使用GPT-3来进行分类。因此，这有点像自我管理，但在一定程度上依靠我们的代码进行辅助。
- en: 'At a high level, here is how we make it work:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次上看，这是我们如何使其工作的方式：
- en: GPT-3 generates a completion to a prompt.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPT-3对提示生成一个完成。
- en: The completion text is submitted back to a GPT-3 filter engine.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成的文本被提交回GPT-3过滤引擎。
- en: The filter engine returns a classification (safe, sensitive, unsafe).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤引擎返回一个分类（安全、敏感、不安全）。
- en: The original completion text is blocked or sent back to the user based on the
    classification.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据分类，原始完成文本被屏蔽或发送回用户。
- en: Optionally, if the completion text is sensitive, or unsafe, a new safe completion
    could be generated and sent without the user knowing that some content was blocked.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，如果完成文本是敏感的或不安全的，可以生成一个新的安全完成并发送，而用户并不知道某些内容被屏蔽了。
- en: Content filtering is done using the completions endpoint. However, a specialized
    content filter engine is used along with some specific settings, and a specially
    formatted prompt.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 内容过滤是使用完成的端点进行的。然而，需要使用专门的内容过滤引擎以及一些特定设置和特殊格式的提示。
- en: As this is being written, the available content filtering engine is **content-filter-alpha-c4**.
    So, the URL we'd use for the completions endpoint with that engine would be [https://api.openai.com/v1/engines/content-filter-alpha-c4/completions](https://api.openai.com/v1/engines/content-filter-alpha-c4/completions).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，可用的内容过滤引擎为**content-filter-alpha-c4**。因此，我们将在该引擎的URL中使用用于完成的端点，如[https://api.openai.com/v1/engines/content-filter-alpha-c4/completions](https://api.openai.com/v1/engines/content-filter-alpha-c4/completions)。
- en: 'Again, there are some specific requirements for parameters that need to be
    included with the API request. Specifically, we need to include the following
    parameters and associated values:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一遍，需要在API请求中包含一些特定参数的具体要求。具体来说，我们需要包括以下参数和相关数值：
- en: '`1`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`0.0`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.0`'
- en: '`0`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`'
- en: Finally, the prompt for content filtering must be formatted in a specific way.
    The prompt format is `"<|endoftext|>[prompt]\n--\nLabel:"`. The `[prompt]` part
    would just be replaced with the text we want the content filter to evaluate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，内容过滤的提示必须以特定方式格式化。提示格式为`"<|endoftext|>[prompt]\n--\nLabel:"`。`[prompt]`部分将被替换为我们希望内容过滤器评估的文本。
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Content filtering is in beta at the time of publishing. There is a good chance
    that the engine ID may have changed by the time you're reading this. For that
    reason, be sure to review the OpenAI content filter documents located at [https://beta.openai.com/docs/engines/content-filter](https://beta.openai.com/docs/engines/content-filter).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布时，内容过滤处于 beta 阶段。很有可能引擎 ID 在您阅读此文时已更改。因此，请务必查看位于 [https://beta.openai.com/docs/engines/content-filter](https://beta.openai.com/docs/engines/content-filter)
    的 OpenAI 内容过滤器文档。
- en: 'So, here is an example of the JSON we''d post to the completions endpoint.
    In this example, the text we''re evaluating is *Once upon a time*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们将发布到完成端点的 JSON 的一个示例。在此示例中，我们正在评估的文本是 *从前有座山*：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s pretty safe to assume that *Once upon a time* would be considered safe.
    So, if that was the text we were applying the filter to, we could expect a response
    that would look something like the following example, showing the text is 0 –
    safe:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以相当肯定地假设 *从前有座山* 会被视为安全的。因此，如果那是我们要应用过滤器的文本，我们可以期望得到类似以下示例的响应，显示文本是 0 - 安全的：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that in the JSON response object, there is an element named **choices**.
    This element contains a JSON array of objects. Each object contains a text property
    that will represent the content filter classification for one completion. The
    value will always be one of the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 JSON 响应对象中，有一个名为**choices**的元素。该元素包含一个对象的 JSON 数组。每个对象都包含一个文本属性，该属性将表示一个完成的内容过滤分类。其值始终是以下之一：
- en: '**0 – Safe**: Nothing about the text seems potentially offensive or unsafe.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0 – 安全**：文本中似乎没有任何可能引起冒犯或不安全的地方。'
- en: '**1 – Sensitive**: Sensitive topics may include text with political, religious,
    racial, or nationality-related content.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1 – 敏感**：敏感话题可能包括具有政治、宗教、种族或国籍相关内容的文本。'
- en: '**2 – Unsafe**: The text contains language that some would consider mean, hurtful,
    explicit, offensive, profane, prejudiced, or hateful, or language that most would
    consider **Not Safe for Work** (**NSFW**), or language that might portray certain
    groups/people in a harmful manner.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2 – 不安全**：文本包含一些人认为是刻薄的、伤人的、明确的、冒犯的、亵渎的、偏见的、仇恨的语言，或者大多数人认为**不适合工作**（**NSFW**）的语言，或者可能以有害方式描绘某些群体/人的语言。'
- en: 'An array is sent back for the choices element because it''s possible to send
    multiple prompts with one request. For example, if you wanted to see whether any
    individual words in a sentence were unsafe, you might split the sentence into
    an array of words and send each word as a prompt. Here is an example of a request
    that sends *Oh hi* as two prompts – one word for each:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数组被发送回 choices 元素，因为可能一次发送多个提示。例如，如果您想要查看句子中的任何单词是否不安全，您可能会将句子拆分为一个单词的数组，并将每个单词作为提示发送。以下是将
    *Oh hi* 作为两个提示发送 - 每个单词一个的请求的示例：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Given the previous example with an array of prompts, you''ll see a response
    that looks something like the following. Note now that there are multiple objects
    in the choices array – one for each word/prompt:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于前面的示例，使用提示数组，您将看到类似以下的响应。现在请注意，choices 数组中有多个对象 - 每个单词/提示一个：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The choices array has a zero-based index value that corresponds to the index
    of the item in the prompt array that was passed in, meaning that the choices object
    for the first prompt/word (which was "*Oh"* in our example) has an index value
    of 0\. In this example, we just sent two words (*"Oh"* and *"hi"*), and both got
    classified as a 0 (safe). However, if you were to change one of the words to your
    favorite (or least favorite) swear word, you'd see the classification change to
    2 (unsafe) for the item with the index that corresponds to the word you changed
    (assuming you use a swear word that most English-speaking people would find offensive).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: choices 数组具有从零开始的索引值，该值对应于传入的提示数组中项目的索引，这意味着第一个提示/单词（在我们的示例中是“*Oh*”）的 choices
    对象具有索引值 0。在此示例中，我们只发送了两个单词（“*Oh*”和“*hi*”），并且两者都被分类为 0（安全）。但是，如果您将其中一个单词更改为您喜欢的（或最不喜欢的）脏话，您会看到分类将更改为
    2（不安全），其索引对应于您更改的单词（假设您使用的脏话大多数英语为母语的人会觉得冒犯）。
- en: Something else to keep in mind is that the filter engine is not 100% accurate
    and will err on the side of caution. So, you'll likely see false positives – words
    being classified as sensitive or unsafe that are actually safe. This is something
    you might have already seen in the Playground. Even topics that mention politics
    or religion, for example, usually get flagged. It's always better to be safe than
    sorry, but you'll want to consider how this might potentially impact your application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要牢记的事情是，过滤引擎并不是100%准确，而是更倾向于谨慎。因此，您可能会看到误报 - 一些实际上是安全的单词被标记为敏感或不安全的情况。这可能是您在Playground中已经看到的情况。甚至提及政治或宗教等话题通常会被标记。小心总比后悔要好，但您需要考虑这可能如何潜在影响到您的应用程序。
- en: 'So, to recap, you can use the OpenAI API completions endpoint to classify potentially
    sensitive or unsafe text. You just need to do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简要总结一下，您可以使用OpenAI API完成端点来对潜在的敏感或不安全文本进行分类。您只需要执行以下操作：
- en: Use a content filter engine.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内容过滤引擎。
- en: Set `max_tokens` to `1`, `temperature` to `0.0`, and `top_p` to `0`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`max_tokens`设置为`1`，`temperature`设置为`0.0`，`top_p`设置为`0`。
- en: Format your prompt as `"<|endoftext|>your text here\n--\nLabel:"`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的提示格式化为`"<|endoftext|>your text here\n--\nLabel:"`。
- en: Alright, let's use Postman to get familiar with how content filtering works.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们使用Postman熟悉一下内容过滤的工作原理。
- en: Testing the content filtering process
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试内容过滤流程
- en: 'Later in this chapter, we''re going to create a simple content filter in code.
    But before we do, let''s use Postman to test the general content filtering approach:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将会在代码中创建一个简单的内容过滤。但在此之前，让我们使用Postman测试一下通用的内容过滤方法：
- en: Log in to [Postman.com](http://Postman.com).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录[Postman.com](http://Postman.com)。
- en: Open the Exploring GPT-3 workspace that we created in [*Chapter 4*](B16854_04_ePub_AM.xhtml#_idTextAnchor074),
    *Working with the OpenAI API*.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在[*第4章*](B16854_04_ePub_AM.xhtml#_idTextAnchor074)中创建的Exploring GPT-3工作空间，*使用OpenAI
    API*。
- en: Create a new Postman collection named **Chapter 06**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**第06章**的新Postman集合。
- en: Create a new request named **Content Filter - Example 1**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**内容过滤 - 示例1**的新请求。
- en: Set the request type to **POST**, and the request URL to [https://api.openai.com/v1/engines/content-filter-alpha-c4/completions](https://api.openai.com/v1/engines/content-filter-alpha-c4/completions),
    as shown in the following screenshot:![Figure 6.1 – Setting the filter endpoint
    in Postman
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求类型设置为**POST**，并将请求URL设置为[https://api.openai.com/v1/engines/content-filter-alpha-c4/completions](https://api.openai.com/v1/engines/content-filter-alpha-c4/completions)，如下面的屏幕截图所示:![图6.1
    - 在Postman中设置过滤端点
- en: '](img/B16854_06_001.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_001.jpg)'
- en: Figure 6.1 – Setting the filter endpoint in Postman
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.1 - 在Postman中设置过滤端点
- en: Set the request body to **raw** and the body type to **JSON**, as in the following
    screenshot:![Figure 6.2 – Filter parameters in Postman
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求主体设置为**原始**，并将主体类型设置为**JSON**，如以下屏幕截图所示:![图6.2 - Postman中的过滤参数
- en: '](img/B16854_06_002.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_002.jpg)'
- en: Figure 6.2 – Filter parameters in Postman
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.2 - Postman中的过滤参数
- en: 'Add the following JSON object to the request body:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下JSON对象添加到请求主体中：
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Click the send button and review the JSON response. The response will look
    something like the following screenshot:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '单击发送按钮并查看JSON响应。响应将类似于以下屏幕截图:'
- en: '![Figure 6.3 – Postman filter results'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 - Postman过滤结果'
- en: '](img/B16854_06_003.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_06_003.jpg)'
- en: Figure 6.3 – Postman filter results
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 - Postman过滤结果
- en: In the response, you should notice that the text value is **1** (sensitive)
    for the choices item with an index of **0**. As you might guess, that's likely
    because the text *Are you religious*? could be considered a sensitive topic.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应中，您会注意到索引为**0**的选择项的文本值为**1**（敏感）。正如您所猜的那样，这很可能是因为文本*Are you religious*?
    可能被视为敏感话题。
- en: Before moving on, try changing the prompt text to something that you suspect
    might be considered sensitive or unsafe and see how it gets classified. After
    getting familiar with the content filtering process, move on to the next section
    to try it out in JavaScript.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，尝试将提示文字更改为您认为可能被视为敏感或不安全的内容，并查看其分类情况。熟悉内容过滤流程后，继续下一节，在JavaScript中尝试应用。
- en: Filtering content with JavaScript
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript过滤内容
- en: 'In this section, we''ll look at a simple content filtering code example using
    JavaScript. We could write all the code ourselves, but there is a cool feature
    in Postman that generates code snippets for the requests we create. So, let''s
    give that a try:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 JavaScript 看一下一个简单的内容过滤代码示例。我们可以自己编写所有代码，但是 Postman 中有一个很酷的功能，可以为我们创建的请求生成代码片段。所以，让我们试试看：
- en: To see Postman-generated code snippets, click on the **code** button on the
    right-side menu. The arrow in the following screenshot is pointing to the **</>**
    icon, which is the button to click:![Figure 6.4 – Code button to open the code
    pane
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看 Postman 生成的代码片段，请单击右侧菜单上的**代码**按钮。以下截图中的箭头指向要单击的**</>**图标：![图 6.4 – 打开代码窗格的代码按钮
- en: '](img/B16854_06_004.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_004.jpg)'
- en: Figure 6.4 – Code button to open the code pane
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.4 – 打开代码窗格的代码按钮
- en: After clicking the code button, a code snippet pane will open in Postman. Change
    the code snippet type to **NodeJs – Axios** by selecting it from the drop-down
    list. Then, click the copy button shown in the following screenshot. This will
    copy the code snippet to your clipboard:![Figure 6.5 – Postman code snippet for
    Node.js – Axios
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击代码按钮后，Postman 将打开一个代码片段窗格。从下拉列表中选择**NodeJs – Axios**，将代码片段类型更改为该选项。然后，单击以下截图中显示的复制按钮。这将复制代码片段到您的剪贴板：![图
    6.5 – 适用于 Node.js – Axios 的 Postman 代码片段
- en: '](img/B16854_06_005.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_005.jpg)'
- en: Figure 6.5 – Postman code snippet for Node.js – Axios
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.5 – 适用于 Node.js – Axios 的 Postman 代码片段
- en: 'After copying the code snippet to the clipboard, perform the following steps:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码片段复制到剪贴板后，请执行以下步骤：
- en: a) Log in to [replit.com](http://replit.com) and open your `chapter06`.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 登录 [replit.com](http://replit.com)，并打开您的`chapter06`。
- en: c) Create a file in the `chapter06` folder named `filter.js`.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 在名为`filter.js`的`chapter06`文件夹中创建一个文件。
- en: d) Paste the code snippet from Postman into the `filter.js` file.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 将来自 Postman 的代码片段粘贴到`filter.js`文件中。
- en: The resulting code should look like the following screenshot. However, there
    is one small change we need to make before we can run the file:![Figure 6.6 –
    Code copied from the Postman snippet to the replit.com file
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终生成的代码应该看起来像以下截图。但是，在运行文件之前，我们需要做一个小改变：![图 6.6 – 从 Postman 代码片段复制到 replit.com
    文件
- en: '](img/B16854_06_006.jpg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_006.jpg)'
- en: '[PRE9]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, after updating the authorization line, the final code should be the following:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在更新授权行之后，最终代码应该如下所示：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows the preceding code in [replit.com](http://replit.com):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了[replit.com](http://replit.com)中的先前代码：
- en: '![Figure 6.7 – Postman code snippet modified for replit.com'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7 – 修改后适用于 replit.com 的 Postman 代码片段'
- en: '](img/B16854_06_007.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_06_007.jpg)'
- en: Figure 6.7 – Postman code snippet modified for replit.com
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 修改后的适用于 replit.com 的 Postman 代码片段
- en: 'At this point, the code is very similar to the code we wrote in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098),
    *Using the OpenAI API in Code*, when we discussed calling the completions endpoint.
    We just need to edit the `run` command in the `.replit` file to run the code in
    our `chapter06/filter.js` file. Then we can carry out a test:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，代码与我们在[*第五章*](B16854_05_ePub_AM.xhtml#_idTextAnchor098)中所写的代码非常相似，*在代码中使用
    OpenAI API*，当我们讨论调用完成端点时。我们只需要编辑`.replit`文件中的`run`命令，以运行我们的`chapter06/filter.js`文件中的代码。然后我们可以进行测试：
- en: 'So, update the `.replit` file to the following:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，将`.replit`文件更新为以下内容：
- en: '[PRE11]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After updating the `.replit` file, click the green **Run** button and you should
    see results in the console window that are similar to the following screenshot:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`.replit`文件后，单击绿色的**运行**按钮，您应该在控制台窗口中看到类似以下截图的结果：
- en: '![Figure 6.8 – Results from running chapter06/filter.js'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.8 – 运行 chapter06/filter.js 的结果'
- en: '](img/B16854_06_008.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_06_008.jpg)'
- en: Figure 6.8 – Results from running chapter06/filter.js
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 运行 chapter06/filter.js 的结果
- en: This is a simple example that classifies all of the text in a single prompt.
    Let's take a look at another example that classifies each word in a string and
    classifies each word as safe, sensitive, or unsafe.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，将单个提示中的所有文本分类。让我们看另一个示例，该示例将字符串中的每个单词进行分类，并将每个单词分类为安全、敏感或不安全。
- en: Flagging unsafe words with Node.js/JavaScript
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Node.js/JavaScript 标记不安全的词汇
- en: 'For this example, we''ll start by creating a new file named `chapter06/flag.js`
    and copying in the code from `chapter06/filter.js` as a starting point. From there,
    we''re going to modify the code in `chapter06/flag.js` to list each word with
    a classification value (0 = safe, 1 = sensitive, 2 = unsafe). To begin, perform
    the following steps to create our starting point:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将从创建一个名为`chapter06/flag.js`的新文件开始，并将`chapter06/filter.js`中的代码复制到其中作为起点。然后，我们将修改`chapter06/flag.js`中的代码，将每个单词列出并附带一个分类值（0
    = 安全，1 = 敏感，2 = 不安全）。首先，执行以下步骤创建我们的起点：
- en: Log in to [replit.com](http://replit.com) and open your **exploring-gpt3-node**
    repl.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到[replit.com](http://replit.com)，打开您的**exploring-gpt3-node** repl。
- en: Create a file in the `chapter06` folder named `flag.js`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chapter06`文件夹中创建一个名为`flag.js`的文件。
- en: Copy and paste the entire contents of `chapter06/filter.js` into `chapter06/flag.js`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`chapter06/filter.js`的整个内容复制并粘贴到`chapter06/flag.js`中。
- en: 'Edit the `.replit` file to run `chapter06/flag.js` by using the following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`.replit`文件以使用以下命令运行`chapter06/flag.js`：
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ll start by adding a variable to hold the text we want to filter. We''ll
    add this code just under the first line. So, the first two lines will be as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先添加一个变量来保存我们要过滤的文本。我们将在第一行下面添加这段代码。因此，前两行将如下所示：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we''ll add a variable to hold an array of prompts and set the initial
    value to an empty array. This will get populated with a prompt for each word from
    our text input:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个变量来保存一个提示数组，并将初始值设置为空数组。这将用文本输入的每个单词的提示填充：
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we''ll split our `textInput` into an array of words and populate the `prompts`
    array with a prompt for each word. Since we''re sending the prompts to the filter
    engine, we''ll also need to format each prompt item properly. So, we''ll add the
    following code after our `prompts` variable. This code splits the text input into
    individual words, loops through each word to create a prompt item, and then adds
    the prompt item to the `prompts` array:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把我们的`textInput`拆分成一个单词数组，并用每个单词的提示填充`prompts`数组。由于我们将提示发送到过滤引擎，我们还需要正确格式化每个提示项。因此，我们将在我们的`prompts`变量后添加以下代码。此代码将文本输入拆分为单个单词，循环遍历每个单词以创建提示项，然后将提示项添加到`prompts`数组中：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we will update the data variable that was created by Postman. We''ll use
    our `prompts` array as the prompt value rather than the hardcoded value from Postman.
    So, we''ll change the data variable to the following:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将更新由Postman创建的data变量。我们将使用我们的`prompts`数组作为提示值，而不是来自Postman的硬编码值。因此，我们将数据变量更改为以下内容：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we''ll modify the output with code that loops through the word array
    and classifies each word using the results from the filter. To do that, replace
    the line that contains `console.log(JSON.stringify(response.data));` with the
    following code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将通过循环遍历单词数组并使用过滤器结果对每个单词进行分类来修改输出。为此，请将包含`console.log(JSON.stringify(response.data));`的行替换为以下代码：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After making that last code edit, we can run the code again and this time we''ll
    see a response like the following:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在进行最后一次代码编辑之后，我们可以再次运行代码，这次我们将看到以下响应：
- en: '![Figure 6.9 – Content filter results for each word in a text input'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9 – 文本输入中每个单词的内容过滤器结果'
- en: '](img/B16854_06_009.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_06_009.jpg)'
- en: Figure 6.9 – Content filter results for each word in a text input
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 文本输入中每个单词的内容过滤器结果
- en: You'll notice now that the word (`religion`) has a text value of *1* (sensitive).
    If you change the `textInput` value with text that contains the more offensive
    word, you can run the code again to see how each word is classified. In a real-world
    implementation, you might replace or redact words that are sensitive or unsafe,
    which could now easily be done with the results from the API using a similar approach.
    We'll look at doing that in [*Chapter 7*](B16854_07_ePub_AM.xhtml#_idTextAnchor136),
    *Generating and Transforming Text*, but for now, let's look at content filtering
    with Python.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您会注意到单词（`religion`）的文本值为*1*（敏感）。如果您将`textInput`值更改为包含更具攻击性单词的文本，则可以再次运行代码以查看每个单词的分类方式。在实际实施中，您可能会替换或删除敏感或不安全的单词，现在可以轻松地通过API的结果使用类似的方法来完成。我们将在[*第7章*](B16854_07_ePub_AM.xhtml#_idTextAnchor136)中研究这样做，*生成和转换文本*，但现在，让我们来看看使用Python进行内容过滤。
- en: Filtering content with Python
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python过滤内容
- en: 'Now let''s see how to implement content filtering with Python. Unless you skipped
    over *Filtering content with JavaScript*, you can probably guess how we''re going
    to get started with a Python content filtering example – we''re going to use a
    code snippet generated by Postman:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用 Python 实现内容过滤。除非你跳过了“*使用 JavaScript 过滤内容*”，否则你可能能够猜到我们要如何开始使用 Python
    实现内容过滤的示例——我们会使用由 Postman 生成的代码片段：
- en: So, start by opening the code snippet pane in Postman. Then, click the code
    button in the right-hand menu. The code button is where the arrow in the following
    screenshot is pointing:![Figure 6.10 – Code button to open the code pane
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，首先需要在 Postman 中打开代码片段窗格。然后，点击右侧菜单中的代码按钮。箭头指向的即为代码按钮，如下面的截图所示：![图 6.10 – 打开代码窗格的代码按钮
- en: '](img/B16854_06_010.jpg)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_010.jpg)'
- en: Figure 6.10 – Code button to open the code pane
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.10 – 打开代码窗格的代码按钮
- en: After clicking the code button, the code snippet pane will open. Change the
    code snippet type to **Python – Requests** by selecting it from the drop-down
    list. Then, click the copy button shown in the following screenshot. This will
    copy the code snippet to your clipboard:![Figure 6.11 – Postman code snippet for
    Python – requests
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击代码按钮后，代码片段窗格会打开。更改代码片段类型为 **Python – Requests**，方法是从下拉列表中选择它，然后单击下面截图中所示的复制按钮。这将将代码片段复制到你的剪贴板：![图
    6.11 – 用于 Python – requests 的 Postman 代码片段
- en: '](img/B16854_06_011.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_011.jpg)'
- en: Figure 6.11 – Postman code snippet for Python – requests
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.11 – 用于 Python – requests 的 Postman 代码片段
- en: 'After copying the code snippet to the clipboard, perform the following steps:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码片段复制到剪贴板后，执行以下步骤：
- en: a) Log in to [replit.com](http://replit.com) and open your `chapter06`.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 登录 [replit.com](http://replit.com)，并打开你的 `chapter06`。
- en: c) Create a file in the `chapter06` folder named `filter.py`.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 创建一个在 `chapter06` 文件夹中命名为 `filter.py` 的文件。
- en: d) Paste the snippet from Postman into the `filter.py` file.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 将 Postman 代码片段粘贴到 `filter.py` 文件中。
- en: The resulting code should look like the following screenshot. But you will see
    that your API key is hardcoded – it is blurred in the screenshot. The hardcoded
    API key is the first thing we will change:![Figure 6.12 – Code copied from the
    Postman snippet to the repl.it file
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终代码应该如下截图所示。但是你会发现你的 API Key 是硬编码的 —— 它在截图中被模糊处理了。硬编码的 API Key 是我们要更改的第一项内容：![图
    6.12 – 从 Postman 代码段复制到 repl.it 文件
- en: '](img/B16854_06_012.jpg)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_012.jpg)'
- en: Figure 6.12 – Code copied from the Postman snippet to the repl.it file
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.12 – 从 Postman 代码段复制到 repl.it 文件
- en: 'To remove the hardcoded API key from our code file, we will import the Python
    `os` library first so we can read the `OPENAI_API_KEY` environment variable that
    we set in the `.env` file in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098),
    *Using the OpenAI API in Code*. So, we''ll add the following code to the first
    line of our `filter.py` file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从我们的代码文件中删除硬编码的 API Key，在 `filter.py` 文件的第一行添加以下代码，这样我们就可以读取在[*使用 OpenAI API
    进行代码编写*](B16854_05_ePub_AM.xhtml#_idTextAnchor098)中设置的 `.env` 文件中的 `OPENAI_API_KEY`
    环境变量了：
- en: '[PRE18]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After importing the Python `os` library, we can get the API key value for the
    authorization header from our environment variable. In the preceding *Figure 6.12*,
    you would be editing *line 7* to the following:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 Python 的 `os` 库后，我们可以从环境变量获取授权头的 API Key 值。在先前的 *图 6.12* 中，你需要将 *第 7 行* 编辑为以下内容：
- en: '[PRE19]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After updating the authorization line, the final code should be the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新授权行后，最终代码应如下所示：
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The following screenshot shows the preceding code in [replit.com](http://replit.com):![Figure
    6.13 – Postman Python code snippet modified for replit.com
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的截图展示了前面章节中修改的 Postman Python 代码片段在 [replit.com](http://replit.com) 中的效果：![图
    6.13 – 修改后的用于 repl.git.com 的 Postman Python 代码片段
- en: '](img/B16854_06_013.jpg)'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_06_013.jpg)'
- en: Figure 6.13 – Postman Python code snippet modified for replit.com
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.13 – 修改后的用于 repl.git.com 的 Postman Python 代码片段
- en: 'At this point, the code is very similar to the code we wrote in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098),
    *Using the OpenAI API in Code*, when we discussed calling the completions endpoint
    using Python. We just need to edit the `run` command in the `.replit` file to
    run the code in our `chapter06/filter.py` file. Then we can carry out a test.
    So, update the `.replit` file to the following:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，代码与我们在前一章“[*使用 OpenAI API 进行代码编写*](B16854_05_ePub_AM.xhtml#_idTextAnchor098)”中编写的代码非常相似，那时我们讨论了使用
    Python 调用完成端点。我们只需编辑 `.replit` 文件中的 `run` 命令，以运行我们的 `chapter06/filter.py` 文件中的代码。然后我们可以进行测试。因此，请将
    `.replit` 文件更新为以下内容：
- en: '[PRE21]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After updating the `.replit` file, click the green **Run** button and you should
    see results in the console window that are similar to the following screenshot:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`.replit`文件后，单击绿色的**Run**按钮，您应该会在控制台窗口中看到类似以下截图的结果：
- en: '![Figure 6.14 – Results from running chapter06/filter.py'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14-运行chapter06/filter.py的结果'
- en: '](img/B16854_06_014.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_06_014.jpg)'
- en: Figure 6.14 – Results from running chapter06/filter.py
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14-运行chapter06/filter.py的结果
- en: This is a simple example that classifies all of the text in a single prompt.
    Let's now take a look at another example that classifies each word in a string
    and replaces unsafe words.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，它将一个单一提示中的所有文本进行分类。让我们现在看另一个例子，它将对字符串中的每个单词进行分类并替换不安全的单词。
- en: Flagging unsafe words with Python
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python标记不安全的单词
- en: 'For this example, we''ll start by creating a new file named `chapter06/flag.py`
    and copying in the code from `chapter06/filter.py` as a starting point. From there,
    we''re going to modify the code in `chapter06/flag.py` to list each word with
    a classification value (0 = safe, 1 = sensitive, 2 = unsafe). To begin, perform
    the following steps to create our starting point:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将首先创建一个名为`chapter06/flag.py`的新文件，并将`chapter06/filter.py`中的代码复制到其中作为起点。从那里开始，我们将修改`chapter06/flag.py`中的代码，列出每个具有分类值的单词（0
    = 安全，1 = 敏感，2 = 不安全）。开始之前，请执行以下步骤创建起点：
- en: Log in to replit.com and open `your exploring-gpt3-python` repl.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到replit.com并打开`your exploring-gpt3-python`repl。
- en: Create a file in the `chapter06` folder named `flag.py`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chapter06`文件夹中创建一个名为`flag.py`的文件。
- en: Copy and paste the entire contents of `chapter06/filter.py` into `chapter06/flag.py`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴`chapter06/filter.py`的全部内容到`chapter06/flag.py`中。
- en: 'Edit the `.replit` file to run `chapter06/flag.py` using the following command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`.replit`文件，使用以下命令运行`chapter06/flag.py`：
- en: '[PRE22]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `chapter06/flag.py` file, we''ll add a variable to hold the text we
    want to filter. We''ll add the following code just under the third line (after
    the last line that starts with `import`):'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chapter06/flag.py`文件中，我们将添加一个变量来保存我们要过滤的文本。我们将在第三行下面（最后一个以`import`开头的行之后）添加以下代码：
- en: '[PRE23]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we''ll add a variable to hold an array of prompts and set the initial
    value to an empty array. This will get populated with a prompt for each word from
    our text input:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个变量来保存提示数组，并将初始值设置为空数组。这将从我们的文本输入中为每个单词填充一个提示：
- en: '[PRE24]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we''ll split our `textInput` into an array of words and populate the `prompts`
    array with a prompt for each word. Since we''re sending the prompts to the filter
    engine, we''ll also need to format each prompt item properly. So, we''ll add the
    following code after our `prompts` variable. This code splits the text input into
    individual words, loops through each word to create a prompt item, and adds the
    prompt item to the `prompts` array:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把`textInput`拆分为单词数组，并用每个单词的提示填充`prompts`数组。由于我们将提示发送到filter engine，因此还需要正确格式化每个提示项。所以，在`prompts`变量之后添加以下代码。此代码将文本输入拆分为单个单词，循环遍历每个单词以创建提示项，并将提示项添加到`prompts`数组中：
- en: '[PRE25]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we will update the payload variable that was created by Postman to a Python
    object rather than a string. This makes it a little more readable and easier to
    include our `prompts` array. So, replace the payload variable with the following
    code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把由Postman创建的`payload`变量更新为Python对象而不是字符串。这使它更容易读取和包含我们的`prompts`数组。因此，请将`payload`变量替换为以下代码：
- en: '[PRE26]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we''ll replace the last line of code, `print(response.text)`, with
    the following code that loops through the results and adds a classification (0
    = safe, 1 = sensitive, 2 = unsafe) for each word:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将用下面的代码替换最后一行代码`print(response.text)`，通过循环遍历结果并为每个单词添加分类（0 = 安全，1 = 敏感，2
    = 不安全）：
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After making that final code edit, we can click the **Run** button and this
    time we''ll see a response like the following:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行最终代码编辑后，我们可以点击**Run**按钮，这次我们将看到类似以下的响应：
- en: '![Figure 6.15 – Content filter results for each word in a text input using
    Python'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15-使用Python显示文本输入中每个单词内容过滤结果'
- en: '](img/B16854_06_015.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_06_015.jpg)'
- en: Figure 6.15 – Content filter results for each word in a text input using Python
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15-使用Python显示文本输入中每个单词内容过滤结果
- en: You'll notice in the console that the word (`religion`) has a text value of
    **1** (sensitive). In a real-world application, you'd use a similar approach to
    redact or replace unsafe and sensitive words. But keep in mind that no content
    filtering process is perfect. Language is constantly evolving, and the context
    of words can change meanings, which might cause the content filter to miss or
    falsely flag content. So, it's important to consider this in the design of your
    filtering approach.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到在控制台中，单词（`religion`）的文本值为**1**（敏感）。在实际应用中，您将使用类似的方法来编辑或替换不安全和敏感的单词。但请记住，没有任何内容过滤过程是完美的。语言不断发展，单词的上下文可能会改变含义，这可能会导致内容过滤器漏掉或错误地标记内容。因此，在设计您的过滤方法时考虑到这一点很重要。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how GPT-3 might, at times, generate inappropriate
    content. We also discussed what we can do to prevent and detect inappropriate
    content. You learned how prompts can be used to prevent the likelihood that inappropriate
    content is generated, and how content filtering can be used to classify content
    as safe, sensitive, or unsafe.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 GPT-3 有时可能生成不适当内容的情况。我们还讨论了我们可以采取的措施来预防和检测不适当内容。您学会了如何使用提示来防止生成不适当内容的可能性，以及如何使用内容过滤将内容分类为安全、敏感或不安全。
- en: We reviewed how the completions endpoint can be used for content filtering and
    how to implement content filtering using both JavaScript and Python.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了如何使用完成端点进行内容过滤，以及如何使用 JavaScript 和 Python 实现内容过滤。
- en: In the next chapter, we will take what we learned in this chapter, along with
    what we learned in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098), *Calling
    the OpenAI API in Code*, and use that knowledge to build a GPT-3 powered chatbot.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，我们将利用本章学到的知识，以及[*第五章*](B16854_05_ePub_AM.xhtml#_idTextAnchor098)，*在代码中调用
    OpenAI API* 中学到的知识，来构建一个由 GPT-3 驱动的聊天机器人。
