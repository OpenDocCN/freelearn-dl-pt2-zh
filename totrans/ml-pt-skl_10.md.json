["```py\n>>> from sklearn.datasets import make_blobs\n>>> X, y = make_blobs(n_samples=150,\n...                   n_features=2,\n...                   centers=3,\n...                   cluster_std=0.5,\n...                   shuffle=True,\n...                   random_state=0)\n>>> import matplotlib.pyplot as plt\n>>> plt.scatter(X[:, 0],\n...             X[:, 1],\n...             c='white',\n...             marker='o',\n...             edgecolor='black',\n...             s=50)\n>>> plt.xlabel('Feature 1')\n>>> plt.ylabel('Feature 2')\n>>> plt.grid()\n>>> plt.tight_layout()\n>>> plt.show() \n```", "```py\n>>> from sklearn.cluster import KMeans\n>>> km = KMeans(n_clusters=3,\n...             init='random',\n...             n_init=10,\n...             max_iter=300,\n...             tol=1e-04,\n...             random_state=0)\n>>> y_km = km.fit_predict(X) \n```", "```py\n>>> plt.scatter(X[y_km == 0, 0],\n...             X[y_km == 0, 1],\n...             s=50, c='lightgreen',\n...             marker='s', edgecolor='black',\n...             label='Cluster 1')\n>>> plt.scatter(X[y_km == 1, 0],\n...             X[y_km == 1, 1],\n...             s=50, c='orange',\n...             marker='o', edgecolor='black',\n...             label='Cluster 2')\n>>> plt.scatter(X[y_km == 2, 0],\n...             X[y_km == 2, 1],\n...             s=50, c='lightblue',\n...             marker='v', edgecolor='black',\n...             label='Cluster 3')\n>>> plt.scatter(km.cluster_centers_[:, 0],\n...             km.cluster_centers_[:, 1],\n...             s=250, marker='*',\n...             c='red', edgecolor='black',\n...             label='Centroids')\n>>> plt.xlabel('Feature 1')\n>>> plt.ylabel('Feature 2')\n>>> plt.legend(scatterpoints=1)\n>>> plt.grid()\n>>> plt.tight_layout()\n>>> plt.show() \n```", "```py\n>>> print(f'Distortion: {km.inertia_:.2f}')\nDistortion: 72.48 \n```", "```py\n>>> distortions = []\n>>> for i in range(1, 11):\n...     km = KMeans(n_clusters=i,\n...                 init='k-means++',\n...                 n_init=10,\n...                 max_iter=300,\n...                 random_state=0)\n...     km.fit(X)\n...     distortions.append(km.inertia_)\n>>> plt.plot(range(1,11), distortions, marker='o')\n>>> plt.xlabel('Number of clusters')\n>>> plt.ylabel('Distortion')\n>>> plt.tight_layout()\n>>> plt.show() \n```", "```py\n>>> km = KMeans(n_clusters=3,\n...             init='k-means++',\n...             n_init=10,\n...             max_iter=300,\n...             tol=1e-04,\n...             random_state=0)\n>>> y_km = km.fit_predict(X)\n>>> import numpy as np\n>>> from matplotlib import cm\n>>> from sklearn.metrics import silhouette_samples\n>>> cluster_labels = np.unique(y_km)\n>>> n_clusters = cluster_labels.shape[0]\n>>> silhouette_vals = silhouette_samples(\n...     X, y_km, metric='euclidean'\n... )\n>>> y_ax_lower, y_ax_upper = 0, 0\n>>> yticks = []\n>>> for i, c in enumerate(cluster_labels):\n...     c_silhouette_vals = silhouette_vals[y_km == c]\n...     c_silhouette_vals.sort()\n...     y_ax_upper += len(c_silhouette_vals)\n...     color = cm.jet(float(i) / n_clusters)\n...     plt.barh(range(y_ax_lower, y_ax_upper),\n...              c_silhouette_vals,\n...              height=1.0,\n...              edgecolor='none',\n...              color=color)\n...     yticks.append((y_ax_lower + y_ax_upper) / 2.)\n...     y_ax_lower += len(c_silhouette_vals)\n>>> silhouette_avg = np.mean(silhouette_vals)\n>>> plt.axvline(silhouette_avg,\n...             color=\"red\",\n...             linestyle=\"--\")\n>>> plt.yticks(yticks, cluster_labels + 1)\n>>> plt.ylabel('Cluster')\n>>> plt.xlabel('Silhouette coefficient')\n>>> plt.tight_layout()\n>>> plt.show() \n```", "```py\n>>> km = KMeans(n_clusters=2,\n...             init='k-means++',\n...             n_init=10,\n...             max_iter=300,\n...             tol=1e-04,\n...             random_state=0)\n>>> y_km = km.fit_predict(X)\n>>> plt.scatter(X[y_km == 0, 0],\n...             X[y_km == 0, 1],\n...             s=50, c='lightgreen',\n...             edgecolor='black',\n...             marker='s',\n...             label='Cluster 1')\n>>> plt.scatter(X[y_km == 1, 0],\n...             X[y_km == 1, 1],\n...             s=50,\n...             c='orange',\n...             edgecolor='black',\n...             marker='o',\n...             label='Cluster 2')\n>>> plt.scatter(km.cluster_centers_[:, 0],\n...             km.cluster_centers_[:, 1],\n...             s=250,\n...             marker='*',\n...             c='red',\n...             label='Centroids')\n>>> plt.xlabel('Feature 1')\n>>> plt.ylabel('Feature 2')\n>>> plt.legend()\n>>> plt.grid()\n>>> plt.tight_layout()\n>>> plt.show() \n```", "```py\n>>> cluster_labels = np.unique(y_km)\n>>> n_clusters = cluster_labels.shape[0]\n>>> silhouette_vals = silhouette_samples(\n...     X, y_km, metric='euclidean'\n... )\n>>> y_ax_lower, y_ax_upper = 0, 0\n>>> yticks = []\n>>> for i, c in enumerate(cluster_labels):\n...     c_silhouette_vals = silhouette_vals[y_km == c]\n...     c_silhouette_vals.sort()\n...     y_ax_upper += len(c_silhouette_vals)\n...     color = cm.jet(float(i) / n_clusters)\n...     plt.barh(range(y_ax_lower, y_ax_upper),\n...              c_silhouette_vals,\n...              height=1.0,\n...              edgecolor='none',\n...              color=color)\n...     yticks.append((y_ax_lower + y_ax_upper) / 2.)\n...     y_ax_lower += len(c_silhouette_vals)\n>>> silhouette_avg = np.mean(silhouette_vals)\n>>> plt.axvline(silhouette_avg, color=\"red\", linestyle=\"--\")\n>>> plt.yticks(yticks, cluster_labels + 1)\n>>> plt.ylabel('Cluster')\n>>> plt.xlabel('Silhouette coefficient')\n>>> plt.tight_layout()\n>>> plt.show() \n```", "```py\n>>> import pandas as pd\n>>> import numpy as np\n>>> np.random.seed(123)\n>>> variables = ['X', 'Y', 'Z']\n>>> labels = ['ID_0', 'ID_1', 'ID_2', 'ID_3', 'ID_4']\n>>> X = np.random.random_sample([5, 3])*10\n>>> df = pd.DataFrame(X, columns=variables, index=labels)\n>>> df \n```", "```py\n>>> from scipy.spatial.distance import pdist, squareform\n>>> row_dist = pd.DataFrame(squareform(\n...                         pdist(df, metric='euclidean')),\n...                         columns=labels, index=labels)\n>>> row_dist \n```", "```py\n>>> from scipy.cluster.hierarchy import linkage\n>>> help(linkage)\n[...]\nParameters:\n  y : ndarray\n    A condensed or redundant distance matrix. A condensed\n    distance matrix is a flat array containing the upper\n    triangular of the distance matrix. This is the form\n    that pdist returns. Alternatively, a collection of m\n    observation vectors in n dimensions may be passed as\n    an m by n array.\n\n  method : str, optional\n    The linkage algorithm to use. See the Linkage Methods\n    section below for full descriptions.\n\n  metric : str, optional\n    The distance metric to use. See the distance.pdist\n    function for a list of valid distance metrics.\n\n  Returns:\n  Z : ndarray\n    The hierarchical clustering encoded as a linkage matrix.\n[...] \n```", "```py\n    >>> row_clusters = linkage(row_dist,\n    ...                        method='complete',\n    ...                        metric='euclidean') \n    ```", "```py\n    >>> row_clusters = linkage(pdist(df, metric='euclidean'),\n    ...                        method='complete') \n    ```", "```py\n    >>> row_clusters = linkage(df.values,\n    ...                        method='complete',\n    ...                        metric='euclidean') \n    ```", "```py\n>>> pd.DataFrame(row_clusters,\n...              columns=['row label 1',\n...                       'row label 2',\n...                       'distance',\n...                       'no. of items in clust.'],\n...              index=[f'cluster {(i + 1)}' for i in\n...                     range(row_clusters.shape[0])]) \n```", "```py\n>>> from scipy.cluster.hierarchy import dendrogram\n>>> # make dendrogram black (part 1/2)\n>>> # from scipy.cluster.hierarchy import set_link_color_palette\n>>> # set_link_color_palette(['black'])\n>>> row_dendr = dendrogram(\n...     row_clusters,\n...     labels=labels,\n...     # make dendrogram black (part 2/2)\n...     # color_threshold=np.inf\n... )\n>>> plt.tight_layout()\n>>> plt.ylabel('Euclidean distance')\n>>> plt.show() \n```", "```py\n    >>> fig = plt.figure(figsize=(8, 8), facecolor='white')\n    >>> axd = fig.add_axes([0.09, 0.1, 0.2, 0.6])\n    >>> row_dendr = dendrogram(row_clusters,\n    ...                        orientation='left')\n    >>> # note: for matplotlib < v1.5.1, please use\n    >>> # orientation='right' \n    ```", "```py\n    >>> df_rowclust = df.iloc[row_dendr['leaves'][::-1]] \n    ```", "```py\n    >>> axm = fig.add_axes([0.23, 0.1, 0.6, 0.6])\n    >>> cax = axm.matshow(df_rowclust,\n    ...                   interpolation='nearest',\n    ...                   cmap='hot_r') \n    ```", "```py\n    >>> axd.set_xticks([])\n    >>> axd.set_yticks([])\n    >>> for i in axd.spines.values():\n    ...     i.set_visible(False)\n    >>> fig.colorbar(cax)\n    >>> axm.set_xticklabels([''] + list(df_rowclust.columns))\n    >>> axm.set_yticklabels([''] + list(df_rowclust.index))\n    >>> plt.show() \n    ```", "```py\n>>> from sklearn.cluster import AgglomerativeClustering\n>>> ac = AgglomerativeClustering(n_clusters=3,\n...                              affinity='euclidean',\n...                              linkage='complete')\n>>> labels = ac.fit_predict(X)\n>>> print(f'Cluster labels: {labels}')\nCluster labels: [1 0 0 2 1] \n```", "```py\n>>> ac = AgglomerativeClustering(n_clusters=2,\n...                              affinity='euclidean',\n...                              linkage='complete')\n>>> labels = ac.fit_predict(X)\n>>> print(f'Cluster labels: {labels}')\nCluster labels: [0 1 1 0 0] \n```", "```py\n>>> from sklearn.datasets import make_moons\n>>> X, y = make_moons(n_samples=200,\n...                   noise=0.05,\n...                   random_state=0)\n>>> plt.scatter(X[:, 0], X[:, 1])\n>>> plt.xlabel('Feature 1')\n>>> plt.ylabel('Feature 2')\n>>> plt.tight_layout()\n>>> plt.show() \n```", "```py\n>>> f, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 3))\n>>> km = KMeans(n_clusters=2,\n...             random_state=0)\n>>> y_km = km.fit_predict(X)\n>>> ax1.scatter(X[y_km == 0, 0],\n...             X[y_km == 0, 1],\n...             c='lightblue',\n...             edgecolor='black',\n...             marker='o',\n...             s=40,\n...             label='cluster 1')\n>>> ax1.scatter(X[y_km == 1, 0],\n...             X[y_km == 1, 1],\n...             c='red',\n...             edgecolor='black',\n...             marker='s',\n...             s=40,\n...             label='cluster 2')\n>>> ax1.set_title('K-means clustering')\n>>> ax1.set_xlabel('Feature 1')\n>>> ax1.set_ylabel('Feature 2')\n>>> ac = AgglomerativeClustering(n_clusters=2,\n...                              affinity='euclidean',\n...                              linkage='complete')\n>>> y_ac = ac.fit_predict(X)\n>>> ax2.scatter(X[y_ac == 0, 0],\n...             X[y_ac == 0, 1],\n...             c='lightblue',\n...             edgecolor='black',\n...             marker='o',\n...             s=40,\n...             label='Cluster 1')\n>>> ax2.scatter(X[y_ac == 1, 0],\n...             X[y_ac == 1, 1],\n...             c='red',\n...             edgecolor='black',\n...             marker='s',\n...             s=40,\n...             label='Cluster 2')\n>>> ax2.set_title('Agglomerative clustering')\n>>> ax2.set_xlabel('Feature 1')\n>>> ax2.set_ylabel('Feature 2')\n>>> plt.legend()\n>>> plt.tight_layout()\n>>> plt.show() \n```", "```py\n>>> from sklearn.cluster import DBSCAN\n>>> db = DBSCAN(eps=0.2,\n...             min_samples=5,\n...             metric='euclidean')\n>>> y_db = db.fit_predict(X)\n>>> plt.scatter(X[y_db == 0, 0],\n...             X[y_db == 0, 1],\n...             c='lightblue',\n...             edgecolor='black',\n...             marker='o',\n...             s=40,\n...             label='Cluster 1')\n>>> plt.scatter(X[y_db == 1, 0],\n...             X[y_db == 1, 1],\n...             c='red',\n...             edgecolor='black',\n...             marker='s',\n...             s=40,\n...             label='Cluster 2')\n>>> plt.xlabel('Feature 1')\n>>> plt.ylabel('Feature 2')\n>>> plt.legend()\n>>> plt.tight_layout()\n>>> plt.show() \n```"]