- en: '*Chapter 4*: Working with the OpenAI API'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, everything we've done with GPT-3 has been through the Playground.
    While the Playground is a great place for learning and testing, when you're building
    applications that incorporate GPT-3, you'll also need to understand how to use
    the OpenAI API directly. So, in this chapter, we'll look at using the OpenAI API
    directly by making HTTP requests. We'll start with a general introduction to APIs
    and the HTTP protocol. Then we'll look at a couple of developer tools for working
    with API requests and the JSON data-interchange format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we''ll cover are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting familiar with HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the OpenAI API endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing CURL and Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding API authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an authenticated request to the OpenAI API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Completions endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Semantic Search endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires that you have access to the **OpenAI API**. You can request
    access by visiting [https://openapi.com](https://openapi.com).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The acronym **API** stands for **Application Programming Interface**. APIs allow
    software to communicate between systems and interchange data – to share computer
    system resources and software functionality. Because functionality can be shared,
    they also enable code reuse. This generally improves the quality of systems while
    also reducing development efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Web-based APIs are exposed over the internet using HTTP, the same protocol you
    use when you visit a URL in a web browser. So, using a web-based API is very much
    like using a website. For example, when you use an API, you make requests to a
    **Uniform Resource Locator** (**URL**), just like you do when you access a website.
    The URL provides the reference for a resource, data, or functionality provided
    by the API.
  prefs: []
  type: TYPE_NORMAL
- en: Like a website, each API is a collection of one or more URLs, which are also
    referred to as endpoints. Each endpoint provides access to a specific resource
    or functionality. Some endpoints might take input data and perform a task, while
    others might simply return data. The format of the input and the output data depends
    on the API. But most APIs use common data interchange formats, such as **JavaScript
    Object Notation** (**JSON**), or just plain text. We'll talk about the JSON data-interchange
    format later because that's what the OpenAI API uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since web-based APIs are accessible using HTTP and work with common data formats,
    they don''t depend on any specific programming language, meaning just about any
    programing language or development tool that can make an HTTP request can interact
    with an HTTP API. In fact, you can even use a web browser to interact with some
    web-based APIs. For example, if you open [http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)
    in your web browser, you''ll see a response that provides data about the number
    of humans that are currently in space. The results aren''t formatted nicely because
    they''re intended for machine use, not human consumption, but we can see the results
    in a browser because it''s using the same web protocol that websites use, as seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Open-Notify API – JSON response'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Open-Notify API – JSON response
  prefs: []
  type: TYPE_NORMAL
- en: But even though HTTP APIs aren't language-specific programming, many API publishers
    provide a **Software Developer Kit** (**SDK**) or a software library to make using
    the API simpler to work with in a specific language. For example, OpenAI provides
    Python bindings (libraries) that simplify use of the OpenAI API in the Python
    programming language. These tools are essentially wrappers for the API that reduce
    the code you might need to write if you are using the API without the library.
    We'll talk more about some of the available libraries for the OpenAI API later,
    in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098), *Calling the OpenAI
    API in Code*. For now, the important thing to note is that it doesn't matter what
    programming language you choose as long as it's one that can make HTTP requests.
    Also, SDKs or libraries can be helpful, but they are not essential for using the
    API. However, what is essential is a basic understanding of the HTTP protocol.
    So, we'll talk about that next.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because APIs are designed to be used in code, in order to work with them, you
    do need to know a bit more about the HTTP protocol than you do for just accessing
    websites. So, in this section, you'll learn some HTTP basics.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, HTTP is a request-response protocol. So, a client (the requesting
    system) makes a request to a server (the receiving system), which then responds
    to the client. The client references the server and the resource being requested
    using a **Uniform Resource Identifier** (**URI**).
  prefs: []
  type: TYPE_NORMAL
- en: Uniform resource identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An HTTP URI provides the details needed to make an HTTP request to a specific
    server for a specific resource. To illustrate, let's break down the [http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)
    endpoint that we looked at previously in the *Understanding APIs* section. The
    endpoint begins with a reference to the protocol used. In our example, this is
    `http://`. For web-based APIs, this will always either be HTTP or HTTPS. When
    HTTPS is used, this is an indicator that requests and responses between the client
    and server will be encrypted. The second part of the URI ([api.open-notify.org](http://api.open-notify.org)
    in this example), is a reference to the server where the resource is located.
    Following the server name is a reference to the resource location on the server.
    Some URIs will also include parameters and values. These can be used to provide
    additional details or variable data that can be used by the server to process
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the URI, the HTTP protocol also supports different request types,
    called **HTTP methods**, which provide additional information about the request
    being made.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP methods let the server perform different operations using the same URL.
    There are six different HTTP methods, but not all URL endpoints support all of
    the methods. The two most common HTTP methods are `GET` and `POST`. The GET method
    tells the server that the client wants to retrieve (or get) information, and a
    POST method tells the server that the client is sending data. So, if an endpoint
    is used for retrieving data, the GET method would normally be used. However, if
    the endpoint expects a data input, the POST method might be used.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The body of an HTTP request or response contains the main data payload. In the
    case of a request, the body contains the data that will be sent to the server.
    In the case of the response, the body contains the data being sent back from the
    server. The data sent in the HTTP body could be any text-based payload. Commonly
    used formats are JSON, XML, and plain text. So, you'll also need to know the format
    of the data you'll be sending and receiving from the API you're working with.
    This is typically found in the API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP body isn't the only way to send/receive data. You can also include
    data as part of the URL, or as an HTTP header. HTTP headers are key/value pairs
    that can be used to send/receive values between the client and server. While HTTP
    headers can be used for a variety of reasons, they usually define metadata, or
    data that provides details about the request. For example, an HTTP header named
    **Content-Type** is used to tell the server what type of data is being passed
    in the body, and an **Authorization** header can be used to send authentication
    details, such as a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP response status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a client makes a valid request to a valid server, the server will always
    include an HTTP response status code with the response. The status code is a numeric
    value that provides a high-level outcome status of the response. For example,
    200 indicates a successful response, while 500 indicates an internal server error.
    For a full list of the different status codes, you can visit [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).
    While it's not important to memorize the different status codes, it's good to
    be familiar with them and to know where to look up what a code means. This is
    especially true when you're having issues calling an API endpoint because the
    status codes are very helpful for debugging problems.
  prefs: []
  type: TYPE_NORMAL
- en: This section just provided a very high-level overview of HTTP, but a high-level
    understanding is all you need for working with the OpenAI API and most other web-based
    APIs for that matter.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the OpenAI API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything that we've looked at doing through the Playground can also be done
    via the OpenAI API – and then some. In fact, the Playground is just a web interface
    that calls the OpenAI API. It is simply exposing functionality that the API provides
    using a graphical interface. So, in this section, we'll review the OpenAI functionality
    that's available through the API endpoints. You'll be familiar with the functionality
    because you've used it through the Playground, but after this section, you'll
    know how to access specific functionality in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the OpenAI API, you can do the following through the available endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Create completions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List available engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get engine details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform semantic searches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the OpenAI API endpoints require authentication. So, they can't just
    be called with a browser, like the Open-Notify API that we looked at earlier.
    But we'll hold off on talking about authentication just yet and review each of
    the available endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: List Engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The List Engines endpoint is a metadata API, meaning it provides data about
    the system itself. Specifically, a list of the available engines along with some
    basic information about each engine. OpenAI is actively working on new engines
    and updating existing ones, so the List Engines endpoint will provide a list of
    currently available engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The List Engines endpoint uses the HTTP GET method and doesn''t require any
    request parameters. The following is the HTTP method (GET) and URI for the List
    Engines endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next is the Retrieve Engine endpoint!
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Retrieve Engine endpoint is also a metadata API. It returns details about
    a specific engine. Like the List Engines endpoint, the Retrieve Engine endpoint
    also uses the HTTP GET method and requires that an engine ID is included as part
    of the URI path. The possible engine ID values can be retrieved from the List
    Engines endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Retrieve Engine endpoint uses the HTTP GET method and the following URI
    with one parameter, the engine ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next is the Create Completions endpoint – the one you'll likely be using the
    most.
  prefs: []
  type: TYPE_NORMAL
- en: Create Completions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Create Completions endpoint is the endpoint you'll be using most of the
    time. This is the endpoint that takes in a prompt and returns the completion results.
    This endpoint uses the HTTP POST method and requires an engine ID as part of the
    URI path. The Create Completions endpoint also accepts a number of additional
    parameters as part of the HTTP body. We'll discuss those parameters later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Completions endpoint also uses the POST method and requires an engine ID
    as a URI parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It's also worth noting that there is an experimental Create Completions endpoint
    for streaming results to a browser. It is called using the HTTP GET method and
    parameters are passed in the URI. You can learn more about this endpoint by visiting
    [https://beta.openai.com/docs/api-reference/create-completion-via-get](https://beta.openai.com/docs/api-reference/create-completion-via-get).
  prefs: []
  type: TYPE_NORMAL
- en: Semantic Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Semantic Search endpoint can be used to perform a semantic search over a
    list of documents. A semantic search compares a search term to the contents of
    a document to identify documents that are semantically similar. The documents
    to be searched are passed to the endpoint as part of the HTTP body and up to 200
    documents can be included. This endpoint uses the HTTP POST method and requires
    an engine ID to be passed as part of the endpoint URI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Semantic Search endpoint uses the POST method and requires an engine ID
    as a URI parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As web-based APIs go, the OpenAI API is relatively simple to work with, but
    before we give it a go, let's discuss a couple of development tools we can use
    to start testing the API.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing CURL and Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at a couple of developer tools for working with
    APIs. As we've discussed, APIs are designed to be used in code. However, during
    the development process, you'll often want to call an API endpoint without writing
    code to get familiar with the functionality or for testing. To do that, there
    are a number of developer tools available. Two of the most popular developer tools
    for working with APIs are CURL and Postman.
  prefs: []
  type: TYPE_NORMAL
- en: CURL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CURL is a popular command-line tool for making HTTP requests. It's been around
    since 1998, so it's very mature and widely used. Many API publishers, including
    OpenAI, provide API examples, using CURL syntax in their documentation. The following
    screenshot shows an example of the CURL syntax used in the OpenAI API docs. So,
    even if CURL isn't the tool you decide to use in the long run, it's helpful to
    be familiar with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows CURL syntax in the OpenAI API documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Curl command in the OpenAI API docs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Curl command in the OpenAI API docs
  prefs: []
  type: TYPE_NORMAL
- en: Curl is available for Linux, Mac, and Windows and comes installed by default
    on most Linux and Mac machines as well as on Windows computers (running Windows
    10 Build 1707 or later).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: To check your version of Windows, press *Windows+R* on your keyboard to open
    the **Run** dialog box. Then, type in *winver* (without the quotes) and click
    **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify whether CURL is installed from the command line. On Linux and
    Mac, the command line is accessible using the terminal application. On Windows,
    open the command prompt to access the command line. At the command line, you can
    enter the `curl --help` command to confirm that CURL is installed. If CURL is
    installed, you should see something like what''s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Curl Help command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Curl Help command
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have CURL installed, you can download it from the official CURL
    site at [https://curl.se/download.html](https://curl.se/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: There are entire books on using CURL, so we're only going to scratch the surface
    of its functionality here. We'll be talking about CURL for working with API calls,
    but it's not just for working with APIs – it can be used to make any HTTP request.
    For example, if you entered `curl` [https://dabblelab.com](https://dabblelab.com)
    at the command prompt and hit the *Return* key, CURL would fetch the [dabblelab.com](http://dabblelab.com)
    home page. However, CURL is not a browser, so what you'll see is raw HTML code
    rather than a nicely formatted web page as you'd see if you were using your browser.
  prefs: []
  type: TYPE_NORMAL
- en: As we take a closer look at the OpenAI API, we'll look at making different API
    calls with CURL. But before we do that, let's take a look at Postman, an alternative
    to using CURL.
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Postman is another developer tool for working with APIs. Unlike CURL, Postman
    has a graphical user interface. So, if the command line isn't your thing, you'll
    probably prefer Postman. You can use Postman from your browser, or you can download
    a version for Linux, Mac, or Windows. For our examples, we'll be using the web
    version because there is no software to install; you just need to sign up for
    a free account at [https://postman.com](https://postman.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Postman home page. You just need to complete
    the signup process to start using Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Postman home page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Postman home page
  prefs: []
  type: TYPE_NORMAL
- en: 'After signing up, you''ll be presented with a short onboarding process. Complete
    the onboarding process and when you''re done, you should see a screen similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Postman welcome screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Postman welcome screen
  prefs: []
  type: TYPE_NORMAL
- en: Like CURL, there is a lot to Postman and we're only going to look at a small
    subset of what Postman does. But at its core, Postman is a tool for calling API
    endpoints and inspecting the results the API endpoint returns. We will start with
    a quick walk-through that will show you how to make your first API request using
    Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Making a request with Postman
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started with Postman, let''s make a request to the Open-Notify API endpoint
    that we looked at previously in our browser. To do that, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: After logging in to [Postman.com](http://Postman.com), click the **Create New**
    link. If you're prompted to download the Desktop agent, click the **Skip for now**
    button. This will bring you to your workspace, which will look something like
    the following screenshot:![Figure 4.6 – My Workspace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16854_04_006.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.6 – My Workspace
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the right side of the workspace is a tab interface that, by default,
    will have the **Overview** tab open. Just to the right, you'll see a plus sign
    that can be used to open a new tab.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click the plus sign to open a new tab, enter the request URL ([http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)),
    and then click the **Send** button. You should see results similar to the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Postman request results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Postman request results
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the JSON results in *Figure 4.7* are formatted in a way that's easy
    to read. This is just one of many helpful things Postman does for us. As we delve
    further into the OpenAI API, we'll also cover more Postman features. But let's
    keep moving and discuss how to call the OpenAI API since it requires authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding API authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some websites are public, while others require you to log in before you can
    access content or functionality. The same is true for APIs. The Open-Notify API
    that we looked at in the *Understanding APIs* section is open to the public and
    doesn't require any kind of authentication. The OpenAI API, on the other hand,
    is private and therefore requires authentication to use it.
  prefs: []
  type: TYPE_NORMAL
- en: An API authentication process does the same thing as a website login, but in
    a way that is practical for applications rather than humans. There are many different
    ways in which APIs can authenticate application requests, but we're going to focus
    on one of the most common methods, **basic authentication**, because that's what
    the OpenAI API uses.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication is an authentication method that is native to HTTP. It
    allows a username and password to be included in an HTTP header. To keep credentials
    secure, requests and responses to the API should be encrypted. So, an API endpoint
    URL that uses basic authentication should always use **Secure Socket Layer** (**SSL**),
    which you can identify by a URL that begins with HTTPS as opposed to just HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the OpenAI API, rather than sending your username and password,
    you use an API key. An API key is like a username and password rolled into one
    string. The benefit of using an API key is that it can be easily changed or renewed
    without having to change your OpenAI password.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at where you can find your API key in [*Chapter 3*](B16854_03_ePub_AM.xhtml#_idTextAnchor050),
    *Working with the OpenAI Playground*, but to review, you can access your OpenAI
    API key under your user settings. From the same location, you can also expire
    and generate a new API key with the **Rotate Key** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **API Keys** screen under the account settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – API Keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – API Keys
  prefs: []
  type: TYPE_NORMAL
- en: With your API key, you have everything you need to make a request to the OpenAI
    API. But before we do that, let's talk for a minute about the importance of keeping
    API keys private.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping API keys private
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though API keys can be easily changed, they should be kept private, just
    like a username and password, because they also provide access to your account.
    So, take precautions to ensure that your API keys don''t get compromised accidentally.
    This can be easy to do by mistake if you''re not careful. For example, the OpenAI
    documentation includes your API key to make trying code samples simple. But if
    you take a screenshot of documentation for a blog post or something like that,
    you''ll expose your API key to anyone who sees the image if you don''t blur it
    out. The following screenshot shows an example of a documentation page that includes
    an API key. In the example, the key has been blurred out, but you can see how
    it would be exposed if that wasn''t the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – API key in documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – API key in documentation
  prefs: []
  type: TYPE_NORMAL
- en: Another common way to mistakenly expose API keys is when they are included with
    source code that is shared. We'll look at how to avoid that in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098),
    *Calling the OpenAI API in Code*, but the main point here is that you need to
    be cautious because your API key, like your username and password, provides access
    to your account.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to find your API key and keep it safe, let's look at using
    it to make our first call to the OpenAI API.
  prefs: []
  type: TYPE_NORMAL
- en: Making an authenticated request to the OpenAI API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to make our first request directly to the OpenAI API. To do that,
    we'll need to include our API key as part of an HTTP header. The header name we'll
    be using is authorization and the value will be the word *Bearer*, followed by
    a space and then your API key. When an API key is used like this, it's often also
    referred to as a bearer token. This is a standard defined by an authorization
    protocol called OAuth 2.0\. You can learn more about OAuth 2.0 by visiting [https://oauth.net/2/](https://oauth.net/2/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Postman makes it really easy to use bearer tokens. But before we make an authenticated
    request, let''s look at what happens if we try to make a request without our API
    key. The following screenshot shows a request to the List Engines endpoint URL,
    `https://api.openai.com/v1/engines`, without any authorization header. You can
    see an error message was returned. You''ll also notice that the HTTP response
    status code is `401 UNAUTHORIZED`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – API request without the API key'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – API request without the API key
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the error, we need to include our API key as the bearer token. Since
    we'll be using the API key for every request, we'll set up a Postman variable
    for the API key.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Postman variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables in Postman allow you to store and reuse values rather than having
    to enter them over and over. Variables can also be grouped into a Postman environment.
    So, we're going to set up an environment named **openai-dev** and add a variable
    named **OPENAI_API_KEY** to store our API key.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a Postman environment and a variable for your API key, use the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the eyeball icon in the upper-right corner of the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Add** link to add a new environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the environment `openai-dev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a variable named `OPENAI_API_KEY`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your API key in the `INITIAL VALUE` input box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Save** icon to save the environment and variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the **openai-dev** environment tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose the new environment from the environment option list in the upper-right
    corner. By default, it should say **No Environment**, and you''ll want to select
    **openai-dev**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Postman with the environment set'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Postman with the environment set
  prefs: []
  type: TYPE_NORMAL
- en: With the environment and `the OPENAI_API_KEY` variable in place, you can use
    your API key by just including `{{OPENAI_API_KEY}}` in place of the actual key
    value. Now, let's try it out by using it to set an authorization header for our
    request to the Engines endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the authorization header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that your OpenAI API key is set as a Postman variable, perform the following
    steps to test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Authorization** tab just below the request URL input box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Bearer Token** option from the **Type** drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **{{OPENAI_API_KEY}}** in the **Token input box**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Send** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see a successful response (HTTP status **200**), as demonstrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – API request using the API key as a bearer token'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – API request using the API key as a bearer token
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the bearer token is sent as an HTTP header. To see the
    header in Postman, click on the **Headers** tab and then unhide the hidden headers,
    and you''ll see the **Authorization** header with your API key as the bearer token
    value, as demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Authorization header with the API key as a bearer token'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Authorization header with the API key as a bearer token
  prefs: []
  type: TYPE_NORMAL
- en: While we're talking about authorization and HTTP headers, it's also important
    to note that if your user account is associated with multiple organizations, you'll
    also need to provide an organization ID to associate your API requests with the
    organization you'd like the requests to be billed to.
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple organizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To associate API requests with a specific organization, you'll include an **OpenAI-Organization
    HTTP header** with the organization ID for the organization you want to associate
    your requests with. This is only required when your user account is associated
    with multiple organizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the OpenAI-Organization header in Postman, scroll to the bottom of the
    list of existing headers and add a new one with the name **OpenAI-Organization**
    and make the value an organization ID that your account is associated with. Better
    yet, add a new environment in Postman named **OPENAI_ORGANIZATION_ID** and add
    **{{OPENAI_ORGANIZATION_ID}}** as the value. As a reminder, you can find your
    organization ID on the account settings page in the OpenAI developer console,
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Finding your organization ID'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – Finding your organization ID
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''ve added your organization ID value to the OpenAI-Organization header
    in Postman, you''ll see it in the headers list, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Using the OpenAI-Organization HTTP header'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Using the OpenAI-Organization HTTP header
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the rest of this book, we'll be using Postman to illustrate and test
    API calls. But before we move on, let's take a look at making an authenticated
    API call with CURL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that CURL is a command-line tool. So, it doesn''t have a graphical user
    interface like Postman. With CURL, HTTP headers are passed as command-line parameters.
    The following is an example of a CURL command for calling the List Engines endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After replacing the `{your-api-key}` placeholder and the `{your-organization-id}`
    placeholder, this command will return something like the results shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Using CURL to call the List Engines endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – Using CURL to call the List Engines endpoint
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to make authenticated calls to the OpenAI API, let's take
    a minute to talk about JSON, the data-interchange format that the OpenAI API uses.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll do a quick introduction to JSON. JSON is a popular data-interchange
    format that is lightweight, easy for machines to parse, and easy for humans to
    read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON syntax is based on a subset of the JavaScript programming language
    and it defines two data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of name/value pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ordered list of values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two data structures are supported in one way or another by virtually all
    modern programming languages. So, although the JSON syntax is based on a subset
    of JavaScript, it can be easily used with other languages as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two data structures in JSON are defined as either an object or an array.
    An object begins with a left brace and ends with a right brace. An empty object
    would look like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'An object can contain a set of name/value pairs, referred to as elements. Elements
    in an object don''t need to be in any particular order and the value can be a
    string (enclosed in double quotes), a number, true or false, null, another object,
    or an array. Element names and values are separated by a colon, and elements themselves
    are separated by a comma. The following code block is an example of a JSON object
    from an OpenAI API response. You''ll notice that it starts and ends with braces
    and contains different elements with names and values. Notice that the value of
    the `"choices"` element contains a value that begins with a left bracket and ends
    with a right bracket – that is an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: An array is an ordered collection of values. The values could be a collection
    of strings, numbers, true or false values, null values, objects, or other arrays.
    An array always begins with a left bracket and ends with a right bracket and the
    values are separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example object, the value for the `"choices"` element is an
    array with one object in it. That object contains elements (`text`, `index`, `logprobs`,
    `finish_reason`) with values. So, objects and arrays can be nested.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to note about JSON is that the formatting of the text, things
    such as spaces, tabs, and line returns, is done for human readability but is not
    required by machines. So, as long as the syntax is valid, it's useable in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following two JSON objects are the same and both are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously in this section, the OpenAI API uses JSON to send and
    receive data between the client and server. The introduction in this section should
    be enough to begin working with the OpenAI API, but to learn more about JSON,
    you can also visit [https://www.json.org/](https://www.json.org/).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you've learned everything you need to begin using the main OpenAI
    API endpoint – the Completions endpoint. So, let's dive into that next.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Completions endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're working with the OpenAI API, most of what you'll be doing will probably
    involve using the Completions endpoint. This is the endpoint you send prompts
    to. In addition to submitting your prompt, you can also include values to influence
    how the completion is generated, like the setting in the Playground.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Completions endpoint is a little more involved than using the List
    Engines endpoint that we looked at in the last section, *Introducing JSON*. This
    is because the Completions endpoint uses the HTTP POST method and requires a JSON
    object as the body. Technically, the JSON body could just be an empty object (just
    a left and right curly brace, like `{})`, but minimally, you''ll want to include
    at least the `prompt` element with the value set to your `prompt` string, something
    like the following JSON example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is a simple one but here''s how we''d submit it using
    Postman. Assuming the authorization was set up as discussed in the previous section,
    there are five steps to completing to call the Completions endpoint from Postman.
    These steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the request type to **POST**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter https://api.openai.com/v1/engines/davinci/completions for the endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the body to **raw**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **JSON** as the body content type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `{"prompt": "Once upon a time"}` as the JSON body text.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The labels on the following screenshot show where each of the steps is completed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Postman settings for the Completions endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – Postman settings for the Completions endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking the **Send** button, we get a response from the Completions
    endpoint, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Postman response from the Completions endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – Postman response from the Completions endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Postman will display the JSON response using the **Pretty** setting,
    which makes it friendly for human viewing. But if you toggle on the **Raw** setting,
    you''ll see how the response is actually sent, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Postman response from the Completions endpoint – Raw'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19 – Postman response from the Completions endpoint – Raw
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example was a simple one with just one request parameter – the
    prompt. However, the endpoint accepts a number of additional parameters that are
    similar to the settings in the Playground. To include additional parameters with
    the request, the parameters are included as elements in the JSON body object.
    For example, to send the prompt and limit the number of tokens returned (like
    the response length setting does in the Playground), we can include the `max_tokens`
    parameter, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Postman response from the Completions endpoint with max_tokens'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_020.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.20 – Postman response from the Completions endpoint with max_tokens
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in order to include the `max_tokens` parameter and value, a new
    `max_tokens` element is added to the JSON body object and separated from the `"prompt"`
    element by a comma. Additional parameters would be added the same way.
  prefs: []
  type: TYPE_NORMAL
- en: A list of all the available parameters can be found at [https://beta.openai.com/docs/api-reference/create-completion](https://beta.openai.com/docs/api-reference/create-completion)
    and we won't cover them all here. However, most of them have an equivalent setting
    in the Playground that we covered in [*Chapter 3*](B16854_03_ePub_AM.xhtml#_idTextAnchor050),
    *Working with the OpenAI Playground*, so they'll be familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we move on, let''s take a look at another example, one that you
    can''t do from the Playground. In this example, we''re going to submit multiple
    prompts simultaneously and get back a completion for each. We''ll use the following
    JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the value for the `"prompt"` element is a JSON array with two values,
    `"The capital of California is:"`, and `"Once upon a time"`. By sending an array
    of prompts, the Completions endpoint will send back completions for each prompt,
    as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Sending multiple prompts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.21 – Sending multiple prompts
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaway from this example is that there are things you can do with
    the API that you can't do in the Playground. So, understanding how to work with
    the OpenAI API enables you to go beyond what you can do in the Playground.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of something you can do from the API but not the Playground
    is semantic searching. Let's look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Semantic Search endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B16854_02_ePub_AM.xhtml#_idTextAnchor038), *GPT-3 Applications
    and Use Cases*, we discussed semantic search. By way of a review, semantic search
    lets you perform a Google-like search over a list of provided documents. A query
    (a word, phrase, question, or statement) is compared to the contents of documents
    to determine whether semantic similarities exist. The result is a ranking, or
    score, for each document. The score is usually between 0 and 300 but can sometimes
    go higher. A higher score, above 200, typically means the document is semantically
    similar to the query.
  prefs: []
  type: TYPE_NORMAL
- en: To perform a semantic search using the API, you'll make a POST request to the
    Semantic Search endpoint. Like the Create Completions endpoint, you'll also include
    a JSON object in the request body. The JSON body object has two elements – the
    documents element and the query element. The documents element is an array of
    documents to be searched, and each item in the array is a string that represents
    a document. Alternatively, a document can be provided in a pre-uploaded file that
    can be referenced in the request. In [*Chapter 9*](B16854_09_ePub_AM.xhtml#_idTextAnchor172),
    *Building a GPT-3 Powered Question-Answering App*, we'll look at using files in
    detail. For now, however, we'll focus on providing documents as an array with
    the endpoint request.
  prefs: []
  type: TYPE_NORMAL
- en: A document could be a single word, sentence, paragraph, or longer text. The
    value of the query element is a string containing the search word or phrase that
    will be searched against the documents. This might be something like a question
    or a statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, a semantic search ranks a query based on how semantically similar it
    is to one or more documents. So, it''s not necessarily a search for similar words.
    For example, the following JSON object provides a list of vehicles (plane, boat,
    spaceship, or car) as the documents and the query `"A vehicle with wheels"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at what the results would look like from the previous JSON.
    We''ll use Postman. Remember that all of the OpenAI API endpoints require authorization,
    so, in Postman, we first make sure that the proper authorization settings are
    in place. From there, the steps are the same as making a request to the Completions
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the request type to **POST**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the **URI** endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the body to **raw**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **JSON** as the body content type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the JSON body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Semantic Search endpoint URI is `https://api.openai.com/v1/engines/{engine_id}/search`,
    where `{engine_id}` is replaced by a valid engine ID (such as `davinci` or `ada`).
    After setting up and submitting the API call in Postman, you should see results
    like those in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Semantic Search results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_022.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.22 – Semantic Search results
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON object returned by the Semantic Search endpoint contains three elements:
    an object, data, and an engine. The value of the data element is a JSON array
    of results – one item for each document. Recall from our earlier introduction
    to JSON that items in an array are ordered, meaning that each item can be referenced
    by a number, the first one starting with zero. So, in our example, the following
    values would apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` = plane'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` = boat'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` = spaceship'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` = car'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knowing that each document is associated with a numeric value, when you look
    at the following results returned from the search API, you can see that document
    `3` (car) got the highest score and therefore represents the document that is
    most semantically similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The document number rather than the document itself is included in the data
    array because the document itself might be a long string of text and using the
    document number is more efficient. So, you will need to match the results returned
    to the documents sent. But that's relatively straightforward when you're working
    with code – and that's exactly what we'll get started on in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at working with the OpenAI API. We started with an
    introduction/review of what an API is and then we became familiar with the basics
    of the HTTP protocol. We reviewed the OpenAI API endpoints and covered how to
    access the API using basic authentication with an OpenAI API key and how to authenticate
    for an account with access to multiple organizations. From there, we learned about
    the JSON data-interchange format before learning how to make API calls to the
    Completions endpoint, the Engines endpoint, and the Semantic Search endpoint using
    Postman.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll put the knowledge acquired in this chapter to work
    and dive into using code to call the API.
  prefs: []
  type: TYPE_NORMAL
