- en: '*Chapter 4*: Working with the OpenAI API'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：使用OpenAI API'
- en: Up to this point, everything we've done with GPT-3 has been through the Playground.
    While the Playground is a great place for learning and testing, when you're building
    applications that incorporate GPT-3, you'll also need to understand how to use
    the OpenAI API directly. So, in this chapter, we'll look at using the OpenAI API
    directly by making HTTP requests. We'll start with a general introduction to APIs
    and the HTTP protocol. Then we'll look at a couple of developer tools for working
    with API requests and the JSON data-interchange format.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们用GPT-3所做的一切都是通过Playground完成的。虽然Playground是学习和测试的好地方，但是当你构建包含GPT-3的应用程序时，你也需要理解如何直接使用OpenAI
    API。因此，在本章中，我们将通过发出HTTP请求来直接使用OpenAI API。我们将首先对API和HTTP协议进行一般介绍。然后我们将看一下一些用于处理API请求和JSON数据交换格式的开发人员工具。
- en: 'The topics we''ll cover are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的主题如下：
- en: Understanding APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解API
- en: Getting familiar with HTTP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉HTTP
- en: Reviewing the OpenAI API endpoints
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看OpenAI API端点
- en: Introducing CURL and Postman
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍CURL和Postman
- en: Understanding API authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解API身份验证
- en: Making an authenticated request to the OpenAI API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出对OpenAI API的经过身份验证的请求
- en: Introducing JSON
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍JSON
- en: Using the Completions endpoint
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Completions端点
- en: Using the Semantic Search endpoint
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用语义搜索端点
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires that you have access to the **OpenAI API**. You can request
    access by visiting [https://openapi.com](https://openapi.com).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要你能够访问**OpenAI API**。你可以通过访问[https://openapi.com](https://openapi.com)来请求访问权限。
- en: Understanding APIs
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解API
- en: The acronym **API** stands for **Application Programming Interface**. APIs allow
    software to communicate between systems and interchange data – to share computer
    system resources and software functionality. Because functionality can be shared,
    they also enable code reuse. This generally improves the quality of systems while
    also reducing development efforts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写**API**代表**应用程序编程接口**。API允许软件在系统之间进行通信和交换数据，共享计算机系统资源和软件功能。由于功能可以共享，它们也可以实现代码重用。这通常提高了系统的质量，同时也降低了开发工作量。
- en: Web-based APIs are exposed over the internet using HTTP, the same protocol you
    use when you visit a URL in a web browser. So, using a web-based API is very much
    like using a website. For example, when you use an API, you make requests to a
    **Uniform Resource Locator** (**URL**), just like you do when you access a website.
    The URL provides the reference for a resource, data, or functionality provided
    by the API.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Web-based APIs是通过HTTP在互联网上公开的，这与你在网络浏览器中访问URL时使用的协议相同。因此，使用基于Web的API非常类似于使用网站。例如，当你使用API时，你会向**统一资源定位符**（**URL**）发出请求，就像你访问网站时所做的那样。URL提供了API提供的资源、数据或功能的参考。
- en: Like a website, each API is a collection of one or more URLs, which are also
    referred to as endpoints. Each endpoint provides access to a specific resource
    or functionality. Some endpoints might take input data and perform a task, while
    others might simply return data. The format of the input and the output data depends
    on the API. But most APIs use common data interchange formats, such as **JavaScript
    Object Notation** (**JSON**), or just plain text. We'll talk about the JSON data-interchange
    format later because that's what the OpenAI API uses.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像网站一样，每个API都是一个或多个URL的集合，也被称为端点。每个端点提供对特定资源或功能的访问。一些端点可能接受输入数据并执行任务，而其他端点可能只是返回数据。输入和输出数据的格式取决于API。但是，大多数API使用常见的数据交换格式，如**JavaScript对象表示**（**JSON**）或纯文本。我们稍后会讨论JSON数据交换格式，因为这是OpenAI
    API所使用的格式。
- en: 'Since web-based APIs are accessible using HTTP and work with common data formats,
    they don''t depend on any specific programming language, meaning just about any
    programing language or development tool that can make an HTTP request can interact
    with an HTTP API. In fact, you can even use a web browser to interact with some
    web-based APIs. For example, if you open [http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)
    in your web browser, you''ll see a response that provides data about the number
    of humans that are currently in space. The results aren''t formatted nicely because
    they''re intended for machine use, not human consumption, but we can see the results
    in a browser because it''s using the same web protocol that websites use, as seen
    in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于 web 的 API 可以使用 HTTP 访问并使用常见数据格式，它们不依赖于任何特定的编程语言，这意味着几乎任何可以发出 HTTP 请求的编程语言或开发工具都可以与
    HTTP API 互动。实际上，甚至可以使用 web 浏览器与一些基于 web 的 API 互动。例如，如果在您的 web 浏览器中打开 [http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)，您将看到提供有关目前在太空的人数的数据的响应。结果并未以美观的格式呈现，因为它们是为机器使用而不是人类消费而设计的，但我们可以在浏览器中看到结果，因为它使用了网站使用的相同的
    web 协议，如下面的屏幕截图中所示：
- en: '![Figure 4.1 – Open-Notify API – JSON response'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – Open-Notify API – JSON 响应'
- en: '](img/B16854_04_001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_001.jpg)'
- en: Figure 4.1 – Open-Notify API – JSON response
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – Open-Notify API – JSON 响应
- en: But even though HTTP APIs aren't language-specific programming, many API publishers
    provide a **Software Developer Kit** (**SDK**) or a software library to make using
    the API simpler to work with in a specific language. For example, OpenAI provides
    Python bindings (libraries) that simplify use of the OpenAI API in the Python
    programming language. These tools are essentially wrappers for the API that reduce
    the code you might need to write if you are using the API without the library.
    We'll talk more about some of the available libraries for the OpenAI API later,
    in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098), *Calling the OpenAI
    API in Code*. For now, the important thing to note is that it doesn't matter what
    programming language you choose as long as it's one that can make HTTP requests.
    Also, SDKs or libraries can be helpful, but they are not essential for using the
    API. However, what is essential is a basic understanding of the HTTP protocol.
    So, we'll talk about that next.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 HTTP API 不是针对特定语言编程的，但许多 API 发布者提供了一个**软件开发工具包**（**SDK**）或一个软件库，以便在特定语言中更简单地使用
    API。例如，OpenAI 提供了简化在 Python 编程语言中使用 OpenAI API 的 Python 绑定（库）。这些工具本质上是 API 的包装器，如果没有库，你可能需要编写的代码会减少。稍后我们会在
    [*第 5 章*](B16854_05_ePub_AM.xhtml#_idTextAnchor098) 中更详细地讨论可用于 OpenAI API 的一些库，*在代码中调用
    OpenAI API*。目前，需要注意的重要事项是，只要选择能够发出 HTTP 请求的编程语言即可，编程语言并不重要。此外，SDK 或库可以提供帮助，但并不是使用
    API 的必需条件。然而，必不可少的是对 HTTP 协议的基本理解。因此，我们接下来会讨论这个问题。
- en: Getting familiar with HTTP
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 HTTP
- en: Because APIs are designed to be used in code, in order to work with them, you
    do need to know a bit more about the HTTP protocol than you do for just accessing
    websites. So, in this section, you'll learn some HTTP basics.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 API 设计用于在代码中使用，为了与其一起工作，你确实需要对 HTTP 协议有更多了解，而不仅仅是访问网站所需的知识。因此，在本节中，你将学习一些
    HTTP 基础知识。
- en: For starters, HTTP is a request-response protocol. So, a client (the requesting
    system) makes a request to a server (the receiving system), which then responds
    to the client. The client references the server and the resource being requested
    using a **Uniform Resource Identifier** (**URI**).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，HTTP 是一种请求-响应协议。因此，客户端（请求系统）向服务器（接收系统）发出请求，服务器然后响应客户端。客户端使用**统一资源标识符**（**URI**）来引用服务器和所请求的资源。
- en: Uniform resource identifiers
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统一资源标识符
- en: An HTTP URI provides the details needed to make an HTTP request to a specific
    server for a specific resource. To illustrate, let's break down the [http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)
    endpoint that we looked at previously in the *Understanding APIs* section. The
    endpoint begins with a reference to the protocol used. In our example, this is
    `http://`. For web-based APIs, this will always either be HTTP or HTTPS. When
    HTTPS is used, this is an indicator that requests and responses between the client
    and server will be encrypted. The second part of the URI ([api.open-notify.org](http://api.open-notify.org)
    in this example), is a reference to the server where the resource is located.
    Following the server name is a reference to the resource location on the server.
    Some URIs will also include parameters and values. These can be used to provide
    additional details or variable data that can be used by the server to process
    the request.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP URI提供了需要向特定服务器请求特定资源的HTTP请求所需的详细信息。为了举例说明，让我们分解前面在*理解API*部分中提到的[http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)端点。端点始于对所使用协议的引用。在我们的示例中，这是
    `http://`。对于基于Web的API，这将始终是HTTP或HTTPS。当使用HTTPS时，这是一个指示请求和响应之间将被加密的指示。URI的第二部分（在本例中为[api.open-notify.org](http://api.open-notify.org)）是资源所在的服务器的引用。在服务器名称之后是对服务器上资源位置的引用。有些URI还会包括参数和值。这些参数和值可用于提供服务器处理请求的附加细节或可变数据。
- en: In addition to the URI, the HTTP protocol also supports different request types,
    called **HTTP methods**, which provide additional information about the request
    being made.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除URI之外，HTTP协议还支持称为**HTTP方法**的不同请求类型，它们提供有关正在进行的请求的附加信息。
- en: HTTP methods
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP方法
- en: HTTP methods let the server perform different operations using the same URL.
    There are six different HTTP methods, but not all URL endpoints support all of
    the methods. The two most common HTTP methods are `GET` and `POST`. The GET method
    tells the server that the client wants to retrieve (or get) information, and a
    POST method tells the server that the client is sending data. So, if an endpoint
    is used for retrieving data, the GET method would normally be used. However, if
    the endpoint expects a data input, the POST method might be used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP方法允许服务器使用相同的URL执行不同的操作。有六种不同的HTTP方法，但并非所有URL端点都支持所有方法。最常见的两种HTTP方法是`GET`和`POST`。GET方法告诉服务器客户端要检索（或获取）信息，而POST方法告诉服务器客户端正在发送数据。因此，如果端点用于检索数据，通常会使用GET方法。但是，如果端点预期数据输入，可能会使用POST方法。
- en: The HTTP body
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP正文
- en: The body of an HTTP request or response contains the main data payload. In the
    case of a request, the body contains the data that will be sent to the server.
    In the case of the response, the body contains the data being sent back from the
    server. The data sent in the HTTP body could be any text-based payload. Commonly
    used formats are JSON, XML, and plain text. So, you'll also need to know the format
    of the data you'll be sending and receiving from the API you're working with.
    This is typically found in the API documentation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求或响应的正文包含主要数据负载。在请求的情况下，正文包含将被发送到服务器的数据。在响应的情况下，正文包含从服务器返回的数据。在HTTP正文中发送的数据可以是任何基于文本的有效载荷。常用的格式有JSON、XML和纯文本。因此，您还需要知道您将与之交互的API中发送和接收数据的格式。这通常可以在API文档中找到。
- en: HTTP headers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP头
- en: The HTTP body isn't the only way to send/receive data. You can also include
    data as part of the URL, or as an HTTP header. HTTP headers are key/value pairs
    that can be used to send/receive values between the client and server. While HTTP
    headers can be used for a variety of reasons, they usually define metadata, or
    data that provides details about the request. For example, an HTTP header named
    **Content-Type** is used to tell the server what type of data is being passed
    in the body, and an **Authorization** header can be used to send authentication
    details, such as a username and password.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP正文不是发送/接收数据的唯一方式。您还可以将数据作为URL的一部分或作为HTTP头包含在内。HTTP头是键/值对，可用于在客户端和服务器之间发送/接收值。虽然HTTP头可以用于各种原因，但它们通常定义元数据或提供有关请求的详细信息的数据。例如，名为**Content-Type**的HTTP头用于告诉服务器传递正文中的数据类型，而**Authorization**头可用于发送认证详细信息，如用户名和密码。
- en: HTTP response status codes
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP响应状态码
- en: When a client makes a valid request to a valid server, the server will always
    include an HTTP response status code with the response. The status code is a numeric
    value that provides a high-level outcome status of the response. For example,
    200 indicates a successful response, while 500 indicates an internal server error.
    For a full list of the different status codes, you can visit [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).
    While it's not important to memorize the different status codes, it's good to
    be familiar with them and to know where to look up what a code means. This is
    especially true when you're having issues calling an API endpoint because the
    status codes are very helpful for debugging problems.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向有效服务器发出有效请求时，服务器将始终在响应中包含一个 HTTP 响应状态代码。状态代码是一个提供响应的高级结果状态的数字值。例如，200 表示成功的响应，而
    500 表示内部服务器错误。有关不同状态代码的完整列表，您可以访问 [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)。虽然记住不同的状态代码并不重要，但熟悉它们并知道在哪里查找代码的含义是很好的。当您调用
    API 端点时遇到问题时，状态代码非常有助于调试问题。
- en: This section just provided a very high-level overview of HTTP, but a high-level
    understanding is all you need for working with the OpenAI API and most other web-based
    APIs for that matter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本节只是对 HTTP 提供了一个非常高层次的概述，但对于使用 OpenAI API 和大多数其他基于 Web 的 API，高层次的理解就足够了。
- en: Reviewing the OpenAI API endpoints
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看 OpenAI API 端点
- en: Everything that we've looked at doing through the Playground can also be done
    via the OpenAI API – and then some. In fact, the Playground is just a web interface
    that calls the OpenAI API. It is simply exposing functionality that the API provides
    using a graphical interface. So, in this section, we'll review the OpenAI functionality
    that's available through the API endpoints. You'll be familiar with the functionality
    because you've used it through the Playground, but after this section, you'll
    know how to access specific functionality in code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Playground 所做的一切也可以通过 OpenAI API 来完成 - 甚至更多。实际上，Playground 只是调用 OpenAI API
    的 Web 接口。它只是使用图形界面暴露了 API 提供的功能。因此，在本节中，我们将审查通过 API 端点可用的 OpenAI 功能。您会对功能很熟悉，因为您已经通过
    Playground 使用了它，但在本节之后，您将知道如何在代码中访问特定的功能。
- en: 'Using the OpenAI API, you can do the following through the available endpoints:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenAI API，您可以通过可用的端点执行以下操作：
- en: Create completions
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建完成
- en: List available engines
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出可用引擎
- en: Get engine details
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取引擎详情
- en: Perform semantic searches
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行语义搜索
- en: All of the OpenAI API endpoints require authentication. So, they can't just
    be called with a browser, like the Open-Notify API that we looked at earlier.
    But we'll hold off on talking about authentication just yet and review each of
    the available endpoints.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 OpenAI API 端点都需要身份验证。因此，它们不能像我们之前查看的 Open-Notify API 那样，只需使用浏览器即可调用。但我们暂时不讨论身份验证，而是审查每个可用的端点。
- en: List Engines
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出引擎
- en: The List Engines endpoint is a metadata API, meaning it provides data about
    the system itself. Specifically, a list of the available engines along with some
    basic information about each engine. OpenAI is actively working on new engines
    and updating existing ones, so the List Engines endpoint will provide a list of
    currently available engines.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列出引擎端点是一个元数据 API，意味着它提供有关系统本身的数据。具体来说，它提供了一份可用引擎的列表，以及每个引擎的一些基本信息。OpenAI 正在积极开发新引擎并更新现有引擎，因此列出引擎端点将提供当前可用引擎的列表。
- en: 'The List Engines endpoint uses the HTTP GET method and doesn''t require any
    request parameters. The following is the HTTP method (GET) and URI for the List
    Engines endpoint:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列出引擎端点使用 HTTP GET 方法，不需要任何请求参数。以下是列出引擎端点的 HTTP 方法（GET）和 URI：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next is the Retrieve Engine endpoint!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是检索引擎端点！
- en: Retrieve Engine
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索引擎
- en: The Retrieve Engine endpoint is also a metadata API. It returns details about
    a specific engine. Like the List Engines endpoint, the Retrieve Engine endpoint
    also uses the HTTP GET method and requires that an engine ID is included as part
    of the URI path. The possible engine ID values can be retrieved from the List
    Engines endpoint.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 检索引擎端点也是一个元数据 API。它返回关于特定引擎的详细信息。与列出引擎端点一样，检索引擎端点也使用 HTTP GET 方法，并且要求将引擎 ID
    包含在 URI 路径中。可以从列出引擎端点检索到可能的引擎 ID 值。
- en: 'The Retrieve Engine endpoint uses the HTTP GET method and the following URI
    with one parameter, the engine ID:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Retrieve Engine 端点使用 HTTP GET 方法和以下 URI，其中一个参数是引擎 ID：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next is the Create Completions endpoint – the one you'll likely be using the
    most.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 Create Completions 端点 - 你可能会经常使用它。
- en: Create Completions
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Create Completions
- en: The Create Completions endpoint is the endpoint you'll be using most of the
    time. This is the endpoint that takes in a prompt and returns the completion results.
    This endpoint uses the HTTP POST method and requires an engine ID as part of the
    URI path. The Create Completions endpoint also accepts a number of additional
    parameters as part of the HTTP body. We'll discuss those parameters later in this
    chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Create Completions 端点是你最常使用的端点。这个端点接收一个提示并返回完成结果。这个端点使用 HTTP POST 方法，并且要求引擎
    ID 作为 URI 路径的一部分。Create Completions 端点还接受许多其他参数作为 HTTP 正文的一部分。我们将在本章后面讨论这些参数。
- en: 'The Completions endpoint also uses the POST method and requires an engine ID
    as a URI parameter:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Completions 端点也使用 POST 方法，并且需要引擎 ID 作为 URI 参数：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's also worth noting that there is an experimental Create Completions endpoint
    for streaming results to a browser. It is called using the HTTP GET method and
    parameters are passed in the URI. You can learn more about this endpoint by visiting
    [https://beta.openai.com/docs/api-reference/create-completion-via-get](https://beta.openai.com/docs/api-reference/create-completion-via-get).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，有一个实验性的 Create Completions 端点，用于将结果流式传输到浏览器。它使用 HTTP GET 方法，并且参数在 URI
    中传递。您可以通过访问[https://beta.openai.com/docs/api-reference/create-completion-via-get](https://beta.openai.com/docs/api-reference/create-completion-via-get)了解有关此端点的更多信息。
- en: Semantic Search
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Semantic Search
- en: The Semantic Search endpoint can be used to perform a semantic search over a
    list of documents. A semantic search compares a search term to the contents of
    a document to identify documents that are semantically similar. The documents
    to be searched are passed to the endpoint as part of the HTTP body and up to 200
    documents can be included. This endpoint uses the HTTP POST method and requires
    an engine ID to be passed as part of the endpoint URI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Semantic Search 端点可以用于在文档列表上执行语义搜索。语义搜索将搜索词与文档内容进行比较，以识别语义上相似的文档。要搜索的文档作为 HTTP
    正文的一部分传递到端点中，最多可以包含200个文档。此端点使用 HTTP POST 方法，并要求将引擎 ID 作为端点 URI 的一部分传递。
- en: 'The Semantic Search endpoint uses the POST method and requires an engine ID
    as a URI parameter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Semantic Search 端点使用 POST 方法，并且需要引擎 ID 作为 URI 参数：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As web-based APIs go, the OpenAI API is relatively simple to work with, but
    before we give it a go, let's discuss a couple of development tools we can use
    to start testing the API.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就基于 Web 的 API 而言，OpenAI API 相对简单易用，但在我们开始测试该 API 之前，让我们讨论一些可以用来开始测试 API 的开发工具。
- en: Introducing CURL and Postman
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 CURL 和 Postman
- en: In this section, we'll look at a couple of developer tools for working with
    APIs. As we've discussed, APIs are designed to be used in code. However, during
    the development process, you'll often want to call an API endpoint without writing
    code to get familiar with the functionality or for testing. To do that, there
    are a number of developer tools available. Two of the most popular developer tools
    for working with APIs are CURL and Postman.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些用于使用 API 的开发人员工具。如我们所讨论的，API 旨在用于代码中。但是，在开发过程中，您常常希望调用 API 端点，而不编写代码来熟悉功能或进行测试。为此，有许多开发人员工具可用。使用
    API 的最受欢迎的两个开发人员工具是 CURL 和 Postman。
- en: CURL
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CURL
- en: CURL is a popular command-line tool for making HTTP requests. It's been around
    since 1998, so it's very mature and widely used. Many API publishers, including
    OpenAI, provide API examples, using CURL syntax in their documentation. The following
    screenshot shows an example of the CURL syntax used in the OpenAI API docs. So,
    even if CURL isn't the tool you decide to use in the long run, it's helpful to
    be familiar with it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CURL 是一个流行的命令行工具，用于发起 HTTP 请求。它已经存在了20多年，所以非常成熟和广泛使用。许多 API 发布者，包括 OpenAI，在他们的文档中使用
    CURL 语法提供 API 示例。下面的截屏显示了 OpenAI API 文档中使用的 CURL 语法示例。因此，即使 CURL 不是你长期决定使用的工具，熟悉它仍然有帮助。
- en: 'The following screenshot shows CURL syntax in the OpenAI API documentation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截屏显示了 OpenAI API 文档中的 CURL 语法：
- en: '![Figure 4.2 – Curl command in the OpenAI API docs'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 - OpenAI API 文档中的 Curl 命令'
- en: '](img/B16854_04_002.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_002.jpg)'
- en: Figure 4.2 – Curl command in the OpenAI API docs
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - OpenAI API 文档中的 Curl 命令
- en: Curl is available for Linux, Mac, and Windows and comes installed by default
    on most Linux and Mac machines as well as on Windows computers (running Windows
    10 Build 1707 or later).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: CURL 可用于 Linux、Mac 和 Windows，并且默认情况下安装在大多数 Linux 和 Mac 机器上以及运行 Windows 10 Build
    1707或更高版本的 Windows 计算机上。
- en: Important note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To check your version of Windows, press *Windows+R* on your keyboard to open
    the **Run** dialog box. Then, type in *winver* (without the quotes) and click
    **OK**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的 Windows 版本，请在键盘上按下*Windows+R*来打开**运行**对话框。然后，输入*winver*（不带引号）并点击**确定**。
- en: 'You can verify whether CURL is installed from the command line. On Linux and
    Mac, the command line is accessible using the terminal application. On Windows,
    open the command prompt to access the command line. At the command line, you can
    enter the `curl --help` command to confirm that CURL is installed. If CURL is
    installed, you should see something like what''s shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过命令行验证是否已安装 CURL。在 Linux 和 Mac 上，可以使用终端应用程序访问命令行。在 Windows 上，打开命令提示符以访问命令行。在命令行中，你可以输入
    `curl --help` 命令来确认是否已安装 CURL。如果 CURL 已安装，你应该会看到类似以下屏幕截图的内容：
- en: '![Figure 4.3 – Curl Help command'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – Curl 帮助命令'
- en: '](img/B16854_04_003.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_003.jpg)'
- en: Figure 4.3 – Curl Help command
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – Curl 帮助命令
- en: If you don't have CURL installed, you can download it from the official CURL
    site at [https://curl.se/download.html](https://curl.se/download.html).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尚未安装 CURL，可以从官方 CURL 网站下载，网址为[https://curl.se/download.html](https://curl.se/download.html)。
- en: There are entire books on using CURL, so we're only going to scratch the surface
    of its functionality here. We'll be talking about CURL for working with API calls,
    but it's not just for working with APIs – it can be used to make any HTTP request.
    For example, if you entered `curl` [https://dabblelab.com](https://dabblelab.com)
    at the command prompt and hit the *Return* key, CURL would fetch the [dabblelab.com](http://dabblelab.com)
    home page. However, CURL is not a browser, so what you'll see is raw HTML code
    rather than a nicely formatted web page as you'd see if you were using your browser.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用 CURL 的整本书籍，因此我们这里只是简单介绍其功能。我们将讨论使用 CURL 处理 API 调用，但不仅限于处理 API – 它可以用来进行任何
    HTTP 请求。例如，如果你在命令提示符下输入 `curl` [https://dabblelab.com](https://dabblelab.com)
    并按下*回车*键，CURL 将抓取 [dabblelab.com](http://dabblelab.com) 的主页。但是，CURL 不是浏览器，因此你所看到的是原始的
    HTML 代码，而不是像使用浏览器时看到的漂亮格式的网页。
- en: As we take a closer look at the OpenAI API, we'll look at making different API
    calls with CURL. But before we do that, let's take a look at Postman, an alternative
    to using CURL.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更详细地研究 OpenAI API 时，将使用 CURL 进行不同的 API 调用。但在此之前，让我们先看看 Postman，这是使用 CURL
    的替代方案。
- en: Postman
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Postman
- en: Postman is another developer tool for working with APIs. Unlike CURL, Postman
    has a graphical user interface. So, if the command line isn't your thing, you'll
    probably prefer Postman. You can use Postman from your browser, or you can download
    a version for Linux, Mac, or Windows. For our examples, we'll be using the web
    version because there is no software to install; you just need to sign up for
    a free account at [https://postman.com](https://postman.com).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 是另一个用于处理 API 的开发者工具。与 CURL 不同，Postman 具有图形用户界面。因此，如果你不太擅长命令行，可能更喜欢使用
    Postman。你可以从浏览器中使用 Postman，或者可以下载适用于 Linux、Mac 或 Windows 的版本。在我们的示例中，我们将使用网络版本，因为无需安装任何软件；你只需在[https://postman.com](https://postman.com)注册一个免费账户。
- en: 'The following screenshot shows the Postman home page. You just need to complete
    the signup process to start using Postman:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了 Postman 的主页。你只需要完成注册过程就能开始使用 Postman：
- en: '![Figure 4.4 – Postman home page'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – Postman 主页'
- en: '](img/B16854_04_004.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_004.jpg)'
- en: Figure 4.4 – Postman home page
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – Postman 主页
- en: 'After signing up, you''ll be presented with a short onboarding process. Complete
    the onboarding process and when you''re done, you should see a screen similar
    to the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注册后，你将进入一个简短的入门流程。完成入门流程后，你应该看到类似以下屏幕截图的界面：
- en: '![Figure 4.5 – Postman welcome screen'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – Postman 欢迎界面'
- en: '](img/B16854_04_005.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_005.jpg)'
- en: Figure 4.5 – Postman welcome screen
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – Postman 欢迎界面
- en: Like CURL, there is a lot to Postman and we're only going to look at a small
    subset of what Postman does. But at its core, Postman is a tool for calling API
    endpoints and inspecting the results the API endpoint returns. We will start with
    a quick walk-through that will show you how to make your first API request using
    Postman.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CURL 类似，Postman 有很多功能，我们只会查看 Postman 的一小部分。但是在其核心，Postman 是一个用于调用 API 端点并检查
    API 端点返回结果的工具。我们将从一个快速的演示开始，向您展示如何使用 Postman 发出您的第一个 API 请求。
- en: Making a request with Postman
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Postman 发送请求
- en: 'To get started with Postman, let''s make a request to the Open-Notify API endpoint
    that we looked at previously in our browser. To do that, complete the following
    steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Postman，请向 Open-Notify API 端点发出我们先前在浏览器中查看过的请求。要做到这一点，请完成以下步骤：
- en: After logging in to [Postman.com](http://Postman.com), click the **Create New**
    link. If you're prompted to download the Desktop agent, click the **Skip for now**
    button. This will bring you to your workspace, which will look something like
    the following screenshot:![Figure 4.6 – My Workspace
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到[Postman.com](http://Postman.com)后，单击**创建新建**链接。如果提示下载桌面代理，请单击**现在跳过**按钮。这将带您进入您的工作区，它看起来类似以下截图:![图
    4.6 – 我的工作空间
- en: '](img/B16854_04_006.jpg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_04_006.jpg)'
- en: Figure 4.6 – My Workspace
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.6 – 我的工作空间
- en: Note that the right side of the workspace is a tab interface that, by default,
    will have the **Overview** tab open. Just to the right, you'll see a plus sign
    that can be used to open a new tab.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，工作区的右侧是一个选项卡界面，默认情况下将打开**概述**选项卡。在右侧，您会看到一个加号，可用于打开一个新选项卡。
- en: 'Click the plus sign to open a new tab, enter the request URL ([http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)),
    and then click the **Send** button. You should see results similar to the following
    screenshot:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '单击加号以打开一个新选项卡，输入请求 URL（[http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)），然后单击**发送**按钮。您应该会看到类似以下截图的结果:'
- en: '![Figure 4.7 – Postman request results'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – Postman 请求结果'
- en: '](img/B16854_04_007.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_007.jpg)'
- en: Figure 4.7 – Postman request results
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – Postman 请求结果
- en: Notice how the JSON results in *Figure 4.7* are formatted in a way that's easy
    to read. This is just one of many helpful things Postman does for us. As we delve
    further into the OpenAI API, we'll also cover more Postman features. But let's
    keep moving and discuss how to call the OpenAI API since it requires authentication.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意观察*图 4.7*中的 JSON 结果是如何格式化的，以便易于阅读。这只是 Postman 为我们提供的许多有用功能之一。当我们深入研究 OpenAI
    API 时，我们还将涵盖更多的 Postman 功能。但是让我们继续并讨论如何调用 OpenAI API，因为这需要身份验证。
- en: Understanding API authentication
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 API 身份验证
- en: Some websites are public, while others require you to log in before you can
    access content or functionality. The same is true for APIs. The Open-Notify API
    that we looked at in the *Understanding APIs* section is open to the public and
    doesn't require any kind of authentication. The OpenAI API, on the other hand,
    is private and therefore requires authentication to use it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网站是公开的，而其他网站则要求您登录后才能访问内容或功能。对于 API 也是如此。我们在*理解 API*部分中查看的 Open-Notify API
    是对公众开放的，并且不需要任何形式的身份验证。另一方面，OpenAI API 是私有的，因此需要身份验证才能使用它。
- en: An API authentication process does the same thing as a website login, but in
    a way that is practical for applications rather than humans. There are many different
    ways in which APIs can authenticate application requests, but we're going to focus
    on one of the most common methods, **basic authentication**, because that's what
    the OpenAI API uses.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: API 身份验证过程的作用与网站登录相同，但是以适用于应用程序而不是人类的方式进行。API 可以通过许多不同的方式对应用程序请求进行身份验证，但我们将重点放在**基本身份验证**上，因为这是
    OpenAI API 使用的方法之一。
- en: Basic authentication is an authentication method that is native to HTTP. It
    allows a username and password to be included in an HTTP header. To keep credentials
    secure, requests and responses to the API should be encrypted. So, an API endpoint
    URL that uses basic authentication should always use **Secure Socket Layer** (**SSL**),
    which you can identify by a URL that begins with HTTPS as opposed to just HTTP.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证是一种原生于 HTTP 的身份验证方法。它允许将用户名和密码包含在 HTTP 头中。为了保护凭据安全，对 API 的请求和响应应进行加密。因此，使用基本身份验证的
    API 端点 URL 应始终使用**安全套接字层**（**SSL**），您可以通过 URL 以 HTTPS 开头而不仅仅是 HTTP 来识别。
- en: In the case of the OpenAI API, rather than sending your username and password,
    you use an API key. An API key is like a username and password rolled into one
    string. The benefit of using an API key is that it can be easily changed or renewed
    without having to change your OpenAI password.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OpenAI API，你不是发送用户名和密码，而是使用 API 密钥。API 密钥就像一个字符串中的用户名和密码合二为一。使用 API 密钥的好处是可以轻松更改或更新，而不必更改
    OpenAI 密码。
- en: We looked at where you can find your API key in [*Chapter 3*](B16854_03_ePub_AM.xhtml#_idTextAnchor050),
    *Working with the OpenAI Playground*, but to review, you can access your OpenAI
    API key under your user settings. From the same location, you can also expire
    and generate a new API key with the **Rotate Key** button.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第 3 章*](B16854_03_ePub_AM.xhtml#_idTextAnchor050)中介绍了你可以在哪里找到你的 API 密钥，*使用
    OpenAI Playground*，但是作为回顾，你可以在用户设置下访问你的 OpenAI API 密钥。从相同位置，你也可以通过点击 **Rotate
    Key** 按钮来使 API 密钥失效并生成一个新的 API 密钥。
- en: 'The following screenshot shows the **API Keys** screen under the account settings:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了账户设置下的 **API 密钥** 屏幕：
- en: '![Figure 4.8 – API Keys'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – API 密钥'
- en: '](img/B16854_04_008.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_008.jpg)'
- en: Figure 4.8 – API Keys
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – API 密钥
- en: With your API key, you have everything you need to make a request to the OpenAI
    API. But before we do that, let's talk for a minute about the importance of keeping
    API keys private.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 API 密钥，你拥有一切需要向 OpenAI API 发送请求的条件。但在我们进行之前，让我们谈一分钟关于保持 API 密钥私密性的重要性。
- en: Keeping API keys private
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持 API 密钥私密
- en: 'Even though API keys can be easily changed, they should be kept private, just
    like a username and password, because they also provide access to your account.
    So, take precautions to ensure that your API keys don''t get compromised accidentally.
    This can be easy to do by mistake if you''re not careful. For example, the OpenAI
    documentation includes your API key to make trying code samples simple. But if
    you take a screenshot of documentation for a blog post or something like that,
    you''ll expose your API key to anyone who sees the image if you don''t blur it
    out. The following screenshot shows an example of a documentation page that includes
    an API key. In the example, the key has been blurred out, but you can see how
    it would be exposed if that wasn''t the case:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 API 密钥可以轻松更改，它们也应该被保持私密，就像用户名和密码一样，因为它们也提供对你的账户的访问。所以，要小心确保你的 API 密钥不会意外泄露。如果你不小心的话，这可能很容易发生错误。例如，OpenAI
    文档包含了你的 API 密钥，以便简化尝试代码示例。但是，如果你对博客文章或类似内容的文档进行截图，如果你没有将其模糊处理，你会将你的 API 密钥暴露给任何看到图像的人。以下截图显示了一个包含
    API 密钥的文档页面示例。在示例中，密钥已经被模糊处理，但你可以看到如果情况不是这样的话它将会暴露：
- en: '![Figure 4.9 – API key in documentation'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 文档中的 API 密钥'
- en: '](img/B16854_04_009.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_009.jpg)'
- en: Figure 4.9 – API key in documentation
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 文档中的 API 密钥
- en: Another common way to mistakenly expose API keys is when they are included with
    source code that is shared. We'll look at how to avoid that in [*Chapter 5*](B16854_05_ePub_AM.xhtml#_idTextAnchor098),
    *Calling the OpenAI API in Code*, but the main point here is that you need to
    be cautious because your API key, like your username and password, provides access
    to your account.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的错误暴露 API 密钥的方式是它们与共享的源代码一起包含。我们将在[*第 5 章*](B16854_05_ePub_AM.xhtml#_idTextAnchor098)中看到如何避免这种情况，*在代码中调用
    OpenAI API*，但这里的主要观点是你需要小心，因为你的 API 密钥，就像你的用户名和密码一样，可以访问你的账户。
- en: Now that you know how to find your API key and keep it safe, let's look at using
    it to make our first call to the OpenAI API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何找到你的 API 密钥并保持它安全，让我们看看如何使用它来第一次调用 OpenAI API。
- en: Making an authenticated request to the OpenAI API
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 OpenAI API 发送经过身份验证的请求
- en: It's time to make our first request directly to the OpenAI API. To do that,
    we'll need to include our API key as part of an HTTP header. The header name we'll
    be using is authorization and the value will be the word *Bearer*, followed by
    a space and then your API key. When an API key is used like this, it's often also
    referred to as a bearer token. This is a standard defined by an authorization
    protocol called OAuth 2.0\. You can learn more about OAuth 2.0 by visiting [https://oauth.net/2/](https://oauth.net/2/).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候直接向 OpenAI API 发送我们的第一个请求了。为此，我们需要将我们的 API 密钥作为 HTTP 标头的一部分。我们将要使用的标头名称是授权，值将是单词
    *Bearer*，后跟一个空格，然后是你的 API 密钥。当 API 密钥像这样被使用时，通常也被称为令牌。这是由一种名为 OAuth 2.0 的授权协议定义的标准。你可以通过访问[https://oauth.net/2/](https://oauth.net/2/)来了解更多关于
    OAuth 2.0 的信息。
- en: 'Postman makes it really easy to use bearer tokens. But before we make an authenticated
    request, let''s look at what happens if we try to make a request without our API
    key. The following screenshot shows a request to the List Engines endpoint URL,
    `https://api.openai.com/v1/engines`, without any authorization header. You can
    see an error message was returned. You''ll also notice that the HTTP response
    status code is `401 UNAUTHORIZED`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Postman非常容易使用持有者标记。但在我们进行经过身份验证的请求之前，让我们看看如果我们尝试在没有我们的API密钥的情况下发出请求会发生什么。下图显示了向不带任何授权标头的请求`https://api.openai.com/v1/engines`发送的请求。您可以看到返回了一个错误消息。您还会注意到HTTP响应状态码为`401
    UNAUTHORIZED`：
- en: '![Figure 4.10 – API request without the API key'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10 – 不带API密钥的API请求'
- en: '](img/B16854_04_010.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_010.jpg)'
- en: Figure 4.10 – API request without the API key
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 不带API密钥的API请求
- en: To resolve the error, we need to include our API key as the bearer token. Since
    we'll be using the API key for every request, we'll set up a Postman variable
    for the API key.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决错误，我们需要将我们的API密钥包含为持有者标记。由于我们将为每个请求使用API密钥，因此我们将为API密钥设置一个Postman变量。
- en: Setting up Postman variables
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Postman变量
- en: Variables in Postman allow you to store and reuse values rather than having
    to enter them over and over. Variables can also be grouped into a Postman environment.
    So, we're going to set up an environment named **openai-dev** and add a variable
    named **OPENAI_API_KEY** to store our API key.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Postman中的变量允许您存储并重复使用值，而不必一遍又一遍地输入。变量还可以被分组到一个Postman环境中。因此，我们要设置一个名为**openai-dev**的环境，并添加一个名为**OPENAI_API_KEY**的变量来存储我们的API密钥。
- en: 'To set up a Postman environment and a variable for your API key, use the following
    steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Postman环境和API密钥变量，请按照以下步骤进行操作：
- en: Click the eyeball icon in the upper-right corner of the request.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击请求右上角的眼睛图标。
- en: Click the **Add** link to add a new environment.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Add**链接以添加新环境。
- en: Name the environment `openai-dev`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将环境命名为`openai-dev`。
- en: Add a variable named `OPENAI_API_KEY`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`OPENAI_API_KEY`的变量。
- en: Enter your API key in the `INITIAL VALUE` input box.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`INITIAL VALUE`输入框中输入您的API密钥。
- en: Click the **Save** icon to save the environment and variable.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Save**图标以保存环境和变量。
- en: Close the **openai-dev** environment tab.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**openai-dev**环境选项卡。
- en: 'Choose the new environment from the environment option list in the upper-right
    corner. By default, it should say **No Environment**, and you''ll want to select
    **openai-dev**, as shown in the following screenshot:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角的环境选项列表中选择新环境。默认情况下，应该显示**无环境**，你将要选择**openai-dev**，如下图所示：
- en: '![Figure 4.11 – Postman with the environment set'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11 – 设置环境的Postman'
- en: '](img/B16854_04_011.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_011.jpg)'
- en: Figure 4.11 – Postman with the environment set
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 设置环境的Postman
- en: With the environment and `the OPENAI_API_KEY` variable in place, you can use
    your API key by just including `{{OPENAI_API_KEY}}` in place of the actual key
    value. Now, let's try it out by using it to set an authorization header for our
    request to the Engines endpoint.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 环境和`OPENAI_API_KEY`变量就位后，你可以通过在实际密钥值位置包含`{{OPENAI_API_KEY}}`来使用你的API密钥。现在，让我们尝试使用它，将其用于为我们的请求设置授权标头到引擎端点。
- en: Setting the authorization header
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置授权标头
- en: 'Now that your OpenAI API key is set as a Postman variable, perform the following
    steps to test it out:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的OpenAI API密钥已设置为Postman变量，请执行以下步骤进行测试：
- en: Click on the **Authorization** tab just below the request URL input box.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求URL输入框下方点击**Authorization**选项卡。
- en: Choose the **Bearer Token** option from the **Type** drop-down list.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**类型**下拉列表中选择**Bearer Token**选项。
- en: Enter **{{OPENAI_API_KEY}}** in the **Token input box**.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Token输入框**中输入**{{OPENAI_API_KEY}}**。
- en: Click the **Send** button.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Send**按钮。
- en: 'You should see a successful response (HTTP status **200**), as demonstrated
    in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个成功的响应（HTTP状态**200**），如下图所示：
- en: '![Figure 4.12 – API request using the API key as a bearer token'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.12 – 使用API密钥作为持有者标记的API请求'
- en: '](img/B16854_04_012.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_012.jpg)'
- en: Figure 4.12 – API request using the API key as a bearer token
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 使用API密钥作为持有者标记的API请求
- en: 'As mentioned earlier, the bearer token is sent as an HTTP header. To see the
    header in Postman, click on the **Headers** tab and then unhide the hidden headers,
    and you''ll see the **Authorization** header with your API key as the bearer token
    value, as demonstrated in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，承载令牌作为 HTTP 标头发送。在 Postman 中查看标头，点击**标头**选项卡，然后取消隐藏标头，您将看到带有 API 密钥作为承载令牌值的**授权**标头，如下截图所示：
- en: '![Figure 4.13 – Authorization header with the API key as a bearer token'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – 使用 API 密钥作为承载令牌的授权标头'
- en: '](img/B16854_04_013.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_013.jpg)'
- en: Figure 4.13 – Authorization header with the API key as a bearer token
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 使用 API 密钥作为承载令牌的授权标头
- en: While we're talking about authorization and HTTP headers, it's also important
    to note that if your user account is associated with multiple organizations, you'll
    also need to provide an organization ID to associate your API requests with the
    organization you'd like the requests to be billed to.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论授权和 HTTP 标头时，还需要注意，如果您的用户帐户关联多个组织，您还需要提供组织 ID，以将 API 请求与您希望计费的组织关联起来。
- en: Working with multiple organizations
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多个组织
- en: To associate API requests with a specific organization, you'll include an **OpenAI-Organization
    HTTP header** with the organization ID for the organization you want to associate
    your requests with. This is only required when your user account is associated
    with multiple organizations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 API 请求与特定组织关联，您将在请求中包含一个**OpenAI-Organization HTTP 标头**，其中包含您要将请求与的组织的组织
    ID。只有在您的用户帐户关联多个组织时才需要这样做。
- en: 'To add the OpenAI-Organization header in Postman, scroll to the bottom of the
    list of existing headers and add a new one with the name **OpenAI-Organization**
    and make the value an organization ID that your account is associated with. Better
    yet, add a new environment in Postman named **OPENAI_ORGANIZATION_ID** and add
    **{{OPENAI_ORGANIZATION_ID}}** as the value. As a reminder, you can find your
    organization ID on the account settings page in the OpenAI developer console,
    as seen in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Postman 中添加 OpenAI-Organization 标头，请滚动到现有标头列表的底部，并添加一个新的标头，名称为**OpenAI-Organization**，并将值设为您的帐户关联的组织
    ID。最好的方法是在 Postman 中添加一个名为**OPENAI_ORGANIZATION_ID**的新环境，并将**{{OPENAI_ORGANIZATION_ID}}**添加为值。作为提醒，您可以在
    OpenAI 开发者控制台中的帐户设置页面上找到您的组织 ID，如下截图所示：
- en: '![Figure 4.14 – Finding your organization ID'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14 – 查找您的组织 ID'
- en: '](img/B16854_04_014.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_014.jpg)'
- en: Figure 4.14 – Finding your organization ID
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 查找您的组织 ID
- en: 'When you''ve added your organization ID value to the OpenAI-Organization header
    in Postman, you''ll see it in the headers list, as seen in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 Postman 中的 OpenAI-Organization 标头中添加了您的组织 ID 值后，您将在标头列表中看到它，如下截图所示：
- en: '![Figure 4.15 – Using the OpenAI-Organization HTTP header'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15 – 使用 OpenAI-Organization HTTP 标头'
- en: '](img/B16854_04_015.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_015.jpg)'
- en: Figure 4.15 – Using the OpenAI-Organization HTTP header
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 使用 OpenAI-Organization HTTP 标头
- en: Throughout the rest of this book, we'll be using Postman to illustrate and test
    API calls. But before we move on, let's take a look at making an authenticated
    API call with CURL.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将使用 Postman 来说明和测试 API 调用。但在我们继续之前，让我们看看如何使用 CURL 进行身份验证的 API 调用。
- en: 'Recall that CURL is a command-line tool. So, it doesn''t have a graphical user
    interface like Postman. With CURL, HTTP headers are passed as command-line parameters.
    The following is an example of a CURL command for calling the List Engines endpoint:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，CURL 是一个命令行工具。因此，它没有像 Postman 那样的图形用户界面。使用 CURL，HTTP 标头作为命令行参数传递。以下是调用列表引擎端点的
    CURL 命令示例：
- en: '[PRE4]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After replacing the `{your-api-key}` placeholder and the `{your-organization-id}`
    placeholder, this command will return something like the results shown in the
    following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在替换 `{your-api-key}` 占位符和 `{your-organization-id}` 占位符之后，这条命令将返回类似下面截图中所示的结果：
- en: '![Figure 4.16 – Using CURL to call the List Engines endpoint'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16 – 使用 CURL 调用列表引擎端点'
- en: '](img/B16854_04_016.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_016.jpg)'
- en: Figure 4.16 – Using CURL to call the List Engines endpoint
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 使用 CURL 调用列表引擎端点
- en: Now that you know how to make authenticated calls to the OpenAI API, let's take
    a minute to talk about JSON, the data-interchange format that the OpenAI API uses.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何进行对 OpenAI API 的身份验证调用，让我们花点时间来谈谈 JSON，这是 OpenAI API 使用的数据交换格式。
- en: Introducing JSON
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 JSON
- en: In this section, we'll do a quick introduction to JSON. JSON is a popular data-interchange
    format that is lightweight, easy for machines to parse, and easy for humans to
    read.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速介绍 JSON。JSON 是一种流行的数据交换格式，它轻量级，易于机器解析，也易于人类阅读。
- en: 'The JSON syntax is based on a subset of the JavaScript programming language
    and it defines two data structures:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 语法基于 JavaScript 编程语言的子集，它定义了两种数据结构：
- en: A collection of name/value pairs
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称/值对的集合
- en: An ordered list of values
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序值列表
- en: These two data structures are supported in one way or another by virtually all
    modern programming languages. So, although the JSON syntax is based on a subset
    of JavaScript, it can be easily used with other languages as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种数据结构在现代几乎所有编程语言中都以某种方式得到支持。因此，尽管 JSON 语法基于 JavaScript 的子集，但也可以轻松地与其他语言一起使用。
- en: 'The two data structures in JSON are defined as either an object or an array.
    An object begins with a left brace and ends with a right brace. An empty object
    would look like the following example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 中的两种数据结构分别定义为对象或数组。对象以左大括号开头，以右大括号结束。一个空对象看起来像下面的示例：
- en: '[PRE5]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An object can contain a set of name/value pairs, referred to as elements. Elements
    in an object don''t need to be in any particular order and the value can be a
    string (enclosed in double quotes), a number, true or false, null, another object,
    or an array. Element names and values are separated by a colon, and elements themselves
    are separated by a comma. The following code block is an example of a JSON object
    from an OpenAI API response. You''ll notice that it starts and ends with braces
    and contains different elements with names and values. Notice that the value of
    the `"choices"` element contains a value that begins with a left bracket and ends
    with a right bracket – that is an array:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以包含一组名称/值对，称为元素。对象中的元素不需要按任何特定顺序排列，值可以是字符串（用双引号括起来）、数字、true 或 false、null、另一个对象或数组。元素名称和值之间用冒号分隔，元素本身用逗号分隔。以下代码块是来自
    OpenAI API 响应的 JSON 对象示例。您会注意到它以大括号开头和结束，并包含具有名称和值的不同元素。请注意，`"choices"` 元素的值包含以左方括号开头和以右方括号结尾的值
    - 那是一个数组：
- en: '[PRE6]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An array is an ordered collection of values. The values could be a collection
    of strings, numbers, true or false values, null values, objects, or other arrays.
    An array always begins with a left bracket and ends with a right bracket and the
    values are separated by a comma.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数组是一组有序的值。这些值可以是一组字符串、数字、true 或 false 值、null 值、对象或其他数组。数组始终以左方括号开头，以右方括号结尾，值之间用逗号分隔。
- en: In the previous example object, the value for the `"choices"` element is an
    array with one object in it. That object contains elements (`text`, `index`, `logprobs`,
    `finish_reason`) with values. So, objects and arrays can be nested.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例对象中，`"choices"` 元素的值是一个包含一个对象的数组。该对象包含带有值的元素（`text`、`index`、`logprobs`、`finish_reason`）。因此，对象和数组可以嵌套。
- en: The last thing to note about JSON is that the formatting of the text, things
    such as spaces, tabs, and line returns, is done for human readability but is not
    required by machines. So, as long as the syntax is valid, it's useable in code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JSON 的最后一点是，文本的格式，诸如空格、制表符和换行符，是为了人类可读性而做的，但并不是机器所必需的。因此，只要语法有效，它就可以在代码中使用。
- en: 'For example, the following two JSON objects are the same and both are valid:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下两个 JSON 对象是相同的，且都是有效的：
- en: 'Example 1:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例 1：
- en: '[PRE7]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Example 2:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例 2：
- en: '[PRE8]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As mentioned previously in this section, the OpenAI API uses JSON to send and
    receive data between the client and server. The introduction in this section should
    be enough to begin working with the OpenAI API, but to learn more about JSON,
    you can also visit [https://www.json.org/](https://www.json.org/).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面提到的，OpenAI API 使用 JSON 在客户端和服务器之间发送和接收数据。本节的介绍应该足以开始使用 OpenAI API，但要了解更多关于
    JSON 的信息，您也可以访问 [https://www.json.org/](https://www.json.org/)。
- en: At this point, you've learned everything you need to begin using the main OpenAI
    API endpoint – the Completions endpoint. So, let's dive into that next.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学会了开始使用主要的 OpenAI API 端点 - Completions 端点所需的所有内容。所以，接下来让我们深入了解一下。
- en: Using the Completions endpoint
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Completions 端点
- en: When you're working with the OpenAI API, most of what you'll be doing will probably
    involve using the Completions endpoint. This is the endpoint you send prompts
    to. In addition to submitting your prompt, you can also include values to influence
    how the completion is generated, like the setting in the Playground.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 OpenAI API 时，你大部分时间可能会涉及到使用 Completions 端点。这是你发送提示的端点。除了提交你的提示外，你还可以包含值来影响完成的生成，就像
    Playground 中的设置一样。
- en: 'Using the Completions endpoint is a little more involved than using the List
    Engines endpoint that we looked at in the last section, *Introducing JSON*. This
    is because the Completions endpoint uses the HTTP POST method and requires a JSON
    object as the body. Technically, the JSON body could just be an empty object (just
    a left and right curly brace, like `{})`, but minimally, you''ll want to include
    at least the `prompt` element with the value set to your `prompt` string, something
    like the following JSON example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 Completions 端点比我们在上一节*介绍 JSON*中看到的 List Engines 端点更加复杂。这是因为 Completions
    端点使用 HTTP POST 方法，并且需要一个 JSON 对象作为正文。从技术上讲，JSON 正文可以只是一个空对象（就像 `{}` 一样），但至少，你会想至少包含
    `prompt` 元素，并将其值设置为你的 `prompt` 字符串，例如以下的 JSON 示例:'
- en: '[PRE9]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding example is a simple one but here''s how we''d submit it using
    Postman. Assuming the authorization was set up as discussed in the previous section,
    there are five steps to completing to call the Completions endpoint from Postman.
    These steps are as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的例子是一个简单的例子，但这是我们如何使用 Postman 提交它。假设授权如前一节所讨论的设置，从 Postman 完成调用 Completions
    端点有五个步骤。这些步骤如下:'
- en: Set the request type to **POST**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求类型设置为**POST**。
- en: Enter https://api.openai.com/v1/engines/davinci/completions for the endpoint.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 https://api.openai.com/v1/engines/davinci/completions 作为端点。
- en: Set the body to **raw**.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将正文设置为**raw**。
- en: Select **JSON** as the body content type.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**JSON**作为正文内容类型。
- en: 'Enter `{"prompt": "Once upon a time"}` as the JSON body text.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '输入 `{"prompt": "Once upon a time"}` 作为 JSON 正文文本。'
- en: 'The labels on the following screenshot show where each of the steps is completed:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的屏幕截图标签显示了每个步骤的完成位置：
- en: '![Figure 4.17 – Postman settings for the Completions endpoint'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17 - Completions 终端的 Postman 设置'
- en: '](img/B16854_04_017.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_017.jpg)'
- en: Figure 4.17 – Postman settings for the Completions endpoint
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 - Completions 终端的 Postman 设置
- en: 'After clicking the **Send** button, we get a response from the Completions
    endpoint, as shown in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '点击**Send**按钮后，我们得到了 Completions 端点的响应，如下面的屏幕截图所示:'
- en: '![Figure 4.18 – Postman response from the Completions endpoint'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18 - Completions 终端的 Postman 响应'
- en: '](img/B16854_04_018.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_018.jpg)'
- en: Figure 4.18 – Postman response from the Completions endpoint
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 - Completions 终端的 Postman 响应
- en: 'By default, Postman will display the JSON response using the **Pretty** setting,
    which makes it friendly for human viewing. But if you toggle on the **Raw** setting,
    you''ll see how the response is actually sent, as the following screenshot shows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Postman 将使用**Pretty**设置来显示 JSON 响应，使其对人类查看友好。但是，如果切换到**Raw**设置，你将看到响应实际上是如何发送的，正如下面的屏幕截图所示：
- en: '![Figure 4.19 – Postman response from the Completions endpoint – Raw'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.19 - Completions 终端的 Postman 响应 – Raw'
- en: '](img/B16854_04_019.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_019.jpg)'
- en: Figure 4.19 – Postman response from the Completions endpoint – Raw
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 - Completions 终端的 Postman 响应 – Raw
- en: 'The previous example was a simple one with just one request parameter – the
    prompt. However, the endpoint accepts a number of additional parameters that are
    similar to the settings in the Playground. To include additional parameters with
    the request, the parameters are included as elements in the JSON body object.
    For example, to send the prompt and limit the number of tokens returned (like
    the response length setting does in the Playground), we can include the `max_tokens`
    parameter, as shown in the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的例子是一个简单的例子，只有一个请求参数 - prompt。然而，端点接受许多其他类似于 Playground 设置的额外参数。为了在请求中包含其他参数，这些参数被包含为
    JSON 正文对象中的元素。例如，要发送提示并限制返回的标记数（就像 Playground 中的响应长度设置一样），我们可以包含 `max_tokens`
    参数，如下面的屏幕截图所示:'
- en: '![Figure 4.20 – Postman response from the Completions endpoint with max_tokens'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.20 - Completions 终端的 Postman 响应含有 max_tokens'
- en: '](img/B16854_04_020.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_020.jpg)'
- en: Figure 4.20 – Postman response from the Completions endpoint with max_tokens
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 - Completions 终端的 Postman 响应含有 max_tokens
- en: Notice that in order to include the `max_tokens` parameter and value, a new
    `max_tokens` element is added to the JSON body object and separated from the `"prompt"`
    element by a comma. Additional parameters would be added the same way.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了包含`max_tokens`参数和值，一个新的`max_tokens`元素被添加到 JSON 主体对象中，并且与`"prompt"`元素用逗号分隔。其他参数会以相同的方式添加。
- en: A list of all the available parameters can be found at [https://beta.openai.com/docs/api-reference/create-completion](https://beta.openai.com/docs/api-reference/create-completion)
    and we won't cover them all here. However, most of them have an equivalent setting
    in the Playground that we covered in [*Chapter 3*](B16854_03_ePub_AM.xhtml#_idTextAnchor050),
    *Working with the OpenAI Playground*, so they'll be familiar to you.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://beta.openai.com/docs/api-reference/create-completion](https://beta.openai.com/docs/api-reference/create-completion)
    找到所有可用参数的列表，我们这里不会全部涵盖。然而，大多数参数在 Playground 中都有对应的设置，我们在[*第三章*](B16854_03_ePub_AM.xhtml#_idTextAnchor050)，*使用
    OpenAI Playground* 中已经介绍过，所以它们对你来说应该是熟悉的。
- en: 'But before we move on, let''s take a look at another example, one that you
    can''t do from the Playground. In this example, we''re going to submit multiple
    prompts simultaneously and get back a completion for each. We''ll use the following
    JSON:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们看看另一个例子，一个你无法从 Playground 中完成的例子。在这个例子中，我们将同时提交多个提示，并针对每个提示返回一个完成。我们将使用以下
    JSON：
- en: '[PRE10]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that the value for the `"prompt"` element is a JSON array with two values,
    `"The capital of California is:"`, and `"Once upon a time"`. By sending an array
    of prompts, the Completions endpoint will send back completions for each prompt,
    as the following screenshot shows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`"prompt"`元素的值是一个 JSON 数组，包含两个值，`"加利福尼亚的首府是："`, 和 `"从前有一只"`。通过发送提示的数组，完成端点将为每个提示返回完成，如下面的截图所示：
- en: '![Figure 4.21 – Sending multiple prompts'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.21 – 发送多个提示'
- en: '](img/B16854_04_021.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_04_021.jpg)'
- en: Figure 4.21 – Sending multiple prompts
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 发送多个提示
- en: The main takeaway from this example is that there are things you can do with
    the API that you can't do in the Playground. So, understanding how to work with
    the OpenAI API enables you to go beyond what you can do in the Playground.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中得出的主要结论是，有一些事情你可以通过 API 做到，但在 Playground 中做不到。因此，了解如何使用 OpenAI API 使你能够超越
    Playground 的功能。
- en: Another example of something you can do from the API but not the Playground
    is semantic searching. Let's look at that next.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: API 中可以做但 Playground 中无法做的另一个例子是语义搜索。下面我们来看看这个。
- en: Using the Semantic Search endpoint
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用语义搜索端点
- en: In [*Chapter 2*](B16854_02_ePub_AM.xhtml#_idTextAnchor038), *GPT-3 Applications
    and Use Cases*, we discussed semantic search. By way of a review, semantic search
    lets you perform a Google-like search over a list of provided documents. A query
    (a word, phrase, question, or statement) is compared to the contents of documents
    to determine whether semantic similarities exist. The result is a ranking, or
    score, for each document. The score is usually between 0 and 300 but can sometimes
    go higher. A higher score, above 200, typically means the document is semantically
    similar to the query.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B16854_02_ePub_AM.xhtml#_idTextAnchor038)，*GPT-3 应用与用例*中，我们讨论了语义搜索。简单回顾一下，语义搜索让你可以在提供的文档列表上执行类似
    Google 的搜索。一个查询（一个词、短语、问题或语句）会与文档内容进行比较，以确定是否存在语义相似性。结果是每个文档的排名或得分。得分通常介于 0 和
    300 之间，但有时会更高。一个更高的分数，超过 200，通常意味着文档在语义上与查询相似。
- en: To perform a semantic search using the API, you'll make a POST request to the
    Semantic Search endpoint. Like the Create Completions endpoint, you'll also include
    a JSON object in the request body. The JSON body object has two elements – the
    documents element and the query element. The documents element is an array of
    documents to be searched, and each item in the array is a string that represents
    a document. Alternatively, a document can be provided in a pre-uploaded file that
    can be referenced in the request. In [*Chapter 9*](B16854_09_ePub_AM.xhtml#_idTextAnchor172),
    *Building a GPT-3 Powered Question-Answering App*, we'll look at using files in
    detail. For now, however, we'll focus on providing documents as an array with
    the endpoint request.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: A document could be a single word, sentence, paragraph, or longer text. The
    value of the query element is a string containing the search word or phrase that
    will be searched against the documents. This might be something like a question
    or a statement.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, a semantic search ranks a query based on how semantically similar it
    is to one or more documents. So, it''s not necessarily a search for similar words.
    For example, the following JSON object provides a list of vehicles (plane, boat,
    spaceship, or car) as the documents and the query `"A vehicle with wheels"`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s take a look at what the results would look like from the previous JSON.
    We''ll use Postman. Remember that all of the OpenAI API endpoints require authorization,
    so, in Postman, we first make sure that the proper authorization settings are
    in place. From there, the steps are the same as making a request to the Completions
    endpoint:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Set the request type to **POST**.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the **URI** endpoint.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the body to **raw**.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **JSON** as the body content type.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the JSON body.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Semantic Search endpoint URI is `https://api.openai.com/v1/engines/{engine_id}/search`,
    where `{engine_id}` is replaced by a valid engine ID (such as `davinci` or `ada`).
    After setting up and submitting the API call in Postman, you should see results
    like those in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Semantic Search results'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16854_04_022.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.22 – Semantic Search results
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON object returned by the Semantic Search endpoint contains three elements:
    an object, data, and an engine. The value of the data element is a JSON array
    of results – one item for each document. Recall from our earlier introduction
    to JSON that items in an array are ordered, meaning that each item can be referenced
    by a number, the first one starting with zero. So, in our example, the following
    values would apply:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`0` = plane'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` = boat'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` = spaceship'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` = car'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knowing that each document is associated with a numeric value, when you look
    at the following results returned from the search API, you can see that document
    `3` (car) got the highest score and therefore represents the document that is
    most semantically similar:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The document number rather than the document itself is included in the data
    array because the document itself might be a long string of text and using the
    document number is more efficient. So, you will need to match the results returned
    to the documents sent. But that's relatively straightforward when you're working
    with code – and that's exactly what we'll get started on in the next chapter.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 数据数组中包含的是文档号而不是文档本身，因为文档本身可能是一长串文本，使用文档号更有效。因此，在匹配返回的结果与发送的文档时，您需要使用文档号。但当您使用代码进行操作时，这相对直接
    – 这也是我们将在下一章开始的内容。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at working with the OpenAI API. We started with an
    introduction/review of what an API is and then we became familiar with the basics
    of the HTTP protocol. We reviewed the OpenAI API endpoints and covered how to
    access the API using basic authentication with an OpenAI API key and how to authenticate
    for an account with access to multiple organizations. From there, we learned about
    the JSON data-interchange format before learning how to make API calls to the
    Completions endpoint, the Engines endpoint, and the Semantic Search endpoint using
    Postman.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用OpenAI API。我们从介绍/回顾API是什么开始，然后熟悉了HTTP协议的基础知识。我们审查了OpenAI API的端点，并涵盖了如何使用OpenAI
    API密钥进行基本身份验证以访问API，以及如何对具有对多个组织访问权限的帐户进行身份验证。然后，我们了解了JSON数据交换格式，然后学习了如何使用Postman对Completions端点、Engines端点和Semantic
    Search端点进行API调用。
- en: In the next chapter, we'll put the knowledge acquired in this chapter to work
    and dive into using code to call the API.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将把本章学到的知识付诸实践，深入了解如何使用代码调用API。
