["```py\npip install nltk karateclub networkx\n```", "```py\nfrom nltk import *\nfrom nltk.sem import Expression\n\np1 = Expression.fromstring('man(socrates)')\np2 = Expression.fromstring('all x.(man(x) -> mortal(x))')\nc = Expression.fromstring('mortal(socrates)')\nResolutionProver().prove(c, [p1, p2], verbose=True)\n```", "```py\n[1] {-mortal(socrates)}     A \n[2] {man(socrates)}         A \n[3] {-man(z2), mortal(z2)}  A \n[4] {-man(socrates)}        (1, 3) \n[5] {mortal(socrates)}      (2, 3) \n[6] {}                      (1, 5) \nTrue\n```", "```py\nimport pandas as pd\nzoo = pd.read_csv('zoo.csv')\nbinary_cols = zoo.columns[zoo.nunique() == 2]\nfor col in binary_cols:\n    zoo[col] = zoo[col].astype(bool)\nlabels = [\n    'Mammal', 'Bird', 'Reptile',\n    'Fish', 'Amphibian', 'Bug',\n    'Invertebrate'\n]\ntraining_size = int(len(zoo) * 0.8)\n```", "```py\nall_labels = { i+1: c for i, c in enumerate(labels) }\ncols = list(zoo.columns)\n\ntriplets = []\ndef get_triplet(row, col):\n    if col == 'class_type':\n        return (\n            all_labels[row[col]],\n            'is_a',\n            row['animal_name'],\n        )\n    # int properties:\n    if col in ['legs']:\n        #if row[col] > 0:\n        return (\n            row['animal_name'],\n            'has' + col,\n            str(row[col]) + '_legs'\n        )\n        #else:\n        # return ()\n    # binary properties:\n    if row[col]:\n        return (\n            row['animal_name'],\n            'has',\n            str(col)\n        )\n    else:\n        return ()\n\nfor i, row in zoo.iterrows():\n    for col in cols:\n        if col == 'animal_name':\n            continue\n        if col == 'class_type' and i > training_size:\n                continue\n        triplet = get_triplet(row, col)\n        if triplet:\n            triplets.append(triplet)\n```", "```py\n[('aardvark', 'has', 'hair'),\n ('aardvark', 'has', 'milk'),\n ('aardvark', 'has', 'predator'),\n ('aardvark', 'has', 'toothed'),\n ('aardvark', 'has', 'backbone'),\n ('aardvark', 'has', 'breathes'),\n ('aardvark', 'haslegs', '4_legs'),\n ('aardvark', 'has', 'catsize'),\n ('Mammal', 'is_a', 'aardvark'),\n ('antelope', 'has', 'hair'),\n ('antelope', 'has', 'milk'),\n ('antelope', 'has', 'toothed'),\n ('antelope', 'has', 'backbone'),\n ('antelope', 'has', 'breathes'),\n ('antelope', 'haslegs', '4_legs'),\n ('antelope', 'has', 'tail'),\n ('antelope', 'has', 'catsize'),\n ('Mammal', 'is_a', 'antelope'),\n ('bass', 'has', 'eggs'),\n ('bass', 'has', 'aquatic')]\n```", "```py\nimport networkx as nx\n\nclass Vocabulary:\n    label2id = {}\n    id2label = {}\n    def lookup(self, word):\n        \"\"\"get word id; if not present, insert\"\"\"\n        if word in self.label2id:\n            return self.label2id[word]\n        ind = len(self.label2id)\n        self.label2id[word] = ind\n        return ind\n\n    def inverse_lookup(self, index):\n        if len(self.id2label) == 0:\n            self.id2label = {\n                ind: label\n                for label, ind in self.label2id.items()\n            }\n        return self.id2label.get(index, None)\n\nvocab = Vocabulary()\nnx_graph = nx.Graph()\nfor (a, p, b) in triplets:\n    id1, id2 = vocab.lookup(a), vocab.lookup(b)\n    nx_graph.add_edge(id1, id2)\n```", "```py\nfrom karateclub.node_embedding.neighbourhood import Walklets\n\nmodel_w = Walklets(dimensions=5)\nmodel_w.fit(nx_graph)\nembedding = model_w.get_embedding()\n```", "```py\ntrainamals = [\n    vocab.label2id[animal]\n    for animal in zoo.animal_name.values[:training_size]\n]\ntestimals = [\n    vocab.label2id[animal]\n    for animal in zoo.animal_name.values[training_size:]\n]\nclf = SVC(random_state=42)\nclf.fit(embedding[trainamals, :], zoo.class_type[:training_size])\n\ntest_labels = zoo.class_type[training_size:]\ntest_embeddings = embedding[testimals, :]\nprint(end='Support Vector Machine: Accuracy: ')\nprint('{:.3f}'.format(\n  accuracy_score(test_labels, clf.predict(test_embeddings)\n))\nprint(confusion_matrix(test_labels, clf.predict(test_embeddings)))\n```", "```py\nSupport Vector Machine: Accuracy = 0.809\n[[5 0 0 0 0 0 0]\n [0 4 0 0 0 0 0]\n [2 0 0 1 0 0 0]\n [0 0 0 3 0 0 0]\n [1 0 0 0 0 0 0]\n [0 0 0 0 0 2 0]\n [0 0 0 0 0 0 3]]\n```", "```py\npip install dd omega\n```", "```py\nimport random\nfrom typing import Optional, List, Tuple\n\nclass Chromosome:\n    def __init__(self, configuration: Optional[List]=None, nq: Optional[int]=None):\n        if configuration is None:\n            self.nq = nq\n            self.max_fitness = np.sum(np.arange(nq))\n            self.configuration = [\n                random.randint(1, nq) for _ in range(nq)\n            ]\n        else:\n            self.configuration = configuration\n            self.nq = len(configuration)\n            self.max_fitness = np.sum(np.arange(self.nq))\n\n    def fitness(self):\n        return cost_function(self.configuration) / self.max_fitness\n\n    def mutate(self):\n        ind = random.randint(0, self.nq-1)\n        val = random.randint(1, self.nq)\n        self.configuration[ind] = val\n```", "```py\ndef cost_function(props):\n    res = 0\n    for i1, q1 in enumerate(props[:-1]):\n        for i2, q2 in enumerate(props[i1+1:], i1+1):\n            if (q1 != q2) and (abs(i1 - i2) != abs(q1 - q2)):\n                res += 1\n    return res\n```", "```py\nclass GeneticQueen:\n    def __init__(self, nq, population_size=20, mutation_prob=0.5):\n        self.nq = nq\n        self.population_size = population_size\n        self.mutation_prob = mutation_prob\n        self.population = [Chromosome(nq=nq) for _ in range(population_size)]\n        self.solution = None\n        self.best_fitness = None\n\n    def iterate(self):\n        new_population = []\n        best_fitness = -1\n        for i in range(len(self.population)):\n            p1, p2 = self.get_parents()\n            child = Chromosome(self.cross_over(p1, p2))\n            if random.random() < self.mutation_prob:\n                child.mutate()\n            new_population.append(child)\n            fit = child.fitness()\n            if fit > best_fitness:\n                best_fitness = fit\n            if fit == 1:\n                self.solution = child\n                break                \n        self.best_fitness = best_fitness\n        self.population = new_population\n\n    def cross_over(self, p1, p2):\n        return [\n            yi\n            if random.random() > 0\n            else xi\n            for xi, yi in zip(\n                p1.configuration,\n                p2.configuration\n            )\n        ]\n\n    def get_parents(self) -> Tuple[Chromosome, Chromosome]:\n        weights = [chrom.fitness() for chrom in self.population]\n        return tuple(\n            random.choices(\n                self.population, \n                weights=weights,\n                k=2\n            )\n        )\n```", "```py\ndef ga_solver(nq):\n    fitness_trace = []\n    gq = GeneticQueen(nq=nq)\n    generation = 0\n    while not gq.solution:\n        gq.iterate()\n        if (generation % 100) == 0:\n            print('Generation {}'.format(generation))\n            print('Maximum Fitness: {:.3f}'.format(gq.best_fitness))\n        fitness_trace.append(gq.best_fitness)\n        generation += 1\n\n    gq.visualize_solution()\n    return fitness_trace\n```", "```py\nGeneration 0\nMaximum Fitness: 0.857\nGeneration 100\nMaximum Fitness: 0.821\nGeneration 200\nMaximum Fitness: 0.892\nGeneration 300\nMaximum Fitness: 0.892\nGeneration 400\nMaximum Fitness: 0.892\n```", "```py\nclass Particle:\n    best_fitness: int = 0\n\n    def __init__(\n        self, N=None, props=None,\n        velocities=None\n    ):\n        if props is None:\n            self.current_particle = np.random.randint(0, N-1, N)\n            self.best_state = np.random.randint(0, N-1, N)\n            self.velocities = np.random.uniform(-(N-1), N-1, N)\n        else:\n            self.current_particle = props\n            self.best_state = props\n            self.velocities = velocities\n\n        self.best_fitness = cost_function(self.best_state)\n\n    def set_new_best(self, props: List[int], new_fitness: int): \n        self.best_state = props\n        self.best_fitness = new_fitness\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}(\\n' +\\\n            f'\\tcurrent_particle={self.current_particle}\\n' +\\\n            f'\\best_state={self.best_state}\\n' +\\\n            f'\\tvelocities={self.velocities}\\n' +\\\n            f'\\best_fitness={self.best_fitness}\\n' +\\\n            ')'\n```", "```py\nclass ParticleSwarm:\n  def __init__(self, N: int, n_particles: int,\n    omega: float, phip: float, phig: float\n  ):\n    self.particles = [Particle(N=N) for i in range(n_particles)]\n    self.omega = omega\n    self.phip = phip\n    self.phig = phig\n\n  def get_best_particle(self):\n    best_particle = 0\n    best_score = -1\n    score = -1\n    for i, particle in enumerate(self.particles):\n        score = cost_function(particle.current_particle)\n        if score > best_score:\n            best_score = score\n            best_ind = i\n    return self.particles[best_ind].current_particle, best_score\n\n  def iterate(self):\n    for particle in self.particles:\n      rg = np.random.rand((N))\n      rp = np.random.rand((N))\n      delta_p = particle.best_state - particle.current_particle\n      delta_g = best_particle - particle.current_particle\n      update = (rp * self.phip * delta_p +\n        \\ rg * self.phig * delta_g)  # local vs global\n      particle.velocities = self.omega * particle.velocities + update\n      particle.current_particle = (np.abs(\n        particle.current_particle + particle.velocities\n      ) % N ).astype(int)  # update the particle best\n      current_fitness = cost_function(particle.current_particle)\n      if current_fitness > particle.best_fitness:\n        particle.set_new_best(\n          particle.current_particle, current_fitness\n        )\n        particle_candidate, score_candidate = get_best_particle(particles)\n        if best_score_cand > best_score:\n          best_particle = particle_candidate\n          best_score = score_candidate\n    return best_particle, best_score\n```", "```py\nimport chess\nimport chess.svg\nfrom IPython.display import display\n\ndef show_board(queens):\n    fen = '/'.join([queen_to_str(q) for q in queens])\n    display(chess.svg.board(board=chess.Board(fen), size=300))\n```", "```py\ndef particle_swarm_optimization(\n    N: int, omega: float, phip: float, phig: float,\n    n_particles: int, visualize=False, max_iteration=999999\n) -> List[int]:\n  def print_best():\n    print(f'iteration {iteration} - best particle: {best_particle}, score: {best_score}')\n  solved_cost = np.sum(np.arange(N))\n  pso = ParticleSwarm(N, n_particles, omega, phip, phig)\n  iteration = 0\n  best_particle, best_score = get_best_particle(particles)\n  scores = [best_score]\n  if visualize:\n    print('iteration:', iteration)\n    show_board(best_particle)\n  while best_score < solved_cost and iteration < max_iteration:\n    if (iteration % 500) == 0 or iteration == 0:\n      print_best()\n      best_particle, best_score = pso.iterate()\n    if iteration > 0 and visualize:\n      print('iteration:', iteration)\n      show_board(best_particle)\n    scores.append(best_score)\n    iteration += 1\n  print_best()\n  return best_particle, scores\n```", "```py\ndef queens_formula(n):\n    present = at_least_one_queen_per_row(n)\n    rows = at_most_one_queen_per_line(True, n)\n    cols = at_most_one_queen_per_line(False, n)\n    slash = at_most_one_queen_per_diagonal(True, n)\n    backslash = at_most_one_queen_per_diagonal(False, n)\n    s = conj([present, rows, cols, slash, backslash])\n    return s\n```", "```py\ndef at_least_one_queen_per_row(n):\n    c = list()\n    for i in range(n):\n        xijs = [_var_str(i, j) for j in range(n)]\n        s = disj(xijs)\n        c.append(s)\n    return conj(c)\n```", "```py\ndef benchmark(n):\n    t0 = time.time()\n    u, bdd = solve_queens(n)\n    t1 = time.time()\n    dt = t1 - t0\n\n    for i, d in enumerate(bdd.pick_iter(u)):\n        if len(d) > 0:\n            visualize_solution(d)\n            break\n    n_solutions = bdd.count(u)\n\n    s = (\n        '------\\n'\n        'queens: {n}\\n'\n        'time: {dt} (sec)\\n'\n        'node: {u}\\n'\n        'total nodes: {k}\\n'\n        'number solutions: {n_solutions}\\n'\n        '------\\n'\n    ).format(\n        n=n, dt=dt, u=u, k=len(bdd),\n        n_solutions=n_solutions,\n    )\n    print(s)\n    return dt\n```", "```py\nqueens: 8\ntime: 4.775595426559448 (sec)\nnode: -250797\ntotal nodes: 250797\nnumber solutions: 92\n```", "```py\ndef iterate(self):\n  new_population = []\n  for i in range(len(self.population)):\n    p1, p2 = self.get_parents()\n    child = Chromosome(self.cross_over(p1, p2))\n    if random.random() < self.mutation_prob:\n      child.mutate()\n    new_population.append(child)\n```", "```py\ndelta_p = particle.best_state - particle.current_particle\ndelta_g = best_particle - particle.current_particle\nupdate = (rp * phip * delta_p +\\\n rg * phig * delta_g) # local vs global\n```", "```py\nparticle.velocities = omega * particle.velocities + update\n```", "```py\npip install scikit-opt\n```", "```py\nimport numpy as np\nN = 15\nstops = np.random.randint(0, 100, (N, 2))\n```", "```py\nfrom scipy import spatial\n\ndistance_matrix = spatial.distance.cdist(stops, stops, metric='euclidean')\n```", "```py\ndef find_tour(stops, distance_matrix, iterations=10**5):\n    def calc_distance(i, j):\n        \"\"\"sum of distance to and from i and j in tour\n        \"\"\"\n        return sum(\n            distance_matrix[tour[k], tour[k+1]]\n            for k in [j - 1, j, i - 1, i]\n        )\n\n    n = len(stops)\n    tour = np.random.permutation(n)\n    lengths = []\n    for temperature in np.logspace(4, 0, num=iterations):\n        i = np.random.randint(n - 1) # city 1\n        j = np.random.randint(i + 1, n) # city 2\n        old_length = calc_distance(i, j)\n        # swap i and j:\n        tour[[i, j]] = tour[[j, i]]\n        new_length = calc_distance(i, j)\n        if np.exp((old_length - new_length) / temperature) < np.random.random():  # bad swap\n            tour[[i, j]] = tour[[j, i]]  # undo swap\n            lengths.append(old_length)\n        else:\n            lengths.append(new_length) \n    return tour, lengths\n```", "```py\nfrom scipy.spatial.distance import euclidean\ntour, lengths = find_tour(\n    stops, distance_matrix, iterations=1000000\n)\n```", "```py\nfrom sko.ACA import ACA_TSP\n\ndef cal_total_distance(tour):\n    return sum([\n        distance_matrix[tour[i % N], tour[(i + 1) % N]]\n        for i in range(N)\n    ])\n\naca = ACA_TSP(\n    func=cal_total_distance,\n    n_dim=N,\n    size_pop=N,\n    max_iter=200,\n    distance_matrix=distance_matrix\n)\nbest_x, best_y = aca.run()\n```", "```py\npip install mesa\n```", "```py\nclass Person(Agent):\n    def __init__(self, unique_id, model):\n        super().__init__(unique_id, model)\n        self.alive = True\n        self.infected = False\n        self.hospitalized = False\n        self.immune = False\n        self.in_quarantine = False  # self-quarantine\n        self.time_infected = 0\n```", "```py\n    def while_infected(self):\n        self.time_infected += 1\n        if self.hospitalized:\n            # stay in bed, do nothing; maybe die\n            if self.random.random() < (\n                    self.model.critical_rate *\n                    self.model.hospital_factor\n            ):\n                # die\n                self.alive = False\n                self.hospitalized = False\n                self.infected = False\n                return\n            self.hospitalized -= 1\n            return\n        if self.random.random() < (\n            self.model.quarantine_rate /\n            self.model.recovery_period\n        ):\n            self.set_quarantine()\n        if not self.in_quarantine:\n            self.infect_others()  # infect others in same cell\n        if self.time_infected < self.model.recovery_period:\n            if self.random.random() < self.model.critical_rate:\n                if self.model.hospital_takeup:\n                    self.hospitalized = self.model.hospital_period\n                    self.set_quarantine()\n                else:\n                    self.alive = False # person died from infection\n                    self.infected = False\n        else:  # person has passed the recovery period so no longer infected\n            self.infected = False\n            self.quarantine = False\n            if self.random.random() < self.model.immunity_chance:\n                self.immune = True\n```", "```py\n    def move_to_next(self):\n        possible_steps = self.model.grid.get_neighborhood(\n            self.pos,\n            moore=True,\n            include_center=False\n        )\n        new_position = self.random.choice(possible_steps)\n        self.model.grid.move_agent(self, new_position)\n```", "```py\n    def step(self):\n        if self.alive:\n            self.move()\n```", "```py\n    def move(self):\n        if self.in_quarantine or self.model.lockdown:\n            pass\n        else:\n            self.move_to_next()\n        if self.infected:\n            self.while_infected()\n```", "```py\n    def create_agents(self):\n        for i in range(self.num_agents):\n            a = Person(i, self)\n            if self.random.random() < self.start_infected:\n                a.set_infected()\n            self.schedule.add(a)\n            x = self.random.randrange(self.grid.width)\n            y = self.random.randrange(self.grid.height)\n            self.grid.place_agent(a, (x, y))\n```", "```py\n        def set_reporters(self):\n            self.datacollector = DataCollector(\n                model_reporters={\n                    'Active Cases': active_cases,\n                    'Deaths': total_deaths,\n                    'Immune': total_immune,\n                    'Hospitalized': total_hospitalized,\n                    'Lockdown': get_lockdown,\n                })\n```", "```py\ndef active_cases(model):\n    return sum([\n        1\n        for agent in model.schedule.agents\n        if agent.infected\n    ])\n```", "```py\n    def step(self):\n        self.datacollector.collect(self)\n        self.hospital_takeup = self.datacollector.model_vars[\n            'Hospitalized'\n        ][-1] < self.free_beds\n        self.schedule.step()\n        if self.lockdown:\n            self.lockdown -= 1\n        else:\n            if self.lockdown_policy(\n                self.datacollector.model_vars['Active Cases'],\n                self.datacollector.model_vars['Deaths'],\n                self.num_agents\n            ):\n                self.lockdown = self.lockdown_period\n        self.current_cycle += 1\n```", "```py\nscale_factor = 0.001\narea = 242495  # km2 uk\nside = int(math.sqrt(area)) # 492\n\nsim_params = {\n    'grid_x': side,\n    'grid_y': side,\n    'density': 259 * scale_factor, # population density uk,\n    'initial_infected': 0.05,\n    'infect_rate': 0.1,\n    'recovery_period': 14 * 12,\n    'critical_rate': 0.05,\n    'hospital_capacity_rate': .02,\n    'active_ratio': 8 / 24.0,\n    'immunity_chance': 1.0,\n    'quarantine_rate': 0.6,\n    'lockdown_policy': lockdown_policy,\n    'cycles': 200 * 12,\n    'hospital_period': 21 * 12,\n}\n```", "```py\ndef lockdown_policy(infected, deaths, population_size):\n    return 0\n```", "```py\ndef lockdown_policy(infected, deaths, population_size):\n  if (\n    (max(infected[-5 * 10:]) / population_size) > 0.6\n    and \n    (len(deaths) > 2 and deaths[-1] > deaths[-2])\n ):\n return 7 * 12\n return 0\n```", "```py\ndef lockdown_policy(infected, deaths, population_size):\n    if infected[-1] / population_size > 0.2:\n        return 21 * 12\n    return 0\n```", "```py\n%matplotlib inline\nfrom collections import defaultdict\nfrom matplotlib import pyplot as plt\nfrom IPython.display import clear_output\n\ndef live_plot(data_dict, figsize=(7,5), title=''):\n    clear_output(wait=True)\n    plt.figure(figsize=figsize)\n    for label,data in data_dict.items():\n        plt.plot(data, label=label)\n    plt.title(title)\n    plt.grid(True)\n    plt.xlabel('iteration')\n    plt.legend(loc='best')\n    plt.show()\n\nmodel = Simulation(sim_params)\ncycles_to_run = sim_params.get('cycles')\nprint(sim_params)\nfor current_cycle in range(cycles_to_run):\n    model.step()\n    if (current_cycle % 10) == 0:\n        live_plot(model.datacollector.model_vars)\n\nprint('Total deaths: {}'.format(\n    model.datacollector.model_vars['Deaths'][-1]\n))\n```", "```py\npip install python-chess\n```", "```py\nimport random\n\nclass MCTS:\n    def __init__(self, exploration_weight=1):\n        self.Q = defaultdict(int)\n        self.N = defaultdict(int)\n        self.children = dict()\n        self.exploration_weight = exploration_weight\n```", "```py\n    def do_rollout(self, node):\n        path = self._select(node)\n        leaf = path[-1]\n        self._expand(leaf)\n        reward = self._simulate(leaf)\n        self._backpropagate(path, reward)\n```", "```py\n    def _select(self, node):\n        path = []\n        while True:\n            path.append(node)\n            if node not in self.children or not self.children[node]:\n                return path\n            unexplored = self.children[node] - self.children.keys()\n            if unexplored:\n                n = unexplored.pop()\n                path.append(n)\n                return path\n            node = self._select(random.choice(self.children[node]))\n```", "```py\n    def _expand(self, node):\n        if node in self.children:\n            return\n        self.children[node] = node.find_children()\n```", "```py\n    def _simulate(self, node):\n        invert_reward = True\n        while True:\n            if node.is_terminal():\n                reward = node.reward()\n                return 1 - reward if invert_reward else reward\n            node = node.find_random_child()\n            invert_reward = not invert_reward\n```", "```py\n    def _backpropagate(self, path, reward):\n        for node in reversed(path):\n            self.N[node] += 1\n            self.Q[node] += reward\n            reward = 1 - reward\n```", "```py\n    def choose(self, node):\n        if node not in self.children:\n            return node.find_random_child()\n\n        def score(n):\n            if self.N[n] == 0:\n                return float('-inf')\n            return self.Q[n] / self.N[n]\n\n        return max(self.children[node], key=score)\n```", "```py\nimport hashlib\nimport copy\n\nclass ChessGame:\n    def find_children(self):\n        if self.is_terminal():\n            return set()\n        return {\n            self.make_move(m) for m in self.board.legal_moves\n        }\n\n    def find_random_child(self):\n        if self.is_terminal():\n            return None\n        moves = list(self.board.legal_moves)\n        m = choice(moves)\n        return self.make_move(m)\n\n    def player_win(self, turn):\n        if self.board.result() == '1-0' and turn:\n            return True\n        if self.board.result() == '0-1' and not turn:\n            return True\n        return False\n\n    def reward(self):\n        if self.board.result() == '1/2-1/2':\n            return 0.5\n        if self.player_win(not self.board.turn):\n            return 0.0\n\n    def make_move(self, move):\n        child = self.board.copy()\n        child.push(move)\n        return ChessGame(child)\n\n    def is_terminal(self):\n        return self.board.is_game_over()\n```", "```py\nfrom IPython.display import display\nimport chess\nimport chess.svg\n\ndef play_chess():\n    tree = MCTS()\n    game = ChessGame(chess.Board())\n    display(chess.svg.board(board=game.board, size=300))\n    while True:\n        move_str = input('enter move: ')\n        move = chess.Move.from_uci(move_str)\n        if move not in list(game.board.legal_moves):\n            raise RuntimeError('Invalid move')\n        game = game.make_move(move)\n        display(chess.svg.board(board=game.board, size=300))\n        if game.is_terminal():\n            break\n        for _ in range(50):\n            tree.do_rollout(game)\n        game = tree.choose(game)\n        print(game)\n        if game.is_terminal():\n            break\n```", "```py\n    def __hash__(self):\n        return int(\n            hashlib.md5(\n                self.board.fen().encode('utf-8')\n            ).hexdigest()[:8],\n            16\n        )\n\n    def __eq__(self, other):\n        return self.__hash__() == other.__hash__()\n\n    def __repr__(self):\n        return '\\n' + str(self.board)\n```", "```py\n    def _uct_select(self, node):\n        log_N_vertex = math.log(self.N[node])\n\n        def uct(n):\n            return self.Q[n] / self.N[n] + self.exploration_weight * math.sqrt(\n                log_N_vertex / self.N[n]\n            )\n\n        return max(self.children[node], key=uct)\n```", "```py\n            node = self._uct_select(node)\n```"]