["```py\nconda install pytorch torchvision cuda80 -c soumith\n```", "```py\nconda install pytorch torchvision -c soumith\n```", "```py\nconda install pytorch torchvision -c soumith\n```", "```py\nx,y = get_data() # x - represents training data,y -                 represents target variables\n\nw,b = get_weights() # w,b - Learnable parameters\n\nfor i in range(500):\n    y_pred = simple_network(x) # function which computes wx + b\n    loss = loss_fn(y,y_pred) # calculates sum of the squared differences of y and y_pred\n\nif i % 50 == 0: \n        print(loss)\n    optimize(learning_rate) # Adjust w,b to minimize the loss\n```", "```py\nx = torch.rand(10)\nx.size()\n\nOutput - torch.Size([10])\n```", "```py\ntemp = torch.FloatTensor([23,24,24.5,26,27.2,23.0])\ntemp.size()\n\nOutput - torch.Size([6])\n```", "```py\nboston_tensor = torch.from_numpy(boston.data)\nboston_tensor.size()\n\nOutput: torch.Size([506, 13])\n\nboston_tensor[:2]\n\nOutput:\nColumns 0 to 7 \n   0.0063 18.0000 2.3100 0.0000 0.5380 6.5750 65.2000 4.0900\n   0.0273 0.0000 7.0700 0.0000 0.4690 6.4210 78.9000 4.9671\n\nColumns 8 to 12 \n   1.0000 296.0000 15.3000 396.9000 4.9800\n   2.0000 242.0000 17.8000 396.9000 9.1400\n[torch.DoubleTensor of size 2x13]\n```", "```py\nfrom PIL import Image\n# Read a panda image from disk using a library called PIL and convert it to numpy array\npanda = np.array(Image.open('panda.jpg').resize((224,224)))\npanda_tensor = torch.from_numpy(panda)\npanda_tensor.size()\n\nOutput - torch.Size([224, 224, 3])\n#Display panda\nplt.imshow(panda)\n\n```", "```py\nsales = torch.FloatTensor([1000.0,323.2,333.4,444.5,1000.0,323.2,333.4,444.5])\n\nsales[:5]\n 1000.0000\n  323.2000\n  333.4000\n  444.5000\n 1000.0000\n[torch.FloatTensor of size 5]\n\nsales[:-5]\n 1000.0000\n  323.2000\n  333.4000\n[torch.FloatTensor of size 3]\n\n```", "```py\nplt.imshow(panda_tensor[:,:,0].numpy())\n#0 represents the first channel of RGB\n```", "```py\nplt.imshow(panda_tensor[25:175,60:130,0].numpy())\n```", "```py\n#torch.eye(shape) produces an diagonal matrix with 1 as it diagonal #elements.\nsales = torch.eye(3,3)\nsales[0,1]\n\nOutput- 0.00.0\n```", "```py\n#Read cat images from disk\ncats = glob(data_path+'*.jpg')\n#Convert images into numpy arrays\ncat_imgs = np.array([np.array(Image.open(cat).resize((224,224))) for cat in cats[:64]]) \ncat_imgs = cat_imgs.reshape(-1,224,224,3)\ncat_tensors = torch.from_numpy(cat_imgs)\ncat_tensors.size()\n\nOutput - torch.Size([64, 224, 224, 3])\n```", "```py\n#Various ways you can perform tensor addition\na = torch.rand(2,2) \nb = torch.rand(2,2)\nc = a + b\nd = torch.add(a,b)\n#For in-place addition\na.add_(5)\n\n#Multiplication of different tensors\n\na*b\na.mul(b)\n#For in-place multiplication\na.mul_(b)\n```", "```py\na = torch.rand(10000,10000)\nb = torch.rand(10000,10000)\n\na.matmul(b)\n\nTime taken: 3.23 s\n\n#Move the tensors to GPU\na = a.cuda()\nb = b.cuda()\n\na.matmul(b)\n\nTime taken: 11.2 Âµs\n```", "```py\nx = Variable(torch.ones(2,2),requires_grad=True)\ny = x.mean()\n\ny.backward()\n\nx.grad\nVariable containing:\n 0.2500  0.2500\n 0.2500  0.2500\n[torch.FloatTensor of size 2x2]\n\nx.grad_fn\nOutput - None\n\nx.data\n 1 1\n 1 1\n[torch.FloatTensor of size 2x2]\n\ny.grad_fn\n<torch.autograd.function.MeanBackward at 0x7f6ee5cfc4f8>\n```", "```py\ndef get_data():\n    train_X = np.asarray([3.3,4.4,5.5,6.71,6.93,4.168,9.779,6.182,7.59,2.167,\n                         7.042,10.791,5.313,7.997,5.654,9.27,3.1])\n    train_Y = np.asarray([1.7,2.76,2.09,3.19,1.694,1.573,3.366,2.596,2.53,1.221,\n                         2.827,3.465,1.65,2.904,2.42,2.94,1.3])\n    dtype = torch.FloatTensor\n    X = Variable(torch.from_numpy(train_X).type(dtype),requires_grad=False).view(17,1)\n    y = Variable(torch.from_numpy(train_Y).type(dtype),requires_grad=False)\n    return X,y\n\n```", "```py\ndef get_weights():\n    w = Variable(torch.randn(1),requires_grad = True)\n    b = Variable(torch.randn(1),requires_grad=True)\n    return w,b\n```", "```py\ndef simple_network(x):\n    y_pred = torch.matmul(x,w)+b\n    return y_pred\n```", "```py\nf = nn.Linear(17,1) # Much simpler.\n```", "```py\ndef loss_fn(y,y_pred):\n    loss = (y_pred-y).pow(2).sum()\n    for param in [w,b]:\n        if not param.grad is None: param.grad.data.zero_()\n    loss.backward()\n    return loss.data[0]\n```", "```py\ndef optimize(learning_rate):\n    w.data -= learning_rate * w.grad.data\n    b.data -= learning_rate * b.grad.data\n```", "```py\nfrom torch.utils.data import Dataset\nclass DogsAndCatsDataset(Dataset):\n    def __init__(self,):\n        pass\n    def __len__(self):\n        pass\n    def __getitem__(self,idx):\n        pass\n```", "```py\nclass DogsAndCatsDataset(Dataset):\n\n    def __init__(self,root_dir,size=(224,224)):\n        self.files = glob(root_dir)\n        self.size = size \n\n    def __len__(self):\n        return len(self.files)\n\n    def __getitem__(self,idx):\n        img = np.asarray(Image.open(self.files[idx]).resize(self.size))\n        label = self.files[idx].split('/')[-2]\n        return img,label\n```", "```py\nfor image,label in dogsdset:\n#Apply your DL on the dataset.\n```", "```py\ndataloader = DataLoader(dogsdset,batch_size=32,num_workers=2)\nfor imgs , labels in dataloader:\n     #Apply your DL on the dataset.\n     pass\n```"]