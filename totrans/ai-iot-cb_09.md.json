["```py\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"cJSON.h\"\n#include \"driver/gpio.h\"\n#include \"esp_system.h\"\n#include \"esp_log.h\"\n#include \"esp_http_client.h\"\n#include \"esp_https_ota.h\"\n#include \"wifi_functions.h\"\n```", "```py\n#define FIRMWARE_VERSION 0.1\n#define UPDATE_JSON_URL \"https://microshak.com/esp32/firmware.json\"\n\nextern const char server_cert_pem_start[] asm(\"_binary_certs_pem_start\");\nextern const char server_cert_pem_end[] asm(\"_binary_certs_pem_end\");\n\nchar rcv_buffer[200];\n```", "```py\nesp_err_t _http_event_handler(esp_http_client_event_t *evt) \n{    \n  switch(evt->event_id) {\n        case HTTP_EVENT_ERROR:\n            break;\n        case HTTP_EVENT_ON_CONNECTED:\n            break;\n        case HTTP_EVENT_HEADER_SENT:\n            break;\n        case HTTP_EVENT_ON_HEADER:\n            break;\n        case HTTP_EVENT_ON_DATA:\n            if (!esp_http_client_is_chunked_response(evt->client)){\n              strncpy(rcv_buffer, (char*)evt->data, evt->data_len);\n            }\n            break;\n        case HTTP_EVENT_ON_FINISH:\n            break;\n        case HTTP_EVENT_DISCONNECTED:\n            break;\n    }\n    return ESP_OK;\n}\n```", "```py\nvoid ml_task(void *pvParameter) \n{\n    while(1) \n    {\n        //ML on this thread\n    }\n}\n```", "```py\nvoid check_update_task(void *pvParameter) \n{  \n  while(1) \n  {\n    printf(\"Looking for a new firmware...\\n\");\n\n    esp_http_client_config_t config = \n    {\n        .url = UPDATE_JSON_URL,\n        .event_handler = _http_event_handler,\n    };\n    esp_http_client_handle_t client = \n        esp_http_client_init(&config);  \n    esp_err_t err = esp_http_client_perform(client);\n    if(err == ESP_OK) {      \n      cJSON *json = cJSON_Parse(rcv_buffer);\n      if(json == NULL) printf(\"downloaded file is not a valid json,\n      aborting...\\n\");\n      else { \n        cJSON *version = cJSON_GetObjectItemCaseSensitive(json, \n        \"version\");\n        cJSON *file = cJSON_GetObjectItemCaseSensitive(json, \n        \"file\");\n        if(!cJSON_IsNumber(version)) printf(\"unable to read new \n        version, aborting...\\n\");\n        else {\n          double new_version = version->valuedouble;\n          if(new_version > FIRMWARE_VERSION) {           \n            printf(\"current firmware version (%.1f) is lower than \n            the available one (%.1f), upgrading...\\n\", \n            FIRMWARE_VERSION, new_version);\n            if(cJSON_IsString(file) && (file->valuestring != NULL)) \n            {\n              printf(\"downloading and installing new \n                     firmware(%s)...\\n\", file->valuestring);              \n              esp_http_client_config_t ota_client_config = \n              {\n                .url = file->valuestring,\n                .cert_pem = server_cert_pem_start,\n              };              \n              esp_err_t ret = esp_https_ota(&ota_client_config);\n              if (ret == ESP_OK) \n              {\n                printf(\"OTA OK, restarting...\\n\");\n                esp_restart();\n              } \n              else \n              {\n                printf(\"OTA failed...\\n\");\n              }\n            }\n            else printf(\"unable to read the new file name, \n                        aborting...\\n\");\n          }\n          else printf(\"current firmware version (%.1f) is greater\n                      or equal to the available one (%.1f), \n                      nothing to do...\\n\", \n                      FIRMWARE_VERSION, new_version);\n        }\n      }\n    }\n    else printf(\"unable to download the json file, aborting...\\n\");\n\n    esp_http_client_cleanup(client);\n\n    printf(\"\\n\");\n        vTaskDelay(60000 / portTICK_PERIOD_MS);\n    }\n}\n```", "```py\nstatic EventGroupHandle_t wifi_event_group;\nconst int CONNECTED_BIT = BIT0;\n\nstatic esp_err_t event_handler(void *ctx, system_event_t *event)\n{\n    switch(event->event_id) \n    {\n      case SYSTEM_EVENT_STA_START:\n            esp_wifi_connect();\n            break;\n\n      case SYSTEM_EVENT_STA_GOT_IP:\n        xEventGroupSetBits(wifi_event_group, CONNECTED_BIT);\n        break;\n\n      case SYSTEM_EVENT_STA_DISCONNECTED:\n        esp_wifi_connect();\n        break;\n\n      default:\n        break;\n    }\n\n  return ESP_OK;\n}\n\nvoid wifi_initialise(void) \n{\n\n  ESP_ERROR_CHECK(nvs_flash_init());\n\n  wifi_event_group = xEventGroupCreate();\n  tcpip_adapter_init();\n  ESP_ERROR_CHECK(esp_event_loop_init(event_handler, NULL));\n  wifi_init_config_t wifi_init_config = WIFI_INIT_CONFIG_DEFAULT();\n  ESP_ERROR_CHECK(esp_wifi_init(&wifi_init_config));\n  ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));\n  ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));\n  wifi_config_t wifi_config = {\n        .sta = {\n            .ssid = \"mynetwork\",\n            .password = \"mywifipassword\",\n        },\n    };\n  ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, \n                                      &wifi_config));\n  ESP_ERROR_CHECK(esp_wifi_start());\n}\n\nvoid wifi_wait_connected()\n{\n  xEventGroupWaitBits(wifi_event_group, CONNECTED_BIT, false, true,\n                      portMAX_DELAY);\n}\n```", "```py\nvoid app_main() {\n\n  printf(\"HTTPS OTA, firmware %.1f\\n\\n\", FIRMWARE_VERSION);\n\n  wifi_initialise();\n  wifi_wait_connected();\n  printf(\"Connected to wifi network\\n\");\n\n  xTaskCreate(&ml_task, \"ml_task\", configMINIMAL_STACK_SIZE, NULL,\n              5, NULL);\n  xTaskCreate(&check_update_task, \"check_update_task\", 8192, NULL,\n              5, NULL);\n}\n```", "```py\n{\n    \"version\":1.2.\n    \"file\":\"https://microshak.com/firmware/otaml1_2.bin\"\n}\n```", "```py\nhostname -I\n```", "```py\nimport time\nimport os\nimport sys\nimport asyncio\nfrom six.moves import input\nimport threading\nfrom azure.iot.device.aio import IoTHubModuleClient\nfrom azure.iot.device import Message\nimport uuid\n```", "```py\ndef MLCode():\n    # You bispoke ML code here\n    return True\n```", "```py\n    async def send_d2c_message(module_client):\n        while True:\n            msg = Message(\"test machine learning \")\n            msg.message_id = uuid.uuid4()\n            msg.custom_properties[\"MachineLearningBasedAlert\"]=\\ \n            MLCode()\n            await module_client.send_message_to_output(msg, \n                                                       \"output1\")\n```", "```py\ndef stdin_listener():\n    while True:\n        try:\n            selection = input(\"Press Q to quit\\n\")\n            if selection == \"Q\" or selection == \"q\":\n                print(\"Quitting...\")\n                break\n        except:\n            time.sleep(10)\n```", "```py\nasync def main():\n    try:\n        module_client = \\\n        IoTHubModuleClient.create_from_edge_environment()\n        await module_client.connect()\n        listeners = asyncio.gather(send_d2c_message(module_client))\n\n        loop = asyncio.get_event_loop()\n        user_finished = loop.run_in_executor(None, stdin_listener)\n\n        # Wait for user to indicate they are done listening for \n        # messages\n        await user_finished\n\n        # Cancel listening\n        listeners.cancel()\n\n        # Finally, disconnect\n        await module_client.disconnect()\n\n    except Exception as e:\n        print ( \"Unexpected error %s \" % e )\n        raise\n```", "```py\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n    loop.close()\n```", "```py\ntensorflowjs_converter --input_format=keras model.h5 tfjs_model\n```", "```py\nasync function GetData(){\n$.get( \"/data.json\", function( data ) {\n$( \"#data\" ).text( data[\"dat\"] );\npredict(data[\"dat\"]) \n});\n}\n```", "```py\nasync function predict(dat)\n{\n    const model = await tf.loadLayersModel('/tfjs_model/model.json');\n    console.log(model)\n    dat = tf.tensor3d(dat, [1, 50, 25] )\n    dat[0] = null\n    console.log(dat)\n    var pred = model.predict( dat)\n    const values = pred.dataSync();\n    let result = \"Needs Maintenance\"\n    if(values[0] < .8)\n        result = \"Does not need Maintenance\"\n\n    $('#needed').html(result )\n} \n```", "```py\n<!DOCTYPE html>\n<html>\n<head>\n<title>Model</title>\n<script src=\"img/tf.min.js\"></script>\n<script src=\"img/tfjs-vis.umd.min.js\"></script>\n</head>\n<body>\n    <button onclick=\"GetData()\">Maintenance Needed</button>\n<textarea id=\"data\" style=\"width:400px;height:400px;\"></textarea>\n<div id=\"needed\"></div>\n</body>\n<script src=\"img/jquery.min.js\"></script>\n<script type=\"text/javascript\" src=\"img/index.js\"></script>\n\n</html>\n```", "```py\nimport org.tensorflow.lite.Interpreter\n```", "```py\nInterpreter tflite;\n```", "```py\ntflite = new Interpreter(loadModelFile(activity));\n```", "```py\nprivate MappedByteBuffer loadModelFile(Activity activity) throws IOException {\n AssetFileDescriptor fileDescriptor = \n  activity.getAssets().openFd(getModelPath());\n FileInputStream inputStream = new \n  FileInputStream(fileDescriptor.getFileDescriptor());\n FileChannel fileChannel = inputStream.getChannel();\n long startOffset = fileDescriptor.getStartOffset();\n long declaredLength = fileDescriptor.getDeclaredLength();\n return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, \n                        declaredLength);\n }\n```", "```py\ntflite.run(inputdata, labelProbArray);\n```", "```py\npip3 install azure-iot-device\npip3 install asyncio\n```", "```py\nimport asyncio\nfrom six.moves import input\nfrom azure.iot.device.aio import IoTHubDeviceClient\n```", "```py\nasync def main():\n    device_client = \\\n    IoTHubDeviceClient.create_from_connection_string(\"Connection\n                                                     String\")\n\n    await device_client.connect()\n```", "```py\n    def quit_listener():\n        while True:\n        selection = input(\"Press Q to quit\\n\")\n        if selection == \"Q\" or selection == \"q\":\n            print(\"Quitting...\")\n            break\n```", "```py\n    asyncio.create_task(twin_patch_listener(device_client))\n```", "```py\n    loop = asyncio.get_running_loop()\n    user_finished = loop.run_in_executor(None, quit_listener)\n```", "```py\n    await user_finished\n    await device_client.disconnect()\n```", "```py\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```", "```py\nimport sys\nfrom time import sleep\nfrom azure.iot.hub import IoTHubRegistryManager\nfrom azure.iot.hub.models import Twin, TwinProperties\n```", "```py\niothub_registry_manager = \\\nIoTHubRegistryManager(\"Service Connection String\")\n```", "```py\ntwin = iothub_registry_manager.get_twin(\"Device_id\")\ntwin_patch = Twin( properties= \\\nTwinProperties(desired={'Vision_Model_Version' : 1.2}))\ntwin = iothub_registry_manager.update_twin(DEVICE_ID, twin_patch, \n                                           twin.etag)\n```", "```py\nimport sys\nfrom time import sleep\nfrom azure.iot.hub import IoTHubRegistryManager\nfrom azure.iot.hub.models import Twin, TwinProperties, \\\nQuerySpecification, QueryResult\n```", "```py\nquery_spec = QuerySpecification(query=\"SELECT * FROM devices WHERE properties.reported.Vision_Model_Version <> 1.2\")\nquery_result = iothub_registry_manager.query_iot_hub(query_spec, None, 100)\nprint(\"Devices that did not update: {}\".format(', '.join([twin.device_id for twin in query_result.items])))\n```", "```py\nwget https://pjreddie.com/media/files/yolov3.weights\nwget https://raw.githubusercontent.com/microshak/AI_Benchtest_Device/yolov3.txt\nwget https://raw.githubusercontent.com/microshak/AI_Benchtest_Device/yolov3.cfg\n```", "```py\nfrom flask import Flask\ncpu = Flask(__name__)\n\nfrom CPU.Yolo import yolo\nfrom CPU.manifest import manifest\ncpu.register_blueprint(yolo)\ncpu.register_blueprint(manifest)\n```", "```py\nfrom flask_apscheduler import APScheduler\nfrom flask import Blueprint, request, jsonify, session\nimport requests\nimport socket\nimport json\nimport os\nmanifest = Blueprint('manifest','manifest',url_prefix='/manifest')\nscheduler = APScheduler()\n\ndef set_manifest():\n    f = open(\"manifest_cpu.json\", \"r\")\n    manifest = f.read()\n    data = json.loads(manifest)\n    data['host_name'] = socket.gethostname()\n    gw = os.popen(\"ip -4 route show default\").read().split()\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    s.connect((gw[2], 0))\n    ipaddr = s.getsockname()[0]\n\n    data['ip_address'] = ipaddr\n    url = 'https://ai-benchtest.azurewebsites.net/device'\n    r = requests.post(url = url, json =data)\n    txt = r.text\n\nset_manifest()\nscheduler.add_job(id ='Scheduled task', func =set_manifest, \n                  trigger = 'interval', minutes = 10)\nscheduler.start()\n```", "```py\nimport cv2\nimport pickle\nfrom io import BytesIO\nimport time\nimport requests\nfrom PIL import Image\nimport numpy as np\nfrom importlib import import_module\nimport os\nfrom flask import Flask, render_template, Response\nfrom flask import request\nimport imutils\nimport json\nimport requests\nfrom flask import Blueprint, request, jsonify, session\n```", "```py\nyolo = Blueprint('yolo', 'yolo', url_prefix='/yolo')\n```", "```py\nclasses = None\nCOLORS = np.random.uniform(0, 300, size=(len(classes), 3))\n```", "```py\nwith open(\"yolov3.txt\", 'r') as f:\n    classes = [line.strip() for line in f.readlines()]\n```", "```py\ndef get_output_layers(net):\n    layer_names = net.getLayerNames()\n    output_layers = [layer_names[i[0] - 1] for i in \n                     net.getUnconnectedOutLayers()]\n    return output_layers\n```", "```py\ndef draw_prediction(img, class_id, confidence, x, y, x_plus_w,\n                    y_plus_h):\n    label = str(classes[class_id])\n    color = COLORS[class_id]\n    cv2.rectangle(img, (x,y), (x_plus_w,y_plus_h), color, 2)\n    cv2.putText(img, label, (x-10,y-10), cv2.FONT_HERSHEY_SIMPLEX, \n                0.5, color, 2)\n```", "```py\ndef Yolo(image, net):\n    try:\n        Width = image.shape[1]\n        Height = image.shape[0]\n        scale = 0.00392\n\n        blob = cv2.dnn.blobFromImage(image, scale, (416,416), \n                                     (0,0,0), True, crop=False)\n```", "```py\n        net.setInput(blob)\n        outs = net.forward(get_output_layers(net))\n```", "```py\n        class_ids = []\n        confidences = []\n        boxes = []\n        conf_threshold = 0.5\n        nms_threshold = 0.4\n```", "```py\n        for out in outs:\n            for detection in out:\n                scores = detection[5:]\n                class_id = np.argmax(scores)\n                confidence = scores[class_id]\n                if confidence > 0.5:\n                    center_x = int(detection[0] * Width)\n                    center_y = int(detection[1] * Height)\n                    w = int(detection[2] * Width)\n                    h = int(detection[3] * Height)\n                    x = center_x - w / 2\n                    y = center_y - h / 2\n                    class_ids.append(class_id)\n                    confidences.append(float(confidence))\n                    boxes.append([x, y, w, h])\n```", "```py\n        indices = cv2.dnn.NMSBoxes(boxes, confidences, \n                                   conf_threshold,\n                                   nms_threshold)\n```", "```py\n        for i in indices:\n            i = i[0]\n            box = boxes[i]\n            x = box[0]\n            y = box[1]\n            w = box[2]\n            h = box[3]\n            draw_prediction(image, class_ids[i], \n                            confidences[i], round(x),\n                            round(y), round(x+w), \n                            round(y+h))\n```", "```py\n    return image\n```", "```py\ndef gen(height,width, downsample, camera):\n\n    net = cv2.dnn.readNet(\"yolov3.weights\", \"yolov3.cfg\")\n    while True:\n        url = f'http://{camera}:5000/image.jpg?\\\n        height={height}&width={width}'\n        r = requests.get(url) # replace with your ip address\n        curr_img = Image.open(BytesIO(r.content))\n```", "```py\n        frame = cv2.cvtColor(np.array(curr_img), cv2.COLOR_RGB2BGR)\n        dwidth = float(width) * (1 - float(downsample))\n        dheight = float(height) * (1 - float(downsample))\n        frame = imutils.resize(frame, width=int(dwidth), \n                               height=int(dheight))\n```", "```py\n        frame = Yolo(frame, net)\n\n        frame = cv2.imencode('.jpg', frame)[1].tobytes()\n        yield (b'--frame\\r\\n'\n               b'Content-Type: image/jpeg\\r\\n\\r\\n' + \n               frame + b'\\r\\n\\r\\n')\n```", "```py\n@yolo.route('/image.jpg')\ndef image():\n\n    height = request.args.get('height')\n    width = request.args.get('width')\n    downsample = request.args.get('downsample')\n    camera = request.args.get('camera')\n\n    \"\"\"Returns a single current image for the webcam\"\"\"\n    return Response(gen(height,width, downsample, camera), \n                    mimetype='multipart/x-mixed-replace; \n                    boundary=frame')\n```", "```py\n{\n     \"FriendlyName\":\"Thinkstation\",\n     \"name\":\"Thinkstation\",\n     \"algorithm\":[{\"name\":\"Object Detection\"\n                    ,\"category\":\"objectdetection\"\n                    ,\"class\":\"Computer Vision\"\n                    ,\"path\":\"yolo/image.jpg\"}\n\n     ]\n     , \"ram\":\"2gb\"\n     , \"cpu\": \"amd\"\n }\n```", "```py\n from os import environ\n from CPU import cpu\n\n if __name__ == '__main__':\n     HOST = environ.get('SERVER_HOST', '0.0.0.0')\n     try:\n         PORT = int(environ.get('SERVER_PORT', '8000'))\n     except ValueError:\n         PORT = 5555\n     cpu.run(HOST, PORT)\n```", "```py\ndocker-compose up\n```", "```py\ndocker build -t sample:dev . docker run -v ${PWD}:/app -v /app/node_modules -p 3001:3000 --rm sample:dev\n```"]