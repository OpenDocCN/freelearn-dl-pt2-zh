["```py\n    import pandas as pd\n    ```", "```py\n    data = pd.read_csv(\"energydata_complete.csv\")\n    data = data.drop(columns=[\"date\"])\n    data.head()\n    ```", "```py\n    cols = data.columns\n    num_cols = data._get_numeric_data().columns\n    list(set(cols) - set(num_cols))\n    ```", "```py\n    data.isnull().sum()\n    ```", "```py\n    outliers = {}\n    for i in range(data.shape[1]):\n        min_t = data[data.columns[i]].mean() – (3 *             data[data.columns[i[[.std())\n        max_t = data[data.columns[i]].mean() + (3 *             data[data.columns[i[[.std())\n\n        count = 0\n        for j in data[data.columns[i]]:\n            if j < min_t or j > max_t:\n                count += 1\n\n        percentage = count / data.shape[0]\n        outliers[data.columns[i]] = \"%.3f\" % percentage\n    ```", "```py\n    X = data.iloc[:, 1:]\n    Y = data.iloc[:, 0]\n    ```", "```py\n    X = (X - X.min()) / (X.max() - X.min())\n    X.head()\n    ```", "```py\n    X.shape\n    ```", "```py\n    train_end = int(len(X) * 0.6)\n    dev_end = int(len(X) * 0.8)\n    ```", "```py\n    X_shuffle = X.sample(frac=1)\n    Y_shuffle = Y.sample(frac=1)\n    ```", "```py\n    x_train = X_shuffle.iloc[:train_end,:]\n    y_train = Y_shuffle.iloc[:train_end]\n    x_dev = X_shuffle.iloc[train_end:dev_end,:]\n    y_dev = Y_shuffle.iloc[train_end:dev_end]\n    x_test = X_shuffle.iloc[dev_end:,:]\n    y_test = Y_shuffle.iloc[dev_end:]\n    ```", "```py\n    print(x_train.shape, y_train.shape)\n    print(x_dev.shape, y_dev.shape)\n    print(x_test.shape, y_test.shape)\n    ```", "```py\n    (11841, 27) (11841, )\n    (3947, 27) (3947, )\n    (3947, 27) (3947, )\n    ```", "```py\n    from sklearn.model_selection import train_test_split\n    ```", "```py\n    x_new, x_test_2, y_new, y_test_2 = train_test_split(X_shuffle, Y_shuffle, test_size=0.2, random_state=0)\n    dev_per = x_test_2.shape[0]/x_new.shape[0]\n    x_train_2, x_dev_2, y_train_2, y_dev_2 = train_test_split(x_new, y_new, test_size=dev_per, random_state=0)\n    ```", "```py\n    print(x_train_2.shape, y_train_2.shape)\n    print(x_dev_2.shape, y_dev_2.shape)\n    print(x_test_2.shape, y_test_2.shape)\n    ```", "```py\n    (11841, 27) (11841, )\n    (3947, 27) (3947, )\n    (3947, 27) (3947, )\n    ```", "```py\n    import torch\n    import torch.nn as nn\n    ```", "```py\n    x_train = torch.tensor(x_train.values).float()\n    y_train = torch.tensor(y_train.values).float()\n    x_dev = torch.tensor(x_dev.values).float()\n    y_dev = torch.tensor(y_dev.values).float()\n    x_test = torch.tensor(x_test.values).float()\n    y_test = torch.tensor(y_test.values).float()\n    ```", "```py\n    model = nn.Sequential(nn.Linear(x_train.shape[1], 100),\n                          nn.ReLU(),\n                          nn.Linear(100, 50),\n                          nn.ReLU(),\n                          nn.Linear(50, 25),\n                          nn.ReLU(),\n                          nn.Linear(25, 1))\n    ```", "```py\n    loss_function = torch.nn.MSELoss()\n    ```", "```py\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)\n    ```", "```py\n    for i in range(100):\n        y_pred = model(x_train)\n        loss = loss_function(y_pred, y_train)\n        print(i, loss.item())\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n    ```", "```py\n    pred = model(x_test[0])\n    print(y_test[0], pred)\n    ```"]