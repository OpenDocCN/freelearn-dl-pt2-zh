- en: '*Chapter 9*: Building a GPT-3-Powered Question-Answering App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：构建一个由 GPT-3 提供动力的问答app'
- en: Up to this point, we've looked at (and written) a lot of code. But we haven't
    actually created a fully functional app. Well, that's what we're going to do now.
    In this chapter, we're going to build a simple but powerful web app that lets
    users ask questions that GPT-3 will answer from a knowledge base we will provide.
    The app could be used to answer any kind of questions, but we're going to use
    it to answer questions people might have about us – an *ask me anything* app.
    So, imagine a website that recruiters or a potential employer could use to ask
    questions about your skills, accomplishments, and experience. Not looking for
    a new job? No problem. Again, this app can be used for just about any question-answering
    application – so maybe a GPT-3-powered product FAQ, or a GPT-3-powered teaching
    assistant – it's completely up to you. We'll start with a quick overview of how
    the app will work, then we'll step through the process of building it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了（并编写了）很多代码。但我们实际上还没有创建一个完全可用的app。那就是我们将要做的事情。在本章中，我们将构建一个简单但功能强大的
    Web app，让用户提出问题，由 GPT-3 从我们提供的知识库中回答。该app可用于回答任何类型的问题，但我们将用它来回答人们可能对我们有的问题 - 一个
    *问我任何事* 的 app。所以，想象一个招聘专员或潜在雇主可以用来询问你的技能、成就和经验的网站。不想找新工作？没问题。同样，这个app可以用于任何类型的问答应用
    - 所以可能是一个由 GPT-3 动力驱动的产品FAQ，或一个由 GPT-3 动力驱动的教学助手 - 这完全取决于你。我们将从app将如何工作的快速概述开始，然后逐步介绍构建过程。
- en: 'The topics we''ll cover are the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的主题如下：
- en: Introducing GPT Answers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 GPT Answers
- en: Introducing the Answers endpoint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Answers 端点
- en: Setting up and testing Express
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和测试 Express
- en: Creating the API endpoint for GPT Answers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 GPT Answers 创建 API 端点
- en: Creating the GPT Answers user interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 GPT Answers 用户界面
- en: Integrating the Answers endpoint
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合 Answers 端点
- en: Generating relevant and factual answers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成相关且准确的答案
- en: Using files with the Answers endpoint
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有 Answers 端点的文件
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires that you have access to the OpenAI API. You can request
    access by visiting [https://openapi.com](https://openapi.com).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要您访问 OpenAI API。您可以通过访问 [https://openapi.com](https://openapi.com) 来请求访问权限。
- en: Introducing GPT Answers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 GPT Answers
- en: In this section, we're going to be building a GPT-3-powered web app that lets
    users ask any questions and get back answers from a knowledge base of data that
    we'll provide. We will call the app **GPT Answers**. Yes, the name is underwhelming,
    but we can always use GPT-3 to help us brainstorm a better name later.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个由 GPT-3 提供动力的 Web app，让用户提出任何问题并从我们提供的数据知识库中获取答案。我们将称该app为 **GPT
    Answers**。是的，这个名称有点平淡，但我们可以随时使用 GPT-3 来帮助我们思考一个更好的名称。
- en: The following is a screenshot of what the app will look like when it's completed.
    Sure, the user interface might be as underwhelming as the name, but the power
    behind it is sure to impress!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完成时app外观的截图。是的，用户界面可能像名称一样平淡，但其背后的功能一定令人印象深刻！
- en: '![Figure 9.1 – GPT Answers user interface'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – GPT Answers 用户界面'
- en: '](img/B16854_09_001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_09_001.jpg)'
- en: Figure 9.1 – GPT Answers user interface
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – GPT Answers 用户界面
- en: Now let's get into what's behind the UI and how the app will be built.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解 UI 的后台以及 app 将如何构建。
- en: GPT Answers technical overview
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPT Answers 技术概述
- en: GPT Answers will be built using Node.js, JavaScript, and HTML. We'll also be
    using a web framework called Express, to simplify the development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: GPT Answers 将使用 Node.js、JavaScript 和 HTML 构建。我们还将使用一个名为 Express 的 Web 框架来简化开发。
- en: Important note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This app could also be built using Python but for this chapter, unlike the previous
    chapters, we'll only be covering the steps to create the app using Node.js/JavaScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该app也可以使用 Python 构建，但对于本章，与之前的章节不同，我们只会介绍使用 Node.js/JavaScript 创建app的步骤。
- en: Questions will be submitted through a simple web form that will use JavaScript
    to make requests to an API endpoint that the app will also expose. The app API
    will primarily act as a proxy for interacting with the OpenAI API, but it will
    also provide exception handling and response formatting.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 问题将通过一个简单的网页表单提交，该表单将使用 JavaScript 向app也暴露的 API 端点发送请求。该app的API 主要作为与 OpenAI
    API 交互的代理，但也将提供异常处理和响应格式化。
- en: Hosting the app
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托管该app
- en: Up to this point, we've only used [replit.com](http://replit.com) for writing
    and testing code. However, [replit.com](http://replit.com) also supports hosting
    apps and it's surprisingly easy to work with. For web apps, you can even use your
    own domain name. So, [replit.com](http://replit.com) is going to be our hosting
    environment as well as our development environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用[replit.com](http://replit.com)来编写和测试代码。但是，[replit.com](http://replit.com)还支持托管应用程序，并且使用起来非常容易。对于Web应用程序，您甚至可以使用自己的域名。因此，[replit.com](http://replit.com)将成为我们的托管环境以及开发环境。
- en: Important note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: GPT-3-powered apps need to be approved by OpenAI before they can be public-facing.
    We won't get into that in this chapter, but we'll cover the app approval process
    in [*Chapter 10*](B16854_10_ePub_AM.xhtml#_idTextAnchor187), *Going Live with
    OpenAI-Powered Apps*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由GPT-3支持的应用程序需要经过OpenAI批准才能向公众展示。我们在本章不会详细讨论此事，但我们将在[*第10章*](B16854_10_ePub_AM.xhtml#_idTextAnchor187)中涵盖应用程序批准流程，*与OpenAI技术的应用上线*。
- en: The main OpenAI endpoint the app will use is the Answers endpoint. But since
    we have not covered the Answers endpoint yet, let's do a quick introduction before
    we start coding.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将使用的主要OpenAI端点是答案端点。但是由于我们尚未涵盖答案端点，请在开始编码之前快速介绍一下。
- en: Introducing the Answers endpoint
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍答案端点
- en: The OpenAI Answers endpoint is specifically designed for question-answering
    tasks. It provides more control than the Completions endpoint by enabling the
    use of a source of truth for the answers. For our GPT Answers app, that source
    of truth will be a knowledge base that will be used for answering questions. The
    knowledge base (that is, documents) can be provided along with the endpoint request
    or by referencing a pre-uploaded file containing the data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI Answers端点专为问答任务而设计。它通过启用用于答案的真实来源而比Completions端点提供更多控制。对于我们的GPT Answers应用程序，这个真实来源将是用于回答问题的知识库。知识库（即文档）可以通过端点请求提供，也可以通过引用包含数据的预先上传的文件来提供。
- en: The URL for the Answers endpoint is [https://api.openai.com/v1/answers](https://api.openai.com/v1/answers)
    and the endpoint accepts an HTTP POST request and a number of input parameters.
    The following is a brief description of the available input parameters, but for
    more complete details, see the OpenAI docs for the Answers endpoint located at
    [https://beta.openai.com/docs/api-reference/answers](https://beta.openai.com/docs/api-reference/answers).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 答案端点的URL为 [https://api.openai.com/v1/answers](https://api.openai.com/v1/answers)，该端点接受HTTP
    POST请求和一些输入参数。以下是可用输入参数的简要描述，但有关更完整的详细信息，请参阅位于 [https://beta.openai.com/docs/api-reference/answers](https://beta.openai.com/docs/api-reference/answers) 的OpenAI文档的答案端点。
- en: 'Here are the required parameters:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是必填参数：
- en: '`model` (required, string) – The ID of the model that will be used for completions.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`（必填，字符串） - 将用于完成的模型的ID。'
- en: '`question` (required, string) – The question to be answered.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`question`（必填，字符串） - 要回答的问题。'
- en: '`examples` (required, array) – A list of questions with answers to help steer
    the model toward the tone and answer format for the answer.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`examples`（必填，数组） - 问题列表，带有答案，以帮助引导模型朝着答案的语气和格式前进。'
- en: '`examples_context` (required, string) – A text snippet containing the contextual
    information used to generate the answers for the examples you provide.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`examples_context`（必填，字符串） - 包含用于为您提供的示例生成答案的上下文信息的文本片段。'
- en: '`documents` (array) – A list of documents from which the answer for the input
    question should be derived. If the `documents` parameter is an empty list, the
    question will be answered based on the question-answer examples. Also, the `documents`
    parameter is only required if the `file` parameter is not used.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`documents`（数组） - 应从中提取输入问题的答案的文档列表。如果`documents`参数是空列表，则将根据问题 - 答案示例来回答问题。另外，仅在不使用`file`参数时才需要`documents`参数。'
- en: '`file` (string) – The ID of an uploaded file containing documents to derive
    the answer from. The `file` parameter is only required if the `documents` parameter
    is not used.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`（字符串） - 包含要从中提取答案的文档的上传文件的ID。如果未使用`documents`参数，则仅需要`file`参数。'
- en: 'The optional parameters are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数如下：
- en: '`search_model` (string) – The engine to use for search. This defaults to `ada`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search_model`（字符串） - 用于搜索的引擎。默认为`ada`。'
- en: '`max_rerank` (integer) – The maximum number of documents to be. A higher value
    can improve accuracy but will increase the latency and cost. This defaults to
    `200`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_rerank`（整数）- 要处理的文档的最大数量。较高的值可以提高准确性，但会增加延迟和成本。默认为`200`。'
- en: '`temperature` (number) – Defaults to `0`, which is best for well-defined answers,
    but a higher value can be used for less deterministic answers.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temperature`（数字）- 默认为`0`，适用于定义明确答案，但较高的值可用于较不确定的答案。'
- en: '`logprobs` (integer) – Defaults to `null`. The number of likely probable tokens
    to return.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logprobs`（整数）- 默认为`null`。返回的可能标记数量。'
- en: '`max_tokens` (integer) – The maximum number of tokens that will be used to
    generate an answer. Defaults to `16`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_tokens`（整数）- 将用于生成答案的最大标记数量。默认为`16`。'
- en: '`stop` (string or array) – An optional sequence of up to four patterns that
    will cause the API to stop generating a completion. This defaults to `null`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`（字符串或数组）- 可选的最多四个模式序列，将导致API停止生成完成。默认为`null`。'
- en: '`n` (integer) – The number of answers to generate for each question. This defaults
    to `1`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`（整数）- 为每个问题生成的答案数量。默认为`1`。'
- en: '`logit_bias` (map) – Can be used to control the likelihood of specified tokens
    appearing in the completion.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logit_bias`（映射）- 可以用于控制指定标记出现在完成中的可能性。'
- en: '`return_metadata` (Boolean) – If the `file` parameter is used and the file
    referenced includes metadata, this will cause the response to include the metadata
    from the file.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return_metadata`（布尔值）- 如果使用了`file`参数并且文件引用包含元数据，则导致响应包含来自文件的元数据。'
- en: '`return_prompt` (Boolean) – Causes the prompt text to be returned with the
    response. This defaults to `false`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return_prompt`（布尔值）- 导致将提示文本与响应一起返回。默认为`false`。'
- en: '`expand` (array) – Causes the response to include details about the completion
    or file. The value of `expand` can currently include `completion` and `file`.
    This defaults to an empty array.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expand`（数组）- 导致响应包含关于完成或文件的详细信息。`expand`的值当前可以包括`completion`和`file`。默认为一个空数组。'
- en: Important note
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: We won't be using all of the available parameters for our GPTAMA app.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的GPTAMA应用程序，我们将不会使用所有可用的参数。
- en: Now that we've done a quick introduction to the Answers endpoint, let's get
    to coding up our GPTAMA app!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Answers端点进行了快速介绍，让我们开始编写我们的GPTAMA应用程序！
- en: Setting up and testing Express
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和测试Express
- en: Express is a lightweight but flexible web application framework for Node.js
    that we'll be using for the app. It's pretty easy to get it up and running, especially
    with Replit.com. So, the first thing we'll do is get Express set up on Replit.com
    and test it out. We'll be starting from scratch, so we'll be creating a new repl
    for GPTAMA.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Express是用于Node.js的轻量级但灵活的Web应用程序框架，我们将在应用程序中使用它。通过Replit.com，它非常容易上手。所以，我们要做的第一件事是在Replit.com上设置Express并进行测试。我们将从头开始，因此我们将为GPTAMA创建一个新的repl。
- en: 'To create a new Node.js REPL and set up Express, complete the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的Node.js REPL并设置Express，请完成以下步骤：
- en: Log in at [replit.com](http://replit.com).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[replit.com](http://replit.com)登录。
- en: Create a new Node.js REPL named **gptanswers-node**.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**gptanswers-node**的新Node.js REPL。
- en: 'In the output pane, click on the **Shell** tab and enter this command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出窗格中，单击**Shell**选项卡，然后输入此命令：
- en: '[PRE0]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the previous command by pressing the *Enter* key and you should see a result
    that looks like the following screenshot:![Figure 9.2 – Output from express-generator
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下*Enter*键运行上一个命令，您应该会看到一个类似以下截图的结果：![图9.2 - express-generator的输出
- en: '](img/B16854_09_002.jpg)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_09_002.jpg)'
- en: Figure 9.2 – Output from express-generator
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.2 - express-generator的输出
- en: Important note
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `npx` command is included with NPM, which is installed with Node.js. It
    is used to run `express-generator`, which creates a basic Express app as a starting
    point. The command ends with a period to instruct `express-generator` to add files
    to the current directory. The `--no-view` switch tells the generator we're just
    using plain HTML for our UI and the `--force` switch tells the generator to overwrite
    any existing files in the current directory.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npx`命令包含在NPM中，NPM与Node.js一起安装。它用于运行`express-generator`，该生成器将创建一个基本的Express应用程序作为起点。命令以句点结尾，以指示`express-generator`将文件添加到当前目录。`--no-view`开关告诉生成器我们只是使用纯HTML作为我们的UI，`--force`开关告诉生成器覆盖当前目录中的任何现有文件。'
- en: 'After `express-generator` completes, run the following command in the shell:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`express-generator`完成后，在shell中运行以下命令：'
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now create a file named `.replit` and add the following `Run` command to it:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个名为`.replit`的文件，并将以下`Run`命令添加到其中：
- en: '[PRE2]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, click the **Run** button to start the Express server. If all went
    well, you should see a browser window open in the Replit.com editor with a welcome
    message from Express. It should look like the following screenshot:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**Run**按钮启动Express服务器。如果一切顺利，您应该在Replit.com编辑器中看到一个打开的浏览器窗口，其中显示Express的欢迎消息。它应如下图所示：
- en: '![Figure 9.3 – Express server running in Replit.com'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – 在Replit.com中运行的Express服务器'
- en: '](img/B16854_09_003.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_09_003.jpg)'
- en: Figure 9.3 – Express server running in Replit.com
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 在Replit.com中运行的Express服务器
- en: Two things to note are the URL in the browser pane and that the **Run** button
    became a **Stop** button. This is because Express is running an HTTP server that
    will continue running until it's stopped. So, the app is available on the web
    and is accessible via the URL in the browser pane while the Express server is
    running. Also, when you make changes, you'll need to stop and restart Express
    by clicking the **Stop** button and then the **Run** button.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的两件事是浏览器窗格中的URL以及**Run**按钮变成了**Stop**按钮。这是因为Express正在运行一个HTTP服务器，该服务器将持续运行，直到停止。因此，在Express服务器运行时，应用程序可在网上访问，并通过浏览器窗格中的URL访问。此外，当您进行更改时，您需要点击**Stop**按钮然后点击**Run**按钮来停止和重新启动Express。
- en: If you run into any issues and don't see the Express page, you can go through
    the steps in this section again without hurting anything. When you see the Express
    welcome page, you're all set to move on. Next, we'll create an API endpoint for
    our GPT Answers app.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到任何问题，并且看不到Express页面，您可以再次按照本节的步骤操作而不会损坏任何内容。当您看到Express的欢迎页面时，您就可以继续进行。接下来，我们将为我们的GPT
    Answers应用程序创建API端点。
- en: Creating the API endpoint for GPT Answers
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为GPT Answers创建API端点
- en: When our app is complete, we'll have a fully functional API endpoint that can
    return answers generated by the OpenAI API. But for now, we'll just create an
    endpoint that returns a placeholder response. Then, we'll test the endpoint using
    Postman and we'll come back later and finish coding it up.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序完成时，我们将拥有一个完全功能的API端点，可以返回由OpenAI API生成的答案。但现在，我们将只创建一个返回占位符响应的端点。然后，我们将使用Postman测试端点，稍后再回来完成编码。
- en: Creating the API endpoint
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建API端点
- en: 'To create the API endpoint, do the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建API端点，请执行以下操作：
- en: Open the `app.js` file that was created by `express-generator`. The file should
    look like the following screenshot:![Figure 9.4 – Default app.js created by express-generator
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开由`express-generator`创建的`app.js`文件。该文件应如下图所示：![图9.4 – 由express-generator创建的默认app.js文件
- en: '](img/B16854_09_004.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_09_004.jpg)'
- en: Figure 9.4 – Default app.js created by express-generator
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.4 – 由express-generator创建的默认app.js文件
- en: 'Edit *line 7* and change `var usersRouter = require(''./routes/users'')` to
    the following:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑*第7行*，将`var usersRouter = require('./routes/users')`更改为以下内容：
- en: '[PRE3]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Edit *line 18* and change `app.use(''/users'', usersRouter);` to the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑*第18行*，将`app.use('/users', usersRouter);`更改为以下内容：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After editing lines *7* and *18*, the `app.js` file should look like the following
    screenshot:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑*第7*行和*18*行后，`app.js`文件应如下图所示：
- en: '![Figure 9.5 – Edited app.js file'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.5 – 编辑后的app.js文件'
- en: '](img/B16854_09_005.jpg)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_09_005.jpg)'
- en: Figure 9.5 – Edited app.js file
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.5 – 编辑后的app.js文件
- en: Delete the `routes/users.js` file.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`routes/users.js`文件。
- en: Create a new file, `routes/answer.js`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`routes/answer.js`。
- en: 'Add the following code to the `answers.js` file:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码到`answers.js`文件中：
- en: '[PRE5]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Click the **Stop** button and then **Start**. You should see the **Welcome to
    E****xpress** message again.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Stop**按钮，然后**Start**。您应该再次看到**Welcome to E****xpress**的消息。
- en: The API endpoint we created accepts an HTTP `/answer`. But since it accepts
    an HTTP POST, we'll need to test it by making a POST request. To do that, we'll
    use Postman.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的API端点接受HTTP`/answer`。但由于它接受HTTP POST，我们需要通过进行POST请求来测试它。为了做到这一点，我们将使用Postman。
- en: Testing our API with Postman
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Postman测试我们的API
- en: 'At this point, we should be able to make an HTTP POST request to our `/answer`
    endpoint and get a response. To complete the test, copy the app URL from the [Replit.com](http://Replit.com)
    browser (the one showing the Express welcome message) to your clipboard:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该能够向我们的`/answer`端点进行HTTP POST请求并获得响应。要完成测试，请将从[Replit.com](http://Replit.com)浏览器（显示Express欢迎消息的浏览器）复制到剪贴板的应用程序URL：
- en: Open a new browser tab and log in to [https://postman.com](https://postman.com).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器选项卡并登录到[https://postman.com](https://postman.com)。
- en: Create a new collection named `gptanswers-node`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`gptanswers-node`的新集合。
- en: 'Create a new request named `test-answer-api` in the `answer` (`/answer`). The
    format of the endpoint URL is as follows but where `{username}` is your Replit.com
    username (assuming you named the repl `gptanswers-node`):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/answer` 中创建一个名为 `test-answer-api` 的新请求。端点URL的格式如下，其中`{username}` 是你的 Replit.com
    用户名（假设你将repl命名为 `gptanswers-node`）：
- en: '[PRE6]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Below the endpoint URL input, select the **Body** tab, choose the **Raw** radio
    button, and choose **JSON** from the dropdown for the content type.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端点URL输入框下方，选择 **Body** 选项卡，选择 **Raw** 单选按钮，并从内容类型下拉列表中选择 **JSON**。
- en: 'Finally, add the following JSON for the request body:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下JSON请求体：
- en: '[PRE7]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After setting up the request in Postman, it should look something like the
    following screenshot:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在设置Postman请求后，它应该像以下的屏幕截图：
- en: '![Figure 9.6 – Postman request to test the GPT-CV app API endpoint'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.6 – 在Postman中测试GPT-CV应用程序API端点的请求。'
- en: '](img/B16854_09_006.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_09_006.jpg)'
- en: Figure 9.6 – Postman request to test the GPT-CV app API endpoint
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.6 – 在Postman中测试GPT-CV应用程序API端点的请求。
- en: 'Click the blue **Send** button to submit the request and review the response,
    which should be the following:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色 **Send** 按钮提交请求并查看响应，应如下所示：
- en: '[PRE8]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Okay, now that we have our API endpoint responding, we'll move on to creating
    a web form to call the API.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经得到API端点的回应，接下来我们将创建一个Web表单来调用API。
- en: Creating the GPT Answers user interface
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建GPT Answers用户界面。
- en: Now let's create a simple web form interface that will let users submit a question
    to get an answer from our API. We'll start by adding **UIkit** – a popular lightweight
    frontend framework that you can learn more about at [https://getuikit.com/](https://getuikit.com/).
    We'll also use **Axios** to make HTTP calls to the app API using a bit of JavaScript.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的Web表单界面，让用户提交问题以从我们的API获取答案。我们将从添加 **UIkit** 开始 – 这是一个流行的轻量级前端框架，你可以在
    [https://getuikit.com/](https://getuikit.com/) 了解更多信息。我们还将使用 **Axios** 使用一些JavaScript来对应用程序API进行HTTP调用。
- en: UIkit will make it easy to create a simple but clean and modern look for our
    app. You can download UIkit for free from [https://getuikit.com](https://getuikit.com).
    Or you can use a hosted version that is available from [https://jsdeliver.com](https://jsdeliver.com),
    a free **Content Delivery Network** (**CDN**) for open source projects, and that's
    what we'll be using.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: UIkit将使我们的应用程序拥有简单但干净和现代的外观。你可以从 [https://getuikit.com](https://getuikit.com)
    免费下载UIkit，或者你可以使用一个托管版本，该版本可从 [https://jsdeliver.com](https://jsdeliver.com) 获得，那就是我们将要使用的。
- en: 'To add UIkit, do the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加UIkit，请执行以下操作：
- en: Open the `public/index.html` file.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `public/index.html` 文件。
- en: Replace the URL for the style sheet with [https://cdn.jsdelivr.net/npm/uikit@3.6.22/dist/css/uikit.min.css](https://cdn.jsdelivr.net/npm/uikit@3.6.22/dist/css/uikit.min.css).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用[https://cdn.jsdelivr.net/npm/uikit@3.6.22/dist/css/uikit.min.css](https://cdn.jsdelivr.net/npm/uikit@3.6.22/dist/css/uikit.min.css)替换样式表的URL。
- en: 'Replace everything between the `<body>` tag and the `</body>` tag with the
    following:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码替换 `<body>` 标签和 `</body>` 标签之间的所有内容：
- en: '[PRE9]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code above the `</body>` tag. This will add references to
    JavaScript files the page will use. Three of the scripts we''ll get from a CDN
    and one, the `/javascripts/script.js` file, we''ll create in the next step:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`</body>`标签上方添加以下代码。这将添加页面使用的JavaScript文件的引用。其中三个脚本将来自CDN，一个 `/javascripts/script.js`，我们将在下一步中创建它：
- en: '[PRE10]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, the code in `public/index.html` should look like the following
    screenshot:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，`public/index.html` 文件的代码应如图所示：
- en: '![Figure 9.7 – Completed index.html code'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.7 – 完成的 `index.html` 代码'
- en: '](img/B16854_09_007.jpg)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_09_007.jpg)'
- en: Figure 9.7 – Completed index.html code
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.7 – 完成的 `index.html` 代码
- en: 'If you stop and restart the Express server by clicking the **Stop** button
    followed by clicking the **Run** button, you should see the home screen updated
    to look like the following screenshot:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你点击 **Stop** 按钮然后点击 **Run** 按钮停止并重新启动 Express服务器，你会看到主屏幕更新为如下屏幕截图的样子：
- en: '![Figure 9.8 – Question input form'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.8 – 问题输入表单'
- en: '](img/B16854_09_008.jpg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_09_008.jpg)'
- en: Figure 9.8 – Question input form
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.8 – 问题输入表单
- en: Now we need to add some JavaScript to make the call to the app API.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们需要添加一些JavaScript来调用应用程序API。
- en: Create the `javascripts/script.js` file and add the following code.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `javascripts/script.js` 文件并添加以下代码。
- en: 'First, we''ll add two variables to hold the HTML form and answer `div`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加两个变量来保存HTML表单和答案 `div`：
- en: '[PRE11]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we''ll add code that will fire when the form is submitted:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加当提交表单时触发的代码：
- en: '[PRE12]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code will append the text to the answer `div`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码将将文本附加到答案`div`中：
- en: '[PRE13]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we''ll add a function to call the app API endpoint using Axios:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个函数，使用 Axios 调用应用程序的 API 端点：
- en: '[PRE14]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we can test it by clicking the **Stop** button and then the **Start** button.
    Then, in the browser pane, enter a question into the textbox and click the **GET
    ANSWER** button. You should see the API respond back with **placeholder for the
    answer** as shown in the following screenshot:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过点击**Stop**按钮，然后点击**Start**按钮来进行测试。然后，在浏览器窗格中，在文本框中输入一个问题，然后点击**GET ANSWER**按钮。你应该会看到
    API 回复的**占位符答案**，如下图所示：
- en: '![Figure 9.9 – Testing the web UI with the placeholder API code'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – 使用占位符 API 代码测试 Web UI'
- en: '](img/B16854_09_009.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_09_009.jpg)'
- en: Figure 9.9 – Testing the web UI with the placeholder API code
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 使用占位符 API 代码测试 Web UI
- en: At this point, we have the basic framework for our application in place. What
    we need to do next is write a bit of code to pass the question on to the OpenAI
    API Answers endpoint.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经搭建好了应用程序的基本框架。接下来，我们需要做的是写一些代码，将问题传递给 OpenAI API 答案端点。
- en: Integrating the Answers endpoint
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成答案端点
- en: 'Now we''ll go back and add some code to our `routes/answer.js` file so that
    it calls the OpenAI Answers endpoint to answer the user''s question, rather than
    returning the placeholder text:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将返回到`routes/answer.js`文件中添加一些代码，以便调用 OpenAI Answers 端点来回答用户的问题，而不是返回占位符文本：
- en: Open the `routes/answer.js` file and do the following.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`routes/answer.js`文件并执行以下操作。
- en: Delete all of the code after *line 5*.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 *第 5 行* 之后的所有代码。
- en: 'Starting on *line 5*, add the following code followed by a line return:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *第 5 行* 开始，添加以下代码，然后换行：
- en: '[PRE15]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, add the following code with a line return after it:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码并在其后换行：
- en: '[PRE16]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code starting on *line 16* followed by a line return:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *第 16 行* 开始添加以下代码，然后换行：
- en: '[PRE17]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, beginning on *line 18*, add the following to complete the code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从 *第 18 行* 开始添加以下内容以完成代码：
- en: '[PRE18]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you''re done editing `routes/answer.js`, the file will look like the following
    screenshot:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你编辑完`routes/answer.js`文件后，文件应该像以下屏幕截图所示：
- en: '![Figure 9.10 – Edited routes/answer.js file'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.10 – 编辑后的 routes/answer.js 文件'
- en: '](img/B16854_09_010.jpg)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_09_010.jpg)'
- en: Figure 9.10 – Edited routes/answer.js file
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.10 – 编辑后的 routes/answer.js 文件
- en: We're just about done. The final step before testing is to add our OpenAI API
    key as an environment variable.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们快要完成了。在测试之前的最后一步是将我们的 OpenAI API 密钥添加为环境变量。
- en: Add your OpenAI API key as a secret for the REPL by clicking the padlock icon
    and adding a key with the name `OPENAI_API_KEY` and the value of your OpenAI API
    key, like the example in the following screenshot:![Figure 9.11 – Add a secret
    for your OpenAI API key
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过点击挂锁图标并添加一个名为`OPENAI_API_KEY`的密钥和您的 OpenAI API 密钥的值来将您的 OpenAI API 密钥添加为
    REPL 的秘密，就像以下屏幕截图中的示例一样: ![图 9.11 – 为 OpenAI API 密钥添加一个秘密'
- en: '](img/B16854_09_011.jpg)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_09_011.jpg)'
- en: Figure 9.11 – Add a secret for your OpenAI API key
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.11 – 为 OpenAI API 密钥添加一个秘密
- en: 'Click the **Stop** button followed by **Run** to restart Express and then enter
    **What is your favorite food?** into the question text field and click the **GET
    ANSWER** button. You should see something like the following screenshot – an answer
    coming from GPT-3:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Stop**按钮，然后点击**Run**重新启动 Express，然后在问题文本框中输入**你最喜欢的食物是什么？**，然后点击**GET ANSWER**按钮。你应该会看到像以下屏幕截图展示的内容——来自
    GPT-3 的答案：
- en: '![Figure 9.12 – Answer from GPT-3'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12 – 来自 GPT-3 的答案'
- en: '](img/B16854_09_012.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_09_012.jpg)'
- en: Figure 9.12 – Answer from GPT-3
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 来自 GPT-3 的答案
- en: We now have a simple but functional GPT-3-powered question-answering app. However,
    you might be wondering why we're getting a response (an answer) for **What is
    your favorite food?** when we haven't provided an answer for that. We'll discuss
    that next.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个简单但功能齐全的基于 GPT-3 的问答应用。然而，您可能想知道为什么我们在**你最喜欢的食物是什么？**这个问题上得到了回应（一个答案），当我们还没有给出那个答案。我们将在后面讨论这个问题。
- en: Generating relevant and factual answers
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成相关且真实的答案
- en: GPT-3 is a language model – it predicts the statistical likelihood of the text
    that should follow the prompt text it was provided. It's not a knowledge base
    in the sense that it's concerned much with the factual accuracy of the responses
    it generates. That doesn't mean it won't generate factual answers; it just means
    you can't count on the answers being accurate all of the time. But the Answers
    endpoint can provide a lot of control over the accuracy or relevancy of the answers
    that will get generated.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: GPT-3是一个语言模型 - 它预测应该跟随提供的提示文本的文本的统计可能性。从某种意义上说，它不是一个知识库，它并不太关心所生成的响应的事实准确性。这并不意味着它不会生成事实性答案；这只是意味着你不能指望所有时间答案都是准确的。但是
    Answers 端点可以提供对所生成答案的准确性或相关性的很多控制。
- en: As we discussed earlier in *Introducing the Answers endpoint*, answers will
    be generated from the documents we provide. At this point, we're providing documents
    as part of the endpoint request. Using that method, if the answer can't be derived
    from the documents, the engine defined by the `routes/answer.js` file – we used
    the `Curie` engine. But let's say we only want answers to be derived from our
    documents and we don't want to return answers otherwise. While we don't have 100%
    control over that, we can use a pre-uploaded file to get us pretty close.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在 *介绍 Answers 端点* 中讨论的那样，答案将从我们提供的文档中生成。在这一点上，我们是作为端点请求的一部分提供文档的。使用这种方法，如果答案无法从文档中推导出来，由
    `routes/answer.js` 文件定义的引擎 - 我们使用了 `Curie` 引擎。但是假设我们只希望答案从我们的文档中推导出来，否则我们不希望返回答案。虽然我们无法完全控制这一点，但我们可以使用预先上传的文件使我们接近实现这一点。
- en: When pre-uploaded files are used with the Answers endpoint, you're not limited
    to just 200 documents like you are when you provide documents with the HTTP request.
    In fact, a pre-uploaded file might contain a very large number of documents because
    you can have up to 1 GB of file space per organization. Because a file might contain
    a very large number of documents, a keyword filter is applied to the documents
    in the file to narrow the possible documents that could be used for the answer.
    From there, the documents are ranked and then used by the engine defined by the
    model parameter to generate the answer. When you send documents with a request
    parameter, the keyword filtering is skipped because the number of documents you
    can send is limited to 200\. For our GPT Answers app, keyword filtering will help
    us decrease the chances that irrelevant questions will be answered. So, let's
    take a look at using files with the Answers endpoint.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Answers 端点时使用预先上传的文件时，与使用 HTTP 请求提供文档时一样，你不仅仅限于只有 200 个文档。事实上，预先上传的文件可能包含非常多的文档，因为每个组织可以拥有最多
    1 GB 的文件空间。因为一个文件可能包含非常多的文档，所以对文件中的文档应用关键字过滤器以缩小可能用于答案的文档范围。从那里开始，文档被排名，然后由模型参数定义的引擎使用以生成答案。当你使用请求参数发送文档时，关键字过滤将被跳过，因为你可以发送的文档数量限制为
    200 个。对于我们的 GPT Answers 应用程序，关键字过滤将帮助我们减少回答无关问题的可能性。所以，让我们看一下如何使用 Answers 端点中的文件。
- en: Using files with the Answers endpoint
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Answers 端点的文件
- en: 'To use documents from a file, the first thing we''ll need to do is get the
    file uploaded to OpenAI so it can be used by the Answers endpoint. The process
    involves creating a file containing our documents, then using the **files endpoint**
    to upload the file and get a file ID that can be used when we make requests to
    the Answers endpoint. To create and upload the answer file, complete the following
    steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用文件中的文档，我们需要做的第一件事是将文件上传到 OpenAI，以便 Answers 端点可以使用它。该过程涉及创建一个包含我们文档的文件，然后使用
    **文件端点** 将文件上传并获取可在对 Answers 端点发出请求时使用的文件 ID。要创建和上传答案文件，请完成以下步骤：
- en: 'Create a new `jsonl` file named `answers.jsonl` and some answers for the file
    in the following format:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `answers.jsonl` 的新的`jsonl`文件，并为文件中的一些答案编写如下格式的答案：
- en: '[PRE19]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Create another new file named `files-upload.js`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `files-upload.js` 的新文件。
- en: 'Add the following code in `file-upload.js`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `file-upload.js` 中添加以下代码：
- en: 'Require a few modules that will be used:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要几个将要使用的模块：
- en: '[PRE20]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, add the following code to read in the `jsonl` data for the request:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码来读取请求的 `jsonl` 数据：
- en: '[PRE21]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a variable for the HTTP request parameters:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个变量用于 HTTP 请求参数：
- en: '[PRE22]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, add code to make the HTTP request and log results:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加代码以进行 HTTP 请求并记录结果：
- en: '[PRE23]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you''re done editing `files-upload.js`, it should look like the code in
    the following screenshot:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当编辑完 `files-upload.js` 后，它应该像以下截图中的代码一样：
- en: '![Figure 9.13 – Completed code for file-upload.js'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.13 – file-upload.js的完成代码'
- en: '](img/B16854_09_013.jpg)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_09_013.jpg)'
- en: Figure 9.13 – Completed code for file-upload.js
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.13 – file-upload.js的完成代码
- en: In the output pane, click on the **Shell** tab.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出窗格中，点击**Shell**选项卡。
- en: 'At the `~/gptanswers-node` prompt, enter the following command with your OpenAI
    API key:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`~/gptanswers-node`提示符处，输入以下命令并附上你的OpenAI API密钥：
- en: '[PRE24]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, enter the following command in the shell:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在shell中输入以下命令：
- en: '[PRE25]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After running the previous shell commands, you should see a result like the
    output in the following screenshot:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行上述shell命令后，你应该会看到类似以下截图的输出结果：
- en: '![Figure 9.14 – Shell output from files-upload.js'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.14 – files-upload.js的Shell输出'
- en: '](img/B16854_09_014.jpg)'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_09_014.jpg)'
- en: Figure 9.14 – Shell output from files-upload.js
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.14 – files-upload.js的Shell输出
- en: Copy the `id` value from the JSON results (the value that begins with `file-`)
    to your clipboard.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从JSON结果中复制`id`值（以`file-`开头的值）到剪贴板。
- en: Click on the padlock icon and create a new secret/environment variable named
    `ANSWERS_FILE` and paste the ID value you copied in the last step into the value
    input, then click the **Add new secret** button.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击小锁图标并创建一个名为`ANSWERS_FILE`的新秘密/环境变量，并将你在上一步中复制的ID值粘贴到值输入中，然后点击**添加新的秘密**按钮。
- en: Open `routes/answer.js` and rename the `documents` parameter on *line 20* to
    `file`. Then replace the `documents` value with `process.env.ANSWERS_FILE`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`routes/answer.js`并将*第20行*的`documents`参数重命名为`file`。然后用`process.env.ANSWERS_FILE`替换`documents`值。
- en: 'After the previous update, *line 20* should look like *line 20* in the following
    screenshot:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一个更新后，*第20行*应该看起来像以下截图中的*第20行*：
- en: '![Figure 9.15 – The Answers endpoint parameters using the file parameter'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.15 – 使用文件参数的Answers端点参数'
- en: '](img/B16854_09_015.jpg)'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16854_09_015.jpg)'
- en: Figure 9.15 – The Answers endpoint parameters using the file parameter
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.15 – 使用文件参数的Answers端点参数
- en: At this point, you are ready to test.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，你已经准备好测试了。
- en: 'Click the **Run** button, then enter **What is your favorite food?** in the
    question input followed by clicking the **GET ANSWER** button. This time you''ll
    notice that the answer was generated from our answers file, as the following screenshot
    shows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮，然后在问题输入中输入**你最喜欢的食物是什么？**，然后点击**获取答案**按钮。这次你会注意到答案是从我们的答案文件中生成的，就像以下截图所示：
- en: '![Figure 9.16 – An answer generated from the answers file'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16 – 从答案文件生成的答案'
- en: '](img/B16854_09_016.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_09_016.jpg)'
- en: Figure 9.16 – An answer generated from the answers file
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 从答案文件生成的答案
- en: 'But now if you enter a question that''s not related at all to the data in your
    file, the response will be **Sorry, I don''t have an answer**. You can test this
    by asking something such as **Do you sell this one in red?** You should see a
    result like the one shown in the following screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，如果你输入一个与你的文件中的数据完全无关的问题，响应将会是**对不起，我没有答案**。你可以尝试询问诸如**你们有红色的这个吗？**这样的问题。你应该会看到一个类似以下截图的结果：
- en: '![Figure 9.17 – A question that can''t be answered'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.17 – 无法回答的问题'
- en: '](img/B16854_09_017.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_09_017.jpg)'
- en: Figure 9.17 – A question that can't be answered
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 无法回答的问题
- en: 'An important thing to keep in mind is that both the answers file and the completion
    engine (`Curie` in our case) are used to generate the answer. So, it''s possible
    to get an answer that isn''t represented in your file. However, the more data
    you have in your answers file, the less likely that will be. But because we just
    have three documents in our answers file now, if you ask a question such as **What
    is your favorite vacation spot?**, you might see a response with an answer that
    isn''t defined in your answers file, as the following screenshot shows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事情要记住的是，答案文件和完成引擎（在我们的案例中是`Curie`）都用于生成答案。因此，有可能得到一个在你的文件中没有定义的答案。但是，你的答案文件中的数据越多，这种可能性就越小。但是因为我们现在只有三个文档在我们的答案文件中，所以如果你问类似**你最喜欢的度假地点是什么？**这样的问题，你可能会看到一个在你的答案文件中没有定义的答案，就像以下截图所示：
- en: '![Figure 9.18 – An answer that isn''t from the answers file'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18 – 不是来自答案文件的答案'
- en: '](img/B16854_09_018.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16854_09_018.jpg)'
- en: Figure 9.18 – An answer that isn't from the answers file
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 – 不是来自答案文件的答案
- en: So, even though we're providing answers in our answers file, that doesn't guarantee
    GPT-3 won't generate an answer that isn't accurate. But we'll discuss this more
    later in this chapter and in [*Chapter 10*](B16854_10_ePub_AM.xhtml#_idTextAnchor187),
    *Going Live with OpenAI-Powered Apps*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使我们在答案文件中提供答案，也不能保证 GPT-3 不会生成不准确的答案。但我们稍后将在本章和[*第 10 章*](B16854_10_ePub_AM.xhtml#_idTextAnchor187)，*使用
    OpenAI-Powered 应用程序上线*中讨论这一点。
- en: 'At this point, we have a fully functional app. Of course, there is a lot more
    we could add to polish our app, but the core functionality is in place. The main
    thing you''ll need to do is add more documents to the answers file. To do that,
    complete the following steps each time you want to add new data:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个完全功能的应用程序。当然，我们可以添加更多功能来完善我们的应用程序，但核心功能已经就位。你需要做的主要事情是向答案文件中添加更多文档。要做到这一点，每次想要添加新数据时，请完成以下步骤：
- en: Add new documents to the `answers.jsonl` file.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `answers.jsonl` 文件添加新文档。
- en: Open the shell.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 shell。
- en: 'Run the following shell command to set your API key as an environment variable
    that the shell can access:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下 shell 命令将你的 API 密钥设置为 shell 可以访问的环境变量：
- en: '[PRE26]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the following command in the shell to execute `files-upload.js`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 shell 中运行以下命令以执行 `files-upload.js`：
- en: '[PRE27]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Copy the file `ANSWERS_FILE` environment variable by clicking the padlock icon
    and replacing the value with the **ANSWERS_FILE** secret.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击锁图标并替换值为 **ANSWERS_FILE** 机密，复制文件 `ANSWERS_FILE` 环境变量。
- en: Click the **Stop** button and then the **Run** button to restart Express.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击 **停止** 按钮，然后单击 **运行** 按钮重新启动 Express。
- en: Again, more data in your answers file will minimize the chances of non-factual
    answers. But it's still possible that GPT-3 will generate answers that clearly
    aren't from your answers file. So, it's still important to consider content filtering,
    which is why we'll be covering that more in the next chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你的答案文件中有更多数据将减少出现非事实性答案的机会。但 GPT-3 仍然可能生成明显不是来自你的答案文件的答案。因此，考虑内容过滤仍然很重要，这也是我们将在下一章中更详细介绍的原因。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we introduced the Answers endpoint and used Node.js/JavaScript
    to build a simple but functional web application that can answer questions from
    documents we provide. For our applications, we created an API that acts as a proxy
    to the OpenAI API and an HTML page that provides the user interface.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了答案端点，并使用 Node.js/JavaScript 构建了一个简单但功能齐全的 Web 应用程序，可以从我们提供的文档中回答问题。对于我们的应用程序，我们创建了一个充当
    OpenAI API 代理的 API 和一个提供用户界面的 HTML 页面。
- en: In the next chapter, we will discuss the OpenAI app review process and implement
    a few modifications to our application based on recommendations from OpenAI. Then,
    we'll cover the steps necessary for going live!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 OpenAI 应用程序审查流程，并根据 OpenAI 的建议实施一些修改。然后，我们将介绍上线所需的步骤！
