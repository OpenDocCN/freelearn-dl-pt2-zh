["```py\nimport torch\nimport torch.nn as nn\n```", "```py\nMy_neuralnet = nn.Sequential(operationOne,operationTwoâ€¦)\n```", "```py\nimport torch\nimport torch.nn as nn\nmy_neuralnet = nn.Sequential(nn.Linear(3,2),\n  nn.ReLU(),\n  nn.Linear(2, 1),\n  nn.Sigmoid())\n```", "```py\nclass MyNeuralNet(nn.Module):\n# define the __init__() method\ndef __init__(self, other_features_for_initialization):\n# Initialize Operations for Layers\n# define the forward() method\ndef forward(self, x):\n# Describe the flow of data through the layers\n```", "```py\nclass MyNeuralNet(nn.Module):\ndef __init__(self):\n    super(MyNeuralNet, self).__init__()\n   self.operationOne = nn.Linear(3, 2)\n    self.operationTwo = nn.Linear(2, 1)\n```", "```py\n self.desiredOperation = PyTorchOperation\n```", "```py\ndef __init__(self, input_size, n_nodes, output_size):\nsuper(MyNerualNet, self).__init__()\nself.operationOne = nn.Linear(input_size, n_nodes)\nself.operationTwo = nn.Linear(n_nodes, output_size)\n```", "```py\ndef forward(self, x):\nx = self.operationOne(x)\nx = nn.functional.relu(x)\nx = self.operationTwo(x)\noutput = nn.functional.sigmoid(x)\nreturn output\n```", "```py\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nclass MyNeuralNet(nn.Module):\ndef __init__(self, input_size, n_nodes, output_size):\n    super(MyNeuralNet, self).__init__()\n    self.operationOne = nn.Linear(input_size, n_nodes)\n    self.operationTwo = nn.Linear(n_nodes, output_size)\ndef forward(self, x):\n    x = F.relu(self.operationOne(x)\n   x = self.operationTwo(x)\n    x = F.sigmoid(x)\nreturn x\n```", "```py\nmy_network = MyNeuralNet(input_size = 3, n_nodes = 2, output_size = 1)\n```", "```py\nimport torch\nfirst_order_tensor = torch.tensor([1, 2, 3])\nprint(first_order_tensor)\n#tensor([1, 2, 3])\n```", "```py\nprint(first_order_tensor[0])\n#tensor(1)\n```", "```py\nprint(first_order_tensor[0:2])\n#tensor([1, 2])\n```", "```py\nprint(first_order_tensor[1:])\n#tensor([2, 3])\n```", "```py\nsecond_order_tensor = torch.tensor([ [ 11, 22, 33 ],\n                                     [ 21, 22, 23 ]\n                                   ])\n\nprint(second_order_tensor)\n\n#tensor([[11, 12, 13],\n         [21, 22, 23]])\n```", "```py\nprint(second_order_tensor[0, 1])\n#tensor(12)\n```", "```py\nfourth_order_tensor = torch.tensor(\n[\n    [\n        [\n            [1111, 1112],\n            [1121, 1122]\n        ],\n        [\n            [1211, 1212],\n            [1221, 1222]\n        ]\n    ],\n    [\n        [\n            [2111, 2112],\n            [2121, 2122]\n        ],\n        [\n            [2211, 2212],\n            [2221, 2222]\n        ]  \n    ]\n])\n```", "```py\nmy_tensor = torch.tensor([1, 2, 3, 4, 5])\nprint(my_tensor.size())\n# torch.Size([5])\n```", "```py\nmy_tensor = torch.tensor([[11, 12, 13], [21, 22, 23]])\nprint(my_tensor.size())\n# torch.Size([2, 3])\n```", "```py\nprint(fourth_order_tensor.size())\n# torch.Size([2, 2, 2, 2])\n```", "```py\nrandom_tensor = torch.rand([4, 2])\nprint(random_tensor)\n#tensor([[0.9449, 0.6247],\n        [0.1689, 0.4221],\n        [0.9565, 0.0504],\n        [0.5897, 0.9584]])\n```", "```py\nrandom_tensor.view([2, 4])\n#tensor([[0.9449, 0.6247, 0.1689, 0.4221],\n         [0.9565, 0.0504, 0.5897, 0.9584]])\n```", "```py\nrandom_tensor = torch.rand([4, 2, 4])\nrandom_tensor.view([2, 4, -1])\n#tensor([[[0.1751, 0.2434, 0.9390, 0.4585],\n          [0.5018, 0.5252, 0.8161, 0.9712],\n          [0.7042, 0.4778, 0.2127, 0.3466],\n          [0.6339, 0.4634, 0.8473, 0.8062]],\n        [[0.3456, 0.0725, 0.0054, 0.4665],\n         [0.9140, 0.2361, 0.4009, 0.4276],\n         [0.3073, 0.9668, 0.0215, 0.5560],\n         [0.4939, 0.6692, 0.9476, 0.7543]]])\n\nrandom_tensor.view([2, -1, 4])\n#tensor([[[0.1751, 0.2434, 0.9390, 0.4585],\n          [0.5018, 0.5252, 0.8161, 0.9712],\n          [0.7042, 0.4778, 0.2127, 0.3466],\n          [0.6339, 0.4634, 0.8473, 0.8062]],\n        [[0.3456, 0.0725, 0.0054, 0.4665],\n         [0.9140, 0.2361, 0.4009, 0.4276],\n         [0.3073, 0.9668, 0.0215, 0.5560],\n         [0.4939, 0.6692, 0.9476, 0.7543]]])\n```", "```py\nx = torch.tensor([5, 3])\ny = torch.tensor([3, 2])\ntorch.add(x, y)\n# tensor([8, 5])\ntorch.sub(x, y)\n# tensor([2, 1])\ntorch.mul(x, y)\n# tensor([15,  6])\n```", "```py\nx + y\n# tensor([8, 5])\n```", "```py\ntorch.matmul(x, y)\n# tensor(21)\nx @ y\n# tensor(21)\n```", "```py\ntorch.div(x, y)\n# tensor([1, 1])\n```", "```py\nx.dtype\n# torch.int64\ny.dtype\n# torch.int64\n```", "```py\nx_float = torch.tensor([5, 3], dtype = torch.float32)\ny_float = torch.tensor([3, 2], dtype = torch.float32)\nprint(x_float / y_float)\n# tensor([1.6667, 1.5000])\n```", "```py\ntorch.FloatTensor([5, 3])\n# tensor([5., 3.])\nx.type(torch.DoubleTensor)\n# tensor([5., 3.], dtype=torch.float64)\n```", "```py\nimport numpy as np\nadmit_data = np.genfromtxt('../datasets/admit_status.csv',\ndelimiter = ',', skip_header = 1)\n            print(admit_data)\n```", "```py\nadmit_tensor = torch.from_numpy(admit_data)\nprint(admit_tensor)\n```", "```py\nx_train = admit_tensor[:300, 1:]\ny_train = admit_tensor[:300, 0]\nx_test = admit_tensor[300:, 1:]\ny_test = admit_tensor[300:, 0]\n```", "```py\ncriterion = nn.BCELoss()\n```", "```py\noptimizer = torch.optim.SGD(my_network.parameters(), lr=0.01)\n```", "```py\nfor epoch in range(100):\n # Forward Propagation\n y_pred = my_network(x_train)\n\n # Compute and print loss\n loss_score = criterion(y_pred, y_train)\n print('epoch: ', epoch,' loss: ', loss.item())\n\n # Zero the gradients\n optimizer.zero_grad()\n\n # perform a backward pass (backpropagation)\n loss_score.backward()\n\n # Update the parameters\n optimizer.step()\n```"]