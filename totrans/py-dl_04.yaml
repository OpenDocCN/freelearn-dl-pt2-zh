- en: Chapter 4. Unsupervised Feature Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the reasons why deep neural networks can succeed where other traditional
    machine learning techniques struggle is the capability of learning the right representations
    of entities in the data (features) without needing (much) human and domain knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, neural networks are able to consume raw data directly as it is
    and map the input layers to the desired output via the hidden intermediate representations.
    Traditional machine learning techniques focus mainly on the final mapping and
    assume the task of "feature engineering" to have already been done.
  prefs: []
  type: TYPE_NORMAL
- en: Feature engineering is the process that uses the available domain knowledge
    to create smart representations of the data, so that it can be processed by the
    machine learning algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Andrew Yan-Tak Ng is a professor at Stanford University and one of the most
    renowned researchers in the field of machine learning and artificial intelligence.
    In his publications and talks, he describes the limitations of traditional machine
    learning when applied to solving real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hardest part of making a machine learning system work is to find the right
    feature representations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Coming up with features is difficult, time-consuming, requires expert knowledge.
    When working applications of learning, we spend a lot of time tuning features.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Anrew Ng, Machine Learning and AI via Brain simulations, Stanford University*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s assume we are classifying pictures into a few categories, such as animals
    versus vehicles. The raw data is a matrix of the pixels in the image. If we used
    those pixels directly in a logistic regression or a decision tree, we would create
    rules (or associating weights) for every single picture that might work for the
    given training samples, but that would be very hard to generalize enough to small
    variations of the same pictures. In other words, let''s suppose that my decision
    tree finds that there are five important pixels whose brightness (supposing we
    are displaying only black and white tones) can determine where most of the training
    data get grouped into the two classes--animals and vehicles. The same pictures,
    if cropped, shifted, rotated, or re-colored, would not follow the same rules as
    before. Thus, the model would probably randomly classify them. The main reason
    is that the features we are considering are too weak and unstable. However, we
    could instead first preprocess the data such that we could extract features like
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the picture contain symmetric centric, shapes like wheels?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it contain handlebars or a steering wheel?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it contain legs or heads?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it have a face with two eyes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In such cases, the decision rules would be quite easy and robust, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unsupervised Feature Learning](img/00118.jpeg)![Unsupervised Feature Learning](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How much effort is needed in order to extract those relevant features?
  prefs: []
  type: TYPE_NORMAL
- en: Since we don't have handlebar detectors, we could try to hand-design features
    to capture some statistical properties of the picture, for example, finding edges
    in different orientations in different picture quadrants. We need to find a better
    way to represent images than pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, robust and significant features are generally made out of hierarchies
    of previously extracted features. We could start extracting edges in the first
    step, then take the generated "edges vector", and combine them to recognize object
    parts, such as an eye, a nose, a mouth, rather than a light, a mirror, or a spoiler.
    The resulting object parts can again be combined into object models; for example,
    two eyes, one nose, and one mouth form a face, or two wheels, a seat, and a handlebar
    form a motorcycle. The whole detection algorithm could be simplified in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unsupervised Feature Learning](img/00120.jpeg)![Unsupervised Feature Learning](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By recursively applying sparse features, we manage to get higher-level features.
    This is why you need deeper neural network architectures as opposed to the shallow
    algorithms. The single network can learn how to move from one representation to
    the following, but stacking them together will enable the whole end-to-end workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The real power is not just in the hierarchical structures though. It is important
    to note that we have only used unlabeled data so far. We are learning the hidden
    structures by reverse-engineering the data itself instead of relying on manually
    labeled samples. The supervised learning represents only the final classification
    steps, where we need to assign to either the vehicle class or the animal class.
    All of the previous steps are performed in an unsupervised fashion.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how the specific feature extraction for pictures is done in the
    following [Chapter 5](part0030_split_000.html#SJGS1-c1ed1b54ca0b4e9fbb9fe2b2431d634f
    "Chapter 5. Image Recognition"), *Image Recognition*. In this chapter, we will
    focus on the general approach of learning feature representations for any type
    of data (for example, time signals, text, or general attribute vectors).
  prefs: []
  type: TYPE_NORMAL
- en: 'For that purpose, we will cover two of the most powerful and quite used architectures
    for unsupervised feature learning: autoencoders and restricted Boltzmann machines.'
  prefs: []
  type: TYPE_NORMAL
- en: Autoencoders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Autoencoders are symmetric networks used for unsupervised learning, where output
    units are connected back to input units:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoencoders](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Autoencoder simple representation from H2O training book (https://github.com/h2oai/h2o-training-book/blob/master/hands-on_training/images/autoencoder.png)
  prefs: []
  type: TYPE_NORMAL
- en: The output layer has the same size of the input layer because its purpose is
    to reconstruct its own inputs rather than predicting a dependent target value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of those networks is to act as a compression filter via an encoding
    layer, Φ that fits the input vector *X* into a smaller latent representation (the
    code) *c*, and then a decoding layer, Φ tries to reconstruct it back to *X''*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoencoders](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The loss function is the reconstruction error, which will force the network
    to find the most efficient compact representation of the training data with minimum
    information loss. For numerical input, the loss function can be the mean squared
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoencoders](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the input data is not numerical but is represented as a vector of bits or
    multinomial distributions, we can use the cross-entropy of the reconstruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoencoders](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *d* is the dimensionality of the input vectors.
  prefs: []
  type: TYPE_NORMAL
- en: The central layer (the code) of the network is the compressed representation
    of the data. We are effectively translating an n-dimensional array into a smaller
    m-dimensional array, where *m < n*. This process is very similar to dimensionality
    reduction using **Principal Component Analysis** (**PCA**). PCA divides the input
    matrix into orthogonal axes (called components) in such, way that you can reconstruct
    an approximation of the original matrix by projecting the original points on those
    axes. By sorting them by their importance, we can extract the top *m* components
    that can be though as high-level features of the original data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a multivariate Gaussian distribution, we could represent each
    point as a coordinate over the two orthogonal components that would describe the
    largest possible variance in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoencoders](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A scatter plot of samples that are distributed according a multivariate (bivariate)
    Gaussian distribution centered at (1,3) with a standard deviation of 3 in the
    (0.866, 0.5) direction and of 1 in the orthogonal direction. The directions represent
    the principal components (PC) associated with the sample. By Nicoguaro (own work)
    CC BY 4.0 (http://creativecommons.org/licenses/by/4.0), via Wikimedia Commons.
  prefs: []
  type: TYPE_NORMAL
- en: The limitation of PCA is that it allows only linear transformation of the data,
    which is not always enough.
  prefs: []
  type: TYPE_NORMAL
- en: Autoencoders have the advantage of being able to represent even non-linear representations
    using a non-linear activation function.
  prefs: []
  type: TYPE_NORMAL
- en: 'One famous example of an autoencoder was given by MITCHELL, T. M. in his book
    *Machine Learning*, wcb, 1997\. In that example, we have a dataset with eight
    categorical objects encoded in binary with eight mutually exclusive labels with
    bits. The network will learn a compact representation with just three hidden nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoencoders](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tom Mitchell's example of an autoencoder.
  prefs: []
  type: TYPE_NORMAL
- en: By applying the right activation function, the learn-compact representation
    corresponds exactly with the binary representation with three bits.
  prefs: []
  type: TYPE_NORMAL
- en: There are situations though where just the single hidden layer is not enough
    to represent the whole complexity and variance of the data. Deeper architecture
    can learn more complicated relationships between the input and hidden layers.
    The network is then able to learn latent features and use those to best represent
    the non-trivial informative components in the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A deep autoencoder is obtained by concatenating two symmetrical networks typically
    made of up to five shallow layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoencoders](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Schematic structure of an autoencoder with 3 fully-connected hidden layers (https://en.wikipedia.org/wiki/Autoencoder#/media/File:Autoencoder_structure.png)
  prefs: []
  type: TYPE_NORMAL
- en: Deep autoencoders can learn new latent representations, combining the previously
    learned ones so that each hidden level can be seen as some compressed hierarchical
    representation of the original data. We could then use the code or any other hidden
    layer of the encoding network as valid features describing the input vector.
  prefs: []
  type: TYPE_NORMAL
- en: Network design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Probably the most common question when building a deep neural network is: how
    do we choose the number of hidden layers and the number of neurons for each layer?
    Furthermore, which activation and loss functions do we use?'
  prefs: []
  type: TYPE_NORMAL
- en: There is no closed answer. The empirical approach consists of running a sequence
    of trial and error or a standard grid search, where the depth and the size of
    each layer are simply defined as tuning hyperparameters. We will look at a few
    design guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'For autoencoders, the problem is slightly simplified. Since there are many
    variants of autoencoders, we will define the guidelines for the general use case.
    Please keep in mind that each variation will have its own rules to be considered.
    We can suggest the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The output layer consists of exactly the same size of the input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network is symmetric most of the time. Having an asymmetric network would
    mean having different complexities of the encoder and decoder functions. Unless
    you have a particular reason for doing so, there is generally no advantage in
    having asymmetric networks. However, you could decide to share the same weights
    or decide to have different weights in the encoding and decoding networks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During the encoding phase, the hidden layers are smaller than the input, in
    which case, we are talking about "undercomplete autoencoders". A multilayer encoder
    gradually decreases the representation size. The size of the hidden layer, generally,
    is at most half the size of the previous one. If the data input layer has 100
    nodes, then a plausible architecture could be 100-40-20-40-100\. Having bigger
    layers than the input would lead to no compression at all, which means no interesting
    patterns are learned. We will see in the *Regularization* section how this constraint
    is not necessary in case of sparse autoencoders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle layer (the code) covers an important role. In the case of feature
    reduction, we could keep it small and equal to 2, 3, or 4 in order to allow efficient
    data visualizations. In the case of stacked autoencoders, we should set it to
    be larger because it will represent the input layer of the next encoder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of binary inputs, we want to use sigmoid as the output activation
    function and cross-entropy, or more precisely, the sum of Bernoulli cross-entropies,
    as the loss function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For real values, we can use a linear activation function (ReLU or softmax) as
    the output and the **mean squared error** (**MSE**) as the loss function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For different types of input data(*x*)and output *u*, you can follow the general
    approach, which consists of the following steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the probability distribution of observing x, given *u*, P(x/u)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding the relationship between *u* and the hidden layer h(x)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using ![Network design](img/00123.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of deep networks (with more than one hidden layer), use the same
    activation function for all of them in order to not unbalance the complexity of
    the encoder and decoder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use a linear activation function throughout the whole network, we will
    approximate the behavior of PCA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is convenient to Gaussian scale (0 mean and unit standard deviation) your
    data unless it is binary, and it is better to leave the input values to be either
    0 or 1\. Categorical data can be represented using one-hot-encoding with dummy
    variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Activation functions are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReLU is generally the default choice for majority of neural networks. Autoencoders,
    given their topology, may benefit from a symmetric activation function. Since
    ReLU tends to overfit more, it is preferred when combined with regularization
    techniques (such as dropout).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If your data is binary or can be scaled in the range of [0, 1], then you would
    probably use a sigmoid activation function. If you used one-hot-encoding for the
    input categorical data, then it's better use ReLU.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyperbolic tangent (*tanh*) is a good choice for computation optimization in
    case of gradient descent. Since data will be centered around 0, the derivatives
    will be higher. Another effect is reducing bias in the gradients as is well explained
    in the "Efficient BackProp" paper ([http://yann.lecun.com/exdb/publis/pdf/lecun-98b.pdf](http://yann.lecun.com/exdb/publis/pdf/lecun-98b.pdf)).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Network design](img/00129.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Different activation functions commonly used for deep neural networks
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Regularization techniques for autoencoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, we already saw different forms of regularizations,
    such as L1, L2, early stopping, and dropout. In this section, we will describe
    a few popular techniques specifically tailored for autoencoders.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have always described autoencoders as "undercomplete", which means
    the hidden layers are smaller than the input layer. This is because having a bigger
    layer would have no compression at all. The hidden units may just copy exactly
    the input and return an exact copy as the output.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, having more hidden units would allow us to have more freedom
    on learning smarter representations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how we can address this problem with three approaches: denoising
    autoencoders, contractive autoencoders, and sparse autoencoders.'
  prefs: []
  type: TYPE_NORMAL
- en: Denoising autoencoders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea is that we want to train our model to learn how to reconstruct a noisy
    version of the input data.
  prefs: []
  type: TYPE_NORMAL
- en: We will use x to represent the original input, ![Denoising autoencoders](img/00130.jpeg),
    the noisy input, and ![Denoising autoencoders](img/00131.jpeg), the reconstructed
    output.
  prefs: []
  type: TYPE_NORMAL
- en: The noisy input, ![Denoising autoencoders](img/00130.jpeg), is generated by
    randomly assigning a subset of the input ![Denoising autoencoders](img/00130.jpeg)
    to 0, with a given probability 𝑝, plus an additive isotropic Gaussian noise, with
    variance *v* for numerical inputs.
  prefs: []
  type: TYPE_NORMAL
- en: We would then have two new hyper-parameters to tune ?? and ![Denoising autoencoders](img/00132.jpeg),
    which represent the noise level.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the noisy variant, ![Denoising autoencoders](img/00130.jpeg), as
    the input of the network, but the loss function will still be the error between
    the output ![Denoising autoencoders](img/00131.jpeg) and the original noiseless
    input ![Denoising autoencoders](img/00130.jpeg). If the input dimensionality is
    *d*, the encoding function *f*, and the decoding function *g*, we will write the
    loss function *j* as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Denoising autoencoders](img/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *L* is the reconstruction error, typically either the MSE or the cross-entropy.
  prefs: []
  type: TYPE_NORMAL
- en: With this variant, if a hidden unit tries to exactly copy the input values,
    then the output layer cannot trust 100% because it knows that it could be the
    noise and not the original input. We are forcing the model to reconstruct based
    on the interrelationships between other input units, aka the meaningful structures
    of the data.
  prefs: []
  type: TYPE_NORMAL
- en: What we would expect is that the higher the added noise, the bigger the filters
    applied at each hidden unit. By filter, we mean the portion of the original input
    that is activated for that particular feature to be extracted. In case of no noise,
    hidden units tend to extract a tiny subset of the input data and propose it at
    the most untouched version to the next layer. By adding noise to the units, the
    error penalty on badly reconstructing ![Denoising autoencoders](img/00134.jpeg)
    will force the network to keep more information in order to contextualize the
    features regardless of the possible presence of noise.
  prefs: []
  type: TYPE_NORMAL
- en: Please pay attention that just adding a small white noise could be equivalent
    to using weight decay regularization. Weight decay is a technique that consists
    of multiplying to a factor less than 1 the weights at each training epoch in order
    to limit the free parameters in our model. Although this is a popular technique
    to regularize neural networks, by setting inputs to 0 with probability *p*, we
    are effectively achieving a totally different result.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to obtain high-frequency filters that when put together give us
    a more generalized model. Our denoising approach generates filters that do represent
    unique features of the underlying data structures and have individual meanings.
  prefs: []
  type: TYPE_NORMAL
- en: Contractive autoencoders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Contractive autoencoders aim to achieve a similar goal to that of the denoising
    approach by explicitly adding a term that penalizes when the model tries to learn
    uninteresting variations and promote only those variations that are observed in
    the training set.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the model may try to approximate the identity function by coming
    out with filters representing variations that are not necessarily present in the
    training data.
  prefs: []
  type: TYPE_NORMAL
- en: We can express this sensitivity as the sum of squares of all partial derivatives
    of the extracted features with respect to the input dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an input *x* of dimensionality ![Contractive autoencoders](img/00135.jpeg)
    mapped by the encoding function *f* to the hidden representation *h* of size *d*[*h*],
    the following quantity corresponds to the L2 norm (Frobenius) of the Jacobian
    matrix ![Contractive autoencoders](img/00136.jpeg) of the encoder activations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Contractive autoencoders](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The loss function will be modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Contractive autoencoders](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, λ is the regularization factor. It is easy to see that the Frobenius norm
    of the Jacobian corresponds to L2 weight decay in the case of a linear encoder.
    The main difference is that for the linear case, the only way of achieving contraction
    would be by keeping weights very small. In case of a sigmoid non-linearity, we
    could also push the hidden units to their saturated regime.
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze the two terms.
  prefs: []
  type: TYPE_NORMAL
- en: The error *J* (the MSE or cross-entropy) pushes toward keeping the most possible
    information to perfectly reconstruct the original value.
  prefs: []
  type: TYPE_NORMAL
- en: The penalty pushes toward getting rid of all of that information such that the
    derivatives of the hidden units with respect to *X* are minimized. A large value
    means that the learned representation is too unstable with respect to input variations.
    We obtain a small value when we observe very little change to the hidden representations
    as we change the input values. In case of the limit of these derivatives being
    0, we would only keep the information that is invariant with respect to the input
    *X*. We are effectively getting rid of all of the hidden features that are not
    stable enough and too sensitive to small perturbations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose we have as input a lot of variations of the same data. In the
    case of images, they could be small rotations or different exposures of the same
    subject. In case of network traffic, they could be an increase/decrease of the
    packet header of the same type of traffic, maybe because of a packing/unpacking
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: If we only look at this dimension, the model is likely to be very sensitive.
    The Jacobian term would penalize the high sensitivity, but it is compensated by
    the low reconstruction error.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we would have one unit that is very sensitive on the variation
    direction but not very useful for all other directions. For example, in the case
    of pictures, we still have the same subject; thus, all of the remaining input
    values are constant. If we don't observe variations on a given direction in the
    training data, we want to discard the feature.
  prefs: []
  type: TYPE_NORMAL
- en: H2O currently does not support contractive autoencoders; however, an open issue
    can be found at [https://0xdata.atlassian.net/browse/PUBDEV-1265](https://0xdata.atlassian.net/browse/PUBDEV-1265).
  prefs: []
  type: TYPE_NORMAL
- en: Sparse autoencoders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Autoencoders, as we have seen them so far, always have the hidden layers smaller
    than the input.
  prefs: []
  type: TYPE_NORMAL
- en: The major reason is that otherwise, the network would have enough capability
    to just memorize exactly the input and reconstruct it perfectly as it is. Adding
    extra capacity to the network would just be redundant.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the capacity of the network forces to learn based on a compression
    version of the input. The algorithm will have to pick the most relevant features
    that help better reconstruct the training data.
  prefs: []
  type: TYPE_NORMAL
- en: There are situations though where compressing is not feasible. Let's consider
    the case where each input node is formed by independent random variables. If the
    variables are not correlated with each other, the only way of achieving compression
    is to get rid of some of them entirely. We are effectively emulating the behavior
    of PCA.
  prefs: []
  type: TYPE_NORMAL
- en: In order to solve this problem, we can set a **sparsity** constraint on the
    hidden units. We will try to push each neuron to be inactive most of the time
    that corresponds to having the output of the activation function close to 0 for
    sigmoid and ReLU, -1 for tanh.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call ![Sparse autoencoders](img/00139.jpeg) the activation of hidden
    unit ![Sparse autoencoders](img/00140.jpeg) at layer ![Sparse autoencoders](img/00141.jpeg)
    when input is ![Sparse autoencoders](img/00142.jpeg), we can define the average
    activation of hidden unit ![Sparse autoencoders](img/00140.jpeg) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sparse autoencoders](img/00143.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, ![Sparse autoencoders](img/00144.jpeg) is the size of our training dataset
    (or batch of training data).
  prefs: []
  type: TYPE_NORMAL
- en: The sparsity constraint consists of forcing ![Sparse autoencoders](img/00145.jpeg),
    where ![Sparse autoencoders](img/00146.jpeg) is the **sparsity parameter** bounded
    in the interval [1,0] and ideally close enough to 0.
  prefs: []
  type: TYPE_NORMAL
- en: The original paper ([http://web.stanford.edu/class/cs294a/sparseAutoencoder.pdf](http://web.stanford.edu/class/cs294a/sparseAutoencoder.pdf))
    recommends values near 0.05.
  prefs: []
  type: TYPE_NORMAL
- en: We model the average activation of each hidden unit as a Bernoulli random variable
    with mean ![Sparse autoencoders](img/00147.jpeg), and we want to force all of
    them to converge to a Bernoulli distribution with mean ![Sparse autoencoders](img/00146.jpeg)
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so, we need to add an extra penalty that quantifies the divergence
    of those two distributions. We can define this penalty based on the **Kullback-Leibler**
    (**KL**) divergence between the real distribution ![Sparse autoencoders](img/00148.jpeg)
    and the theoretical one ![Sparse autoencoders](img/00149.jpeg) we would like to
    achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, for discrete probability distributions *P* and *Q*, the *KL* divergence
    when information is measured in bits is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sparse autoencoders](img/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One requirement is that *P* is absolutely continuous with respect to *Q*, that
    is, ![Sparse autoencoders](img/00151.jpeg) for any measurable value of *x*. This
    is also written as ![Sparse autoencoders](img/00152.jpeg). Whenever ![Sparse autoencoders](img/00153.jpeg),
    the contribution of that term will be ![Sparse autoencoders](img/00154.jpeg) since
    that ![Sparse autoencoders](img/00155.jpeg).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the ![Sparse autoencoders](img/00156.jpeg) divergence of unit
    *j* would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sparse autoencoders](img/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This function has the property to be ![Sparse autoencoders](img/00154.jpeg)
    when the two means are equal and increase monotonically, otherwise until approaching
    8 when ![Sparse autoencoders](img/00158.jpeg) is close to
  prefs: []
  type: TYPE_NORMAL
- en: '![Sparse autoencoders](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: or 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final loss function with extra penalty term added will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sparse autoencoders](img/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *J* is the standard loss function (the RMSE), ![Sparse autoencoders](img/00160.jpeg)
    is the number of hidden units, and ß is a weight of the sparsity term.
  prefs: []
  type: TYPE_NORMAL
- en: This extra penalty will cause a small inefficiency to the backpropagation algorithm.
    In particular, the preceding formula will require an additional forward step over
    the whole training set to precompute the average activations ![Sparse autoencoders](img/00158.jpeg)
    before computing the backpropagation on each example.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of autoencoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Autoencoders are powerful unsupervised learning algorithms, which are getting
    popularity in fields such as anomaly detection or feature engineering, using the
    output of intermediate layers as features to train a supervised model instead
    of the raw input data.
  prefs: []
  type: TYPE_NORMAL
- en: Unsupervised means they do not require labels or ground truth to be specified
    during training. They just work with whatever data you put as input as long as
    the network has enough capability to learn and represent the intrinsic existing
    relationships. That means that we can set both the size of the code layer (the
    reduced dimensionality *m*) but obtain different results depending on the number
    and size of the hidden layers, if any.
  prefs: []
  type: TYPE_NORMAL
- en: If we are building an autoencoder network, we want to achieve robustness in
    order to avoid wrong representations but at the same time not limit the capacity
    of the network by compressing the information through smaller sequential layers.
  prefs: []
  type: TYPE_NORMAL
- en: Denoising, contractive, and autoencoders are all great techniques for solving
    those problems.
  prefs: []
  type: TYPE_NORMAL
- en: Adding noise is generally simpler and doesn't add complexity in the loss function,
    which results in less computation. On the other hand, the noisy input makes the
    gradient to be sampled and also discard part of the information in exchange for
    better features.
  prefs: []
  type: TYPE_NORMAL
- en: Contractive autoencoders are very good at making the model more stable to small
    deviations from the training distribution. Thus, it is a very good candidate for
    reducing false alarms. The drawback is a sort of countereffect that increases
    the reconstruction error in order to reduce the sensibility.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse autoencoders are probably the most complete around solution. It is the
    most expensive to compute for large datasets, but since the gradient is deterministic,
    it can be useful in case of second-order optimizers and, in general, to provide
    a good trade-off between stability and low reconstruction error.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of what choice you make, adopting a regularization technique is strongly
    recommended. They both come with hyper-parameters to tune, which we will see how
    to optimize in the corresponding *Tuning* section.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the techniques described so far, it is worth mentioning variational
    autoencoders, which seem to be the ultimate solution for regularizing autoencoders.
    Variational autoencoders belong to the class of generative models. They don't
    just learn the structures that better describe the training data, they learn the
    parameters of a latent unit Gaussian distribution that can best regenerate the
    input data. The final loss function will be the sum of the reconstruction error
    and the KL divergence between the reconstructed latent variable and the Gaussian
    distribution. The encoder phase will generate a code consisting of a vector of
    means and a vector of standard deviations. From the code, we can characterize
    the latent distribution parameters and reconstruct the original input by sampling
    from that distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Restricted Boltzmann machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early 90s, neural networks had largely gone out of fashion. The bulk
    of machine learning research was around other techniques, such as random forests
    and support vector machines. Neural networks with only a single hidden layer were
    less performant than these other techniques, and it was thought that deeper neural
    networks were too difficult to train.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resurgence of interest in neural networks was spearheaded by Geoffrey Hinton,
    who, in 2004, led a team of researchers who proceeded to make a series of breakthroughs
    using restricted Boltzmann machines (RBM) and creating neural networks with many
    layers; they called this approach deep learning. Within 10 years, deep learning
    would go from being a niche technique to dominating every single AI competition.
    RBMs were part of the big breakthrough, allowing Hinton and others to get world
    record scores on a variety of image and speech recognition problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will look at the theory of how RBMs work, how to implement
    them, and how they can be combined into deep belief networks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A restricted Boltzmann machine looks a lot like a single layer of a neural
    network. There are a set of input nodes that have connections to another set of
    output nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Restricted Boltzmann machines](img/00161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1\. Restricted Boltzmann machine
  prefs: []
  type: TYPE_NORMAL
- en: The way these output nodes are activated is also identical to an autoencoder.
    There is a weight between each input node and output node, the activation of each
    input nodes multiplied by this matrix of weight mappings, and a bias vector is
    then applied, and the sum for each output node is then put through a sigmoid function.
  prefs: []
  type: TYPE_NORMAL
- en: What makes a restricted Boltzmann machine different is what the activations
    represent, how we think about them, and the way in which they are trained. To
    begin with, when talking about RBMs rather than talking about input and output
    layers, we refer to the layers as visible and hidden. This is because, when training,
    the visible nodes represent the known information we have. The hidden nodes will
    aim to represent some variables that generated the visible data. This contrasts
    with an autoencoder, where the output layer doesn't explicitly represent anything,
    is just a constrained space through which the information is passed.
  prefs: []
  type: TYPE_NORMAL
- en: The basis of learning the weights of a restricted Boltzmann machine comes from
    statistical physics and uses an **energy-based model** (**EBM**). In these, every
    state is put through an energy function, which relates to the probability of a
    state occurring. If an energy function returns a high value, we expect this state
    to be unlikely, rarely occurring. Conversely, a low result from an energy function
    means a state that is more stable and will occur more frequently.
  prefs: []
  type: TYPE_NORMAL
- en: A good intuitive way of thinking about an energy function is to imagine a huge
    number of bouncy balls being thrown into a box. At first, all the balls have high
    energy and so will be bouncing very high. A state here would be a single snapshot
    in time of all the balls' positions and their associated velocities. These states,
    when the balls are bouncing, are going to be very transitory; they will only exist
    for moments and because of the range of movement of the balls, are very unlikely
    to reoccur. But as the balls start to settle, as the energy leaves the system,
    some of the balls will start to be increasingly stationary. These states are stable
    once it occurs once it never stops occurring. Eventually, once the balls have
    stopped bouncing and all become stationary, we have a completely stable state,
    which has high probability.
  prefs: []
  type: TYPE_NORMAL
- en: To give an example that applies to restricted Boltzmann machines, consider the
    task of learning a group of images of butterflies. We train our RBM on these images,
    and we want it to assign a low energy value to any image of a butterflies. But
    when given an image from a different set, say cars, it will give it a high energy
    value. Related objects, such as moths, bats, or birds, may have a more medium
    energy value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have an energy function defined, the probability of a given state is then
    given as follows:![Restricted Boltzmann machines](img/00162.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, v is our state, E is our energy function, and Z is the partition function;
    the sum of all possible configurations of v is defined as follows:![Restricted
    Boltzmann machines](img/00163.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopfield networks and Boltzmann machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we go further into restricted Boltzmann machines, let's briefly talk
    about Hopfield networks; this should help in giving us a bit more of an understanding
    about how we get to restricted Boltzmann machines. Hopfield networks are also
    energy-based models, but unlike a restricted Boltzmann machine, it has only visible
    nodes, and they are all interconnected. The activation of each node will always
    be either -1 or +1.![Hopfield networks and Boltzmann machines](img/00164.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 2\. Hopfield network, all input nodes are interconnected
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When running a Hopfield network (or RBM), you have two options. The first option
    is that you can set the value of every visible node to the corresponding value
    of your data item you are triggering it on. Then you can trigger successive activations,
    where, at each activation, every node has its value updated based on the value
    of the other visible nodes it is connected to. The other option is to just initialize
    the visible nodes randomly and then trigger successive activations so it produces
    random examples of the data it has been trained on. This is often referred to
    as the network daydreaming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The activation of each of these visible nodes at the next time step is defined
    as follows:![Hopfield networks and Boltzmann machines](img/00165.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, W is a matrix defining the connection strength between each node v at
    time step t. A thresholding rule is then applied to a to get a new state for v:![Hopfield
    networks and Boltzmann machines](img/00166.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The weights W between nodes can be either positive or negative, which will lead
    nodes to attract or repel the other nodes in the network, when active. The Hopfield
    network also has a continuous variant, which simply involves replacing the thresholding
    function with the tanh function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The energy function for this network is as follows:![Hopfield networks and Boltzmann
    machines](img/00167.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In matrix notation, it is as follows:![Hopfield networks and Boltzmann machines](img/00168.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ![Hopfield networks and Boltzmann machines](img/00169.jpeg) in the equation
    is because we are going through every pair of i and j and so double-counting each
    connection (once when i=1 and j=2 then again when i=2 and j=1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The question that might arise here is: why have a model with only visible nodes?
    I will activate it with data I give it, then trigger some state updates. But what
    useful information does this new state give me? This is where the properties of
    energy-based models become interesting. Different configurations of W will vary
    the energy function associated with the states v. If we set the state of the network
    to something with a high energy function, that is an unstable state (think of
    the many bouncing balls); the network will over successive iterations move to
    a stable state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we train a Hopefield network on a dataset to learn a W with low energy for
    each item in the dataset, we can then make a corrupted sample from the data, say,
    by randomly swapping a few of the inputs between their minus one and plus one
    states. The corrupted samples may be in a high-energy state now because the corruption
    has made it unlikely to be a member of the original dataset. If we activate the
    visible nodes of the network on the corrupted sample, run a few more iterations
    of the network until it has reached a low-energy state; there is a good chance
    that it will have reconstructed the original uncorrupted pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This leads to one use of the Hopfield networks being spelling correction; you
    can train it on a library of words, with the letters used in the words as inputs.
    Then if it is given a misspelled word, it may be able to find the correct original
    word. Another use of the Hopfield networks is as a content-addressable memory.
    One of the big differences between the computer memory and the human memory is
    that with computers, memories are stored with addresses. If a computer wants to
    retrieve a memory, it must know the exact place it stored it in. Human memory,
    on the other hand, can be given a partial section of that memory, the content
    of which can be used to recover the rest of it. For example, if I need to remember
    my pin number, I know the content I'm looking for and the properties of that content,
    a four digit number; my brain uses that to return the values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopfield networks allow you to store content-addressable memories, which have
    led some people to suggest (speculatively) that the human memory system may function
    like a Hopfield network, with human dreaming being the attempt to learn the weights.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last use of a Hopfield network is that it can be used to solve optimization
    tasks, such as the traveling salesman task. The energy function can be defined
    to represent the cost of the task to be optimized, and the nodes of the network
    to represent the choices being optimized. Again, all that needs to be done is
    to minimize the energy function with respect to the weights of the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boltzmann machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Boltzmann machine is also known as a stochastic Hopfield network. In a Hopfield
    network, node activations are set based on the threshold; but in a Boltzmann machine,
    activation is stochastic. The value of a node in a Boltzmann machine is always
    set to either +1 or -1\. The probability of the node being in the state +1 is
    defined as follows:![Boltzmann machine](img/00170.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, *a*[*i*] is the activation for that node as defined for the Hopfield network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn the weights of our Boltzmann machine or Hopfield network, we want
    to maximize the likelihood of the dataset, given the W, which is simply the product
    of the likelihood for each data item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Boltzmann machine](img/00171.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, W is the weights matrix, and *x**^((n))* is the nth sample from the dataset
    x of size N. Let''s now replace ![Boltzmann machine](img/00172.jpeg) with the
    actual likelihood from our Boltzmann machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Boltzmann machine](img/00173.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *Z* is as shown in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Boltzmann machine](img/00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you look at the original definition of our energy function and Z, then *x'*
    should be every possible configuration of *x* based on the probability distribution
    *p(x)*. We now have W as part of our model, so the distribution will change to
    ![Boltzmann machine](img/00175.jpeg). Unfortunately, ![Boltzmann machine](img/00176.jpeg)
    is, if not completely intractable, at the very least, far too computationally
    expensive to compute. We would need to take every possible configuration of x
    across all possible W.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to computing an intractable probability distribution such as this
    is what's called Monte Carlo sampling. This involves taking lots of samples from
    the distribution and using the average of these samples to approximate the true
    value. The more samples we take from the distribution, the more accurate it will
    tend to be. A hypothetical infinite number of samples would be exactly the quantity
    we want, while 1 would be a very poor approximation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the products of probabilities can get very small, we will instead use
    the log probability; also, let''s also include the definition of *Z*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Boltzmann machine](img/00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, x'' is a sample of state of the network, as taken from the probability
    distribution ![Boltzmann machine](img/00175.jpeg) learned by the network. If we
    take the gradient of this with respect to a single weight between nodes i and
    j, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Boltzmann machine](img/00178.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![Boltzmann machine](img/00179.jpeg) across all N samples is simply the
    correlation between the nodes i and j. Another way to write this across all N
    samples, for each weight *i* and *j*, would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Boltzmann machine](img/00180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This equation can be understood as being two phases of learning, known as positive
    and negative or, more poetically, waking and sleeping. In the positive phase,
    ![Boltzmann machine](img/00181.jpeg) increases the weights based on the data we
    are given. In the negative phase, ![Boltzmann machine](img/00182.jpeg), we draw
    samples from the model as per the weights we currently have, then move the weights
    away from that distribution. This can be thought of as reducing the probability
    of items generated by the model. We want our model to reflect the data as closely
    as possible, so we want to reduce the selection generated by our model. If our
    model was producing images exactly like the data, then the two terms would cancel
    each other out, and equilibrium would be reached.
  prefs: []
  type: TYPE_NORMAL
- en: Boltzmann machines and Hopfield networks can be useful for tasks such as optimization
    and recommendation systems. They are very computationally expensive. Correlation
    must be measured between every single node, and then a range of Monte Carlo samples
    must be generated from the model for every training step. Also, the kinds of patterns
    it can learn are limited. If we are training on images to learn shapes, it cannot
    learn position invariant information. A butterfly on the left-hand side of an
    image is a completely different beast to a butterfly on the right-hand side of
    an image. In [Chapter 5](part0030_split_000.html#SJGS1-c1ed1b54ca0b4e9fbb9fe2b2431d634f
    "Chapter 5. Image Recognition"), *Image Recognition*, we will take a look at convolutional
    neural networks, which offers a solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Restricted Boltzmann machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Restricted Boltzmann machines make two changes from the Boltzmann machines:
    the first is that we add in hidden nodes, each of which is connected to every
    visible node, but not to each other. The second is that we remove all connections
    between visible nodes. This has the effect of making each node in the visible
    layer conditionally independent of each other if we are given the hidden layer.
    Nodes in the hidden layer are also conditionally independent, given the visible
    layer. We will also now add bias terms to both the visible and hidden nodes. A
    Boltzmann machine can also be trained with a bias term for each node, but this
    was left out of the equations for ease of notation.'
  prefs: []
  type: TYPE_NORMAL
- en: Given that the data we have is only for the visible units, what we aim to do
    through training is find configurations of hidden units that lead to low-energy
    states when combined with the visible units. In our restricted Boltzmann machine,
    the state *x* is now the full configuration of both visible and hidden nodes.
    So, we will parameterize our energy function as E(v, h). It now looks like this:![Restricted
    Boltzmann machine](img/00183.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, a is the bias vector for the visible nodes, b is the bias vector for the
    hidden nodes, and W is the matrix of weights between the visible and hidden nodes.
    Here, ![Restricted Boltzmann machine](img/00184.jpeg) is the dot product of the
    two vectors, equivalent to ![Restricted Boltzmann machine](img/00185.jpeg). Now
    we need to take the gradients of our biases and weights with respect to this new
    energy function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because of the conditional independence between layers, we now have this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Restricted Boltzmann machine](img/00186.jpeg)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
- en: '![Restricted Boltzmann machine](img/00187.jpeg)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
- en: These two definitions will be used in the normalization constant, Z. Since we
    longer have connections between visible nodes, our ![Restricted Boltzmann machine](img/00188.jpeg)
    has changed a lot:![Restricted Boltzmann machine](img/00189.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, i is going through each visible node and j through each hidden node. If
    we take the gradient with respect to the different parameters, then what you eventually
    end up with is this:![Restricted Boltzmann machine](img/00190.jpeg)![Restricted
    Boltzmann machine](img/00191.jpeg)![Restricted Boltzmann machine](img/00192.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As before, ![Restricted Boltzmann machine](img/00193.jpeg) is approximated by
    taking the Monte Carlo samples from the distribution. These final three equations
    give us the complete way to iteratively train all the parameters for a given dataset.
    Training will be a case of updating our parameters by some learning rate by these
    gradients.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth restating on a conceptual level what is going on here. v denotes
    the visible variables, the data from the world on which we are learning. h denotes
    the hidden variables, the variables we will train to generate visible variables.
    The hidden variables do not explicitly represent anything, but through training
    and minimizing the energy in the system, they should eventually find important
    components of the distribution we are looking at. For example, if the visible
    variables are a list of movies, with a value of 1 if a person likes the movie
    and 0 if they do not, the hidden variables may come to represent genres of movie,
    such as horror or comedy, because people may have genre preferences, so this is
    an efficient way to encode people's tastes.
  prefs: []
  type: TYPE_NORMAL
- en: If we generate random samples of hidden variables and then activate the visible
    variables based on this, it should give us a plausible looking set of human tastes
    in movies. Likewise, if we set the visible variables to a random selection of
    movies over successive activations of the hidden and visible nodes, it should
    move us to find a more plausible selection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation in TensorFlow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have gone through the math, let's see what an implementation of
    it looks like. For this, we will use TensorFlow. TensorFlow is a Google open source
    mathematical graph library that is popular for deep learning. It does not have
    built-in neural network concepts, such as network layers and nodes, which a higher-level
    library such as Keres does; it is closer to a library such as Theano. It has been
    chosen here because being able to work directly on the mathematical symbols underlying
    the network allows the user to get a better understanding of what they are doing.
  prefs: []
  type: TYPE_NORMAL
- en: TensorFlow can be installed directly via `pip` using the command `pip install
    tensorflow` for the CPU version or `pip install tensorflow-gpu` if you have NVidea
    GPU-enabled machine.
  prefs: []
  type: TYPE_NORMAL
- en: We will build a small restricted Boltzmann machine and train it on the MNIST
    collection of handwritten digits. We will have a smaller number of hidden nodes
    than visible nodes, which will force the RBM to learn patterns in the input. The
    success of the training will be measured in the network's ability to reconstruct
    the image after putting it through the hidden layer; for this, we will use the
    mean squared error between the original and our reconstruction. The full code
    sample is in the GitHub repo [https://github.com/DanielSlater/PythonDeepLearningSamples](https://github.com/DanielSlater/PythonDeepLearningSamples)
    in the `restricted_boltzmann_machine.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the MNIST dataset is used so ubiquitously, TensorFlow has a nice built-in
    way to download and cache the MNIST dataset. It can be done by simply calling
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download all the MNIST data into `MNIST_data` into the `"MNIST_data/"`
    directory, if it is not already there. The `mnist` object has properties, `train
    and test`, which allow you to access the data in NumPy arrays. The `MNIST` images
    are all sized 28 by 28, which means 784 pixels per image. We will need one visible
    node in our RBM for each pixel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A placeholder object in TensorFlow represents values that will be passed in
    to the computational graph during usage. In this case, the `input_placeholder`
    object will hold the values of the `MNIST` images we give it. The `"float"` specifies
    the type of value we will be passing in, and the `shape` defines the dimensions.
    In this case, we want 784 values, one for each pixel, and the `None` dimension
    is for batching. Having a None dimension means that it can be of any size; so,
    this will allow us to send variable-sized batches of 784-length arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`tf.variable` represents a variable on the computational graph. This is the
    *W* from our preceding equations. The argument passed to it is how the variable
    values should first be initialized. Here, we are initializing it from a normal
    distribution of size 784 by 300, the number of visible nodes to hidden nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These variables will be the `a` and `b` from our preceding equation; they are
    initialised to all start with a value of 0\. Now we will program in the activations
    of our network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This represents the activation of the hidden nodes, ![Implementation in TensorFlow](img/00194.jpeg),
    in the preceding equations. After applying the `sigmoid` function, this activation
    could be put into a binomial distribution so that all values in the hidden layer
    go to 0 or 1, with the probability given; but it turns out an RBM trains just
    as well as the raw probabilities. So, there''s no need to complicate the model
    by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the reconstruction of the visible layer, ![Implementation in TensorFlow](img/00195.jpeg).
    As specified by the equation, we give it the `hidden_activation`, and from that,
    we get our sample from the visible layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now compute the final sample we need, the activation of the hidden nodes
    from our `visible_reconstruction`. This is equivalent to ![Implementation in TensorFlow](img/00196.jpeg)
    in the equations. We could keep going with successive iterations of hidden and
    visual activation to get a much more unbiased sample from the model. But it doing
    just one rotation works fine for training:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we compute the positive and negative phases. The first phase is the correlation
    across samples from our mini-batch of the `input_placeholder`,![Implementation
    in TensorFlow](img/00197.jpeg) and the first `hidden_activation`, ![Implementation
    in TensorFlow](img/00194.jpeg). Then the negative phase gets the correlation between
    the `visible_reconstruction`, ![Implementation in TensorFlow](img/00195.jpeg)
    and the `final_hidden_activation`, ![Implementation in TensorFlow](img/00196.jpeg):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `assign_add` on our `weights` variable creates an operation that, when
    run, adds the given quantity to the variable. Here, 0.01 is our learning rate,
    and we scale the positive and negative phases by that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create the operations for scaling the hidden and visible biases. These
    are also scaled by our 0.01 learning rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `tf.group` creates a new operation than when called executes all the
    operation arguments together. We will always want to update all the weights in
    unison, so it makes sense to create a single operation for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This `loss_op` will give us feedback on how well we are training, using the
    MSE. Note that this is purely used for information; there is no backpropagation
    run against this signal. If we wanted to run this network as a pure autoencoder,
    we would create an optimizer here and activate it to minimize the `loss_op`:?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a session object that will be used for running the computational
    graph. Calling `tf.initialize_all_variables()` is when everything gets initialized
    on to the graph. If you are running TensorFlow on the GPU, this is where the hardware
    is first interfaced with. Now that we have created every step for the RBM, let''s
    put it through a few epochs of running against MNIST and see how well it learns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time we call `mnist.train.next_batch(100)`, 100 images are retrieved
    from the `mnist` dataset. At the end of each epoch, the `mnist.train.epochs_completed`
    is incremented by 1, and all the training data is reshuffled. If you run this,
    you may see results something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see what an image reconstruction looks like by running the following
    command on the `mnist` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of what the reconstructed images with 300 hidden nodes
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation in TensorFlow](img/00198.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3\. Reconstructions of digits using restricted Boltzmann machines with
    different numbers of hidden nodes
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with 300 hidden nodes, less than half the number of pixels,
    it can still do an almost perfect reconstruction of the image, with only a little
    blurring around the edges. But as the number of hidden nodes decreases, so does
    the quality of the reconstruction. Going down to just 10 hidden nodes, the reconstructions
    can produce images that, to the human eye, look like the wrong digit, such as
    the 2 and 3 in Figure 3.
  prefs: []
  type: TYPE_NORMAL
- en: Deep belief networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we imagine our RBM is learning a set of latent variables that generated
    our visible data and we were feeling inquisitive, we might wonder: can we then
    learn a second layer of latent variables that generated the latent variables for
    the hidden layer? The answer is yes, we can stack RBMs on top of previously trained
    RBMs to be able to learn second, third, fourth, and so on, order information about
    the visible data. These successive layers of RBMs allow the network to learn increasingly
    invariant representations of the underlying structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deep belief networks](img/00199.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4 Deep belief network, containing many chained RBMs
  prefs: []
  type: TYPE_NORMAL
- en: These stacked RBMs are known as deep belief networks and were the deep networks
    used by Geoffrey Hinton in his 2002 paper *Training Products of Experts by Minimizing
    Contrastive Divergence*, to first produce the record-breaking results on MNIST.
    The exact technique he found useful was to train successive RBMs on data with
    only a slight reduction in the size of the layers. Once a layer was trained to
    the point where the reconstruction error was no longer improving, its weights
    were frozen, and a new RBM was stacked on top and again trained until error rate
    convergence. Once the full network was trained, a final supervised layer was put
    at the end in order to map the final RBM's hidden layer to the labels of the data.
    Then the weights of the whole network were used to construct a standard deep feed-forward
    neutral network, allowing those precalculated weights of the deep belief network
    to be updated by backpropagation.
  prefs: []
  type: TYPE_NORMAL
- en: At first, these had great results, but over time, the techniques for training
    standard feed-forward networks have improved, and RBMs are no longer considered
    the best for image or speech recognition. They also have the problem that because
    of their two-phase nature, they can be a lot slower to train. But they are still
    very popular for things such as recommender systems and pure unsupervised learning.
    Also, from a theoretical point of view, using the energy-based model to learn
    deep representations is a very interesting approach and leaves the door open for
    many extensions that can be built on top of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen in this chapter two of the most powerful techniques at the core
    of many practical deep learning implementations: autoencoders and restricted Boltzmann
    machines.'
  prefs: []
  type: TYPE_NORMAL
- en: For both of them, we started with the shallow example of one hidden layer, and
    we explored how we can stack them together to form a deep neural network able
    to automatically learn high-level and hierarchical features without requiring
    explicit human knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: They both serve similar purposes, but there is a little substantial difference.
  prefs: []
  type: TYPE_NORMAL
- en: Autoencoders can be seen as a compression filter that we use to compress the
    data in order to preserve only the most informative part of it and be able to
    deterministically reconstruct an approximation of the original data. Autoencoders
    are an elegant solution to dimensionality reduction and non-linear compression
    bypassing the limitations of the principal component analysis (PCA) technique.
    The advantages of autoencoders are that they can be used as preprocessing steps
    for further classification tasks, where the output of each hidden layer is one
    of the possible levels of informative representations of the data, or a denoised
    and recovered version of it. Another great advantage is to exploit the reconstruction
    error as a measure of dissimilarity of a single point from the rest of the group.
    Such a technique is widely used for anomaly detection problems, where the relationships
    from what we observe and the internal representations are constant and deterministic.
    In the case of time-variant relationships or depending upon an observable dimension,
    we could group and train different networks in order to be adaptive, but once
    trained, the network assumes those relationships to not be affected by random
    variations.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, RBM uses a stochastic approach to sample and adjust weights
    to minimize the reconstruction error. The intuition could be that there might
    exist some visible random variables and some hidden latent attributes, and the
    goal is to find how the two sets are connected to each other. To give an example,
    in the case of movie rating, we can have some hidden attributes, such as film
    genre, and some random observations, such as the rating and/or review. In such
    topology, we can also see the bias term as a way of adjusting the different inherent
    popularities of each movie. If we asked our users to rate which movie they like
    from a set made of *Harry Potter*, *Avatar*, *Lord of The Ring*, *Gladiator*,
    and *Titanic*, we might get a resulting network where two of the latent units
    could represent science fiction movies and Oscar-winning movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](img/00200.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Example of possible RBM where only the links with a weight significantly different
    from 0 are drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Although the attributes of SF and Oscar-winning are deterministic (effectively,
    they are attributes of the movie), the ratings of the users are influenced by
    that in a probabilistic way. The learned weights are the parameters that characterize
    the probability distribution of the movie rating (for example, Harry Potter with
    five stars), given that the user likes a particular genre (for example, science
    fiction).
  prefs: []
  type: TYPE_NORMAL
- en: In such a scenario, where the relationships are not deterministic, we want to
    prefer using RBM to using an autoencoder.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, unsupervised features learning is a very powerful methodology
    to enrich feature engineering with the minimum required knowledge and human interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Standing to a few benchmarks ([Lee, Pham and Ng, 2009] and [Le, Zhou and Ng,
    2011]) performed in order to measure the accuracy of different feature learning
    techniques, it was proved that unsupervised feature learning improved accuracy
    with respect to the current state of the art.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few open challenges though. If you do have some knowledge, it is
    always good not to discard it. We could embed that knowledge in the form of priors
    during the initialization step, where we might handcraft the network topology
    and initial state accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, since neural networks are already hard to explain and are mostly approached
    as black box, having an understanding of at least the input features could help.
    In our unsupervised feature learning, we want to consume raw data directly. Hence,
    understanding how the model works becomes even harder.
  prefs: []
  type: TYPE_NORMAL
- en: We will not address those issues in this book. We believe that it is too early
    to make some conclusions and that further evolutions of deep learning and the
    way people and businesses approach those applications will converge to a steady
    trustworthiness.
  prefs: []
  type: TYPE_NORMAL
